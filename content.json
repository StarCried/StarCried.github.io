{"meta":{"title":"StarCried 的狼窝","subtitle":"Nothing is true. Everything is permitted.","description":"StarCried 的狼窝，记录算法竞赛知识（OI, ACM）以及学习、工作、生活中的点点滴滴。","author":"StarCried","url":"https://StarCried.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2024-08-01T09:38:50.672Z","updated":"2024-08-01T09:38:50.672Z","comments":true,"path":"categories/index.html","permalink":"https://starcried.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-08-02T02:22:00.142Z","updated":"2024-08-02T02:22:00.142Z","comments":true,"path":"friends/index.html","permalink":"https://starcried.github.io/friends/index.html","excerpt":"欢迎访问","text":"欢迎访问 如果您想添加友链，请联系我，格式如下： title avatar url"},{"title":"","date":"2024-08-11T13:00:39.513Z","updated":"2024-08-11T13:00:39.513Z","comments":true,"path":"404.html","permalink":"https://starcried.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-08-09T00:27:45.554Z","updated":"2024-08-09T00:27:45.554Z","comments":true,"path":"about/index.html","permalink":"https://starcried.github.io/about/index.html","excerpt":"","text":"我是谁截止于2024年，我是一名本科生，上海交通大学强基数学专业。日常在上海与陕西活动。基本属性如下： 网名：Star_Cried。 生日：4月30日。 信息学竞赛：退役 OIer，ACMer，因此博客内有很多算法竞赛题解。 Furry：自设名为 微光，StarCried 取自星星的声音。 外文名：Ezio，多用于游戏 ID。 兴趣爱好运动什么都想试一试，感受世界和自我最原始直接的方式。 骑行：有一辆中等的自组公路车。 滑雪：单板玩家，去过两趟大雪场，想学些简单的花式，但目前没有装备、时间、资金。 羽毛球：能陪练的水平。 乒乓球：能陪练的水平。 台球：能陪练的水平。 游泳：淹不死的水平。想学自由泳。 健身：为其他运动打基础。 艺术学会如何感受，进而如何表达，最终真正了解自己的途径。 小提琴：从小学，不算专业，现在在上海交通大学学生乐团。 其他乐器：尝试学习吉他、钢琴，目的是为了想尝试的编曲增加乐理基础。 音乐：最近喜欢古典、爵士和其他轻音乐（器乐或电子），喜欢悠扬的、节奏感强、有情绪的纯音乐。 绘画：抽空自学，画了点表情包，可以在 QQ 和微信搜索“小狼微光”找到。想进一步学习。 摄影：作为绘画基础，想在旅行时记录风景和自己。有运动相机，但没有专业摄影设备。 微光微光是我展示和提升自己的一种途径。基本上，他是一个更好的我，赋予了我所期望的一些美好特质；然而他又不脱离实际，没有非凡的能力，只是尽力把能做的事做好，寻找自己的意义。 微光可以存在于各种世界观，有着类似但不完全相同的背景故事。为了完善他的形象，我已经做了一些工作： 设定图（直腿与曲腿） 3D 模型（直腿） 兽装（在做） 还有很多东西可以做： Live2D 模型（嵌入网页） 主题曲（前置技能：编曲） 更多的图（前置技能：绘画） 游戏（前置技能：…） 更完善标准的人物设定（前置技能：绘画） 我希望能让大家认识他，也通过他认识大家，以及我自己。 愿望已完成 和其他人（小提、大提）一起完成 Pachelbel’s Canon 合奏。 在生日的时候骑车去海边看日出。 目前最长单次骑行距离约 160 公里。 未完成 从上海骑回陕西。 体验一次蹦极和跳伞。 骑行川藏。 学会编曲，能完全自由地表达自己的声音。 学会绘画和设计，能自主创作有风格的作品。 获得一定的曝光度。 见识更广阔的世界。 登顶珠穆朗玛峰。 联系方式Githubhttps://github.com/StarCriedBiliBilihttps://space.bilibili.com/351621972Titterhttps://twitter.com/CriedStar58579洛谷https://www.luogu.com.cn/user/280015"},{"title":"","date":"2024-08-07T08:00:00.351Z","updated":"2024-08-07T08:00:00.351Z","comments":true,"path":"gallery/index.html","permalink":"https://starcried.github.io/gallery/index.html","excerpt":"","text":"微光的画廊 加载缓慢，请耐心等待 AliceHenry1Henry2SamiHenrySamifalling2Rappylcy2024.1小猫小猫星夜3遥夜"},{"title":"","date":"2024-08-01T08:03:45.762Z","updated":"2024-08-01T08:03:45.762Z","comments":true,"path":"mylist/index.html","permalink":"https://starcried.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-08-01T08:47:00.398Z","updated":"2024-08-01T08:47:00.398Z","comments":true,"path":"tags/index.html","permalink":"https://starcried.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"博客园 Cnblogs 迁移到 Github Pages","slug":"博客园-Cnblogs-迁移到-Github-Pages","date":"2024-08-06T12:11:51.000Z","updated":"2024-08-10T14:25:42.215Z","comments":true,"path":"2024/08/06/博客园-Cnblogs-迁移到-Github-Pages/","permalink":"https://starcried.github.io/2024/08/06/%E5%8D%9A%E5%AE%A2%E5%9B%AD-Cnblogs-%E8%BF%81%E7%A7%BB%E5%88%B0-Github-Pages/","excerpt":"","text":"前言大概是四年以前，我开通了我的博客园账号。 博客是一个很原始的互联网形式。我并没有使用其社区功能，只是当做一个跨平台电子笔记本来用。如果写的文章能给别人帮助的话，那就再好不过了。 我的第一个博客文章标题是《快速幂》。当时我才初学信息竞赛，根本没有完全理解快速幂的原理，也不知道矩阵是什么。然而，我还是从晚上别人的博客里抄来了快速幂的公式，甚至包括矩阵快速幂，复述了一遍，通过这个过程进行学习。当时我甚至不会用 Markdown，就使用博客园默认的 TinyMCE 编辑器一个个手动点击来输入上标下标。 那篇博客的最后一句话是“大家一起进步吧XD”。我想起我当时是作为一个博主的身份，以自己的文章会被很多人看到的心态写下这篇博客。内容写得十分努力，然而也漏洞百出。在 NOI 结束之后，我把这篇文章错误的地方都删掉了，以免误人子弟。 从 2020 年 5 月 5 日，停课搞竞赛开始，我写了近有 150 多篇文章，总计 34500 多阅读量。很多之前的文章在不经意间已经有几百的阅读量了，有一篇题为《高斯消元——行列式》的文章甚至达到了 2600+。然而其内容却非常敷衍，透露出一股刚学竞赛的愚蠢。我不止一次地想把这些早年文章修改整理一下，学竞赛的时候，竞赛结束的时候，高考后的假期。然而，我始终没有动手。 总是发现，学做一些事情，就像小时候牙牙学语，并不总是按部就班，而是整个人倏地置身其中，任由自己不知所措、摸爬滚打地成长。学习竞赛就是一个很好的例子。我抄过很多题解，抄过很多代码，在那许多不在教室而在机房度过的日夜里死磕看不懂的题目，在无数坐牢般的比赛中用自己的想法得到尽可能高的分数。我急着摆脱前一天差劲的自己，尽可能多地去学习新的东西，去刷更多的题，让自己 OJ 的过题数飞涨。然而，在每场模拟赛和正式比赛后，我却没有踏踏实实地去补题，去反思，去总结。我总是记不住上次比赛的题目，甚至到现在都不知道高考那些题做错了。这样的学习方式可能对我这种只有一年时间的竞赛生收益很快，但上限不高。也许，这就是我差别人的地方。博客园的样子就是很好的反映。 我从来没有记日记的习惯，也并不喜欢整理笔记，尤其是在学期已经结束、再也不会上这门课之后。但是现在我发现，竞赛带给我的感觉却很不一样。不只是因为上大学后开始打 ACM，而且我发现之前在高中学到的很多东西，在很多不经意的时刻会再次出现。大学后的每一门新的课程，都让我重新审视之前学过的知识。诸如微积分、线性代数、概率论、数论等等，我都有了新的认识。每每在课堂上学到、在题目中用到它们，我都会想到我在很久以前，又或许是不久之前，在电脑前一点点敲下关于它们的不求甚解的文章，抄背没有完全理解的模板。 因此，在这次暑假的时间里，我下定决心建一个全新的博客，好好装扮它，作为我的心灵庇护所。我想把之前欠的账尽可能还上，不再被回旋镖打到。之前，我总想着快速地把上一秒的自己甩到身后，仿佛那是一个拖累我的“别人”。但现在我发现，每段时间的我都确实是我，无论他叫 Star_Cried 还是微光。他们都没有在拖累我，正是他们一步步推动着我成为现在的自己。 成长的路程总是有舍有得。Github 相较于博客园，更难被搜索到，更难以访问，而且我会失去之前的阅读量。不过我建立博客最初的目的，也只是为自己而写而已。这次的迁移，我不想它作为一个新的开始，而是将我之前所有的一切都搬过来，擦拭干净，摆放整齐。 欢迎访问：Star_Cried 的博客园。(不再维护，仅留档) 博客迁移下载博客我觉得各大博客网站为了自己的用户量都不会去给迁移出去的方式。博客园也是如此。如果你的博文不多，那你大可以手动复制；但是我的文章有 200 篇左右，手动复制实在是累人。 网上有很多迁移的办法，大多数都是个人写的小工具。我试了很多，最终使用这个 cnblogs-blogger-downloader 将文章成功导出，效果不错。其它工具由于博客园版本更新频繁的原因，大多数已经不再适用了。我用的工具在发布日期仍可用。 网上的迁移方法大致分为几种： 网页爬虫。这种访客形式的爬虫工具无法访问文章源码，只能获取到文章的 HTML 页面，无法获取到文章的 Markdown 格式。 博客园导出工具。博客园可以备份文章为 xml 文件，许多工具对该文件进行解析，可以获取到文章的 Markdown 格式。然而，我试用了许多工具，最晚到 2022 年，这些工具都已无法使用。对照 xml 文件发现，现在的文件格式和之前有较大出入，代码字符串匹配的方式无法识别。 MetaWeblog。cnblogs-click-backup-util利用多博客同步的 API 接口的工具，理论上可行。但我不知为何在验证部分失败了。(后收到回复为用户名和博客地址不同，没有继续尝试) 博主端爬虫。cnblogs-blogger-downloader，感谢这位作者的开源。该工具利用 Cookie 访问博客园后台，将文章按分类导出，直接导出源码。非 Markdown 文章会导出 html 格式，Markdown 理论上可以解析。 导入博客将 Markdown 文件放在一个目录下，用脚本添加 Hexo 的 Front-Matter 头信息，再放入 Hexo 的 _posts 文件夹即可。 123456789101112131415161718192021222324252627282930313233343536import os# 定义要添加的前缀模板prefix_template = &quot;&quot;&quot;---title: &#123;title&#125;categories: [OI]date: 2022-04-30 00:00:00tags: [博客园]---&quot;&quot;&quot;# 定义目标文件夹folder_path = &#x27;./cnblog/ALL&#x27;# 遍历文件夹中的所有文件for filename in os.listdir(folder_path): if filename.endswith(&#x27;.md&#x27;): file_path = os.path.join(folder_path, filename) with open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file: content = file.read() # 获取文件名（不包括扩展名） title = os.path.splitext(filename)[0] # 生成带有文件名的前缀 prefix = prefix_template.format(title=title) # 添加前缀 new_content = prefix + content # 写回文件 with open(file_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file: file.write(new_content)print(&quot;前缀已成功添加到所有.md文件中。&quot;) 后记我将所有博客进行了导入，并对所有文章进行了删改整理。 非 Markdown 格式的文章，由于其基本都是早期文章，内容不精，进行删改转换格式。 对大多数文章进行了格式调整。有空修改内容。 图片引用原地址，等挂了再修改。 所有导入文章添加了博客园的 tag，方便分类。 所有导入文章的日期默认为 2022-04-30，之后会对日记内容时间进行修改。","categories":[{"name":"教程","slug":"教程","permalink":"https://starcried.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://starcried.github.io/tags/blog/"}]},{"title":"利用 Github pages 和 hexo 搭建自己的博客","slug":"利用-Github-pages-和-hexo-搭建自己的博客","date":"2024-08-01T09:25:23.000Z","updated":"2024-08-07T08:06:00.576Z","comments":true,"path":"2024/08/01/利用-Github-pages-和-hexo-搭建自己的博客/","permalink":"https://starcried.github.io/2024/08/01/%E5%88%A9%E7%94%A8-Github-pages-%E5%92%8C-hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"前言Hello world! 这是我的第一篇博客文章，记录这个博客是如何搭建的。由于我并非专业人士，仅记录我的搭建过程和遇到的问题，并且不详细解释每一步的操作。如有疑问，请访问参考部分。 目前该博客处于美化阶段，主要内容为替换默认图片（背景，图标等）。博主艺术创作能力有限，欢迎提供帮助。 待办 124 默认封面背景274 打赏组件589 qrcode807 视差壁纸1237 cursor settingsLive2D 搭建博客博客可以像搭建访问量较大的网站一样实现。一般来说，搭建网站需要购买服务器、域名、备案、购买云服务器等一系列繁琐的流程，如果要制作静态网页还需要自己手搓或者利用 WordPress 等 CMS 系统。而用 GitHub Pages 和 Hexo 搭建博客，可以快速搭建个人博客，而且不需要购买服务器、域名、备案等繁琐的流程。 Github Pages 是 Github 提供的静态页面托管服务，可以直接将静态网页托管到 Github Pages 仓库中，然后通过域名访问。相较于其他静态页面托管服务，Github Pages 免费、稳定、安全，但是在国内访问和加载资源较慢，适合个人博客。 理论上说，你完全可以自己手搓 HTML 页面和脚本完成博客。但对于像我这样的新手或者重点在成果而非过程的人来说，使用现成的框架和工具可以节省大量时间。Hexo 是一个基于 Node.js 的静态博客框架，它可以快速生成静态网页，并且可以用 Git 部署到 GitHub Pages。 创建 GitHub Page登录 Github，创建一个名为 username.github.io 的仓库，其中 username 是你的 GitHub 用户名。这就是你的 GitHub Pages 站点的仓库。可以通过访问 https://username.github.io 来访问你站点的 index.html 文件。 安装配置 Git从 Git 官网 下载安装。 因为 Git 是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。在命令行输入如下： 12git config --global user.name &quot;user_name&quot; # user_name填入GitHub用户名git config --global user.email &quot;user_email&quot; # user_email填入GitHub注册的邮箱 查看已设置的用户名和邮箱，在命令行输入如下： 12git config user.namegit config user.email 配置 SSH key: 1ssh-keygen -t rsa -C &quot;user.email&quot; # user.email为GitHub上注册的邮箱 三个默认设置就可以，不需要密码。在 C 盘 /Users/your_user_name/.ssh 目录下找到 id_rsa.pub 公钥文件，复制里面的内容，在 GitHub_Settings_keys 上新建添加 SSH key。 输入以下命令检测是否配置成功： 1ssh -T git@github.com 如果出现 Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 字样，则配置成功。 如果返回 Connection closed by 20.205.243.166 port 22，有可能是代理的问题。请关闭你的代理清除缓存（重启）并重试。 安装 Node.js从 Node.js 官网 下载安装。 我用 Package Manager 安装 Node.js 遇到了问题，可选择使用 Prebuilt Installer 安装。 安装 Hexo在命令行中输入以下命令安装 Hexo： 1npm install -g hexo-cli 创建一个文件夹作为你的博客配置文件夹所在位置，并在其中打开命令行。输入 123hexo init blogcd blognpm install 即可创建你的博客项目。其中 blog 是你的博客文件夹名。之后所有的操作都在 blog 文件夹中进行。 配置 Hexo安装 hexo-deployer-git 插件，用于部署到 GitHub Pages。 1npm install hexo-deployer-git --save 编辑根目录下的 _config.yml 文件，配置你的 deploy 部分站点信息。 _config.yml1234deploy: type: git repository: git@github.com:StarCried/StarCried.github.io.git #你的仓库地址 branch: main 现在你已经搭建好了你的博客，可以进行本地预览和部署。 如果你本地预览正常而部署后静态资源未加载（比如主题格式混乱），请检查你的 _config.yml 文件中的 url 和 deploy 部分是否正确。 除了 deploy 部分，你还需要配置其他部分，包括 site 等。 使用 HexoHexo 有以下常用命令： 123456hexo init # 创建一个新的 Hexo 站点hexo clean # 清除缓存文件hexo generate # 生成静态文件hexo deploy # 部署到 GitHub Pageshexo server # 启动本地预览服务器hexo new &lt;layout&gt; &lt;title&gt; # 创建新文章 Hexo 的工作流程是，在项目中进行主题配置（_config.yml 文件），用 hexo new 命令创建新文章、在 _posts 文件夹中编写文章后，运行 hexo generate 命令生成静态文件（要部署到 Github Pages 的文件，在 .deply_git 文件夹中），然后运行 hexo deploy 命令部署到 GitHub Pages。 美化博客Hexo 官方提供了丰富的主题，你可以在 官方主题发布页 中查看。注意，大多数主题是由社区提供的，其配置方式和插件支持等千差万别，请根据自己的需求选择适合的主题。我是用的是 volantis 主题，阅读文档以自定义美化。 主题安装参考 官方文档 安装主题。 主题文件夹下也有一个配置文件 /node_modules/hexo-theme-volantis/_config.yml。在博客根目录的 _config.yml 文件旁边新建一个文件 _config.volantis.yml ，这个文件中的配置信息优先级高于主题文件夹中的配置文件。将配置文件复制过来修改，以免配置丢失。 使用 npm 安装主题的配置文件在如上位置，而使用传统方式安装的主题配置文件在 theme 文件夹下。 遵循官方文档，修改配置文件 _config.volantis.yml 中的配置信息即可。 使用资源在配置文件中，你可能经常看到图标使用 volantis-static 位置的图片资源。这是主题的官方静态资源库，可以直接使用里面的资源。 如果你想上传自己的资源，最简单的办法是使用图床或者另开一个 github 仓库，然后将图片链接替换到配置文件中。如果你觉得加载速度太慢，也可以使用 cdn 服务，参见文档。 Live2D 插件除了主题整合的可以直接使用的插件，你也可以自己装额外插件。在进阶玩法里有一个看板娘插件（实际是将 Live2D 模型渲染到页面上）。我想更进一步使用微光模型。 待更新 参考 GitHub-Hexo-从零开始搭建个人博客 GitHub Pages + Hexo搭建个人博客网站，史上最全教程 volantis 官方文档 hexo 官方文档","categories":[{"name":"教程","slug":"教程","permalink":"https://starcried.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://starcried.github.io/tags/blog/"}]},{"title":"兽装制作","slug":"兽装制作","date":"2024-06-02T03:32:29.000Z","updated":"2024-08-09T00:36:49.367Z","comments":true,"path":"2024/06/02/兽装制作/","permalink":"https://starcried.github.io/2024/06/02/%E5%85%BD%E8%A3%85%E5%88%B6%E4%BD%9C/","excerpt":"","text":"前言学期末开始的工程，导致现在工程停滞。等待更新。 以微光为例。包括兽头、爪子和尾巴三个部分。花纹较少，有少量头发。 粗体文字为重要，删除线文字为微光未选。 爪子材料 四面弹绒布 毛布 棉花 衬底布（可选） 滴胶指甲（可选） 工具 电动剃毛器 针线：粗针粗线 剪刀 美工刀 打板纸：牛皮纸或其他可以画图和裁剪的纸 热熔胶枪（可选，滴胶指甲） 制作步骤 使用打板纸对照手型画出爪子的形状，并将其剪切为爪掌、爪指各部分，且正反各一面。正面可以加入肉垫的形状，肉垫的洞不用裁走，裁剪外缘即可。可以用笔标注版型的名称和对齐线。 按版型在毛布上标出缝合位置。注意毛布的方向，毛布朝向应向外。可以用笔标注对应版型的名称和对齐线。 在裁切毛布前先剃毛。（可选） 使用美工刀裁切布料。（手指部分可以做成短毛的，比较好看）。 用四面弹绒布裁出肉垫的形状并缝合到爪掌和爪指上。 如用布指甲，则需独立打板缝合填充。（可选） 有毛的一面向内缝合爪子各部分。（可选：如用布指甲，在缝爪子对应位置时将布指甲缝在上面） 如肉球有体积，则将手指的内部毛布上割开并塞入棉花，最后缝上缺口。 如果需要衬底，使用同样拼合完整的版型裁两片衬底布缝合边缘，并贴合毛布的背面缝一圈固定在毛布上。 最后，将爪子翻过来，使用包边布将边缘缝合固定。 如用滴胶指甲，此时用热熔胶将其贴到对应位置。（可选）。 兽头微光使用打印头骨和 EVA 制作兽头基底。可使用海绵直接制作，在此不做讨论。 准备工作自己设计头骨头骨骨架支撑结构，决定了大体形状和大小，根据自己头的大小和形象风格确定。 可选用商用头骨，当然也可以自己设计 3D 模型进行打印。由于正面面部结构比较复杂精细，而后脑可能需要减重或者柔软和舒适性，所以头骨可以全打印或只打印面部。 微光使用的是自己设计的 3D 模型，使用 Blender 软件进行 3D 建模面部，导出为 stl 文件，即可在 3D 打印机上打印。没有打印机的话，可以找接代打的装师或网上代打。注意自己建模的话，最好找有经验的装师先检查一下模型，以免导致打出来不可用。微光找的工作室是绒光芥子。 如果自己设计头骨，模型文件具有自己的版权，请注意防止盗用。 眼睛需设计好眼睛的图案。自己画或者请人画都行。测量好眼睛的尺寸，并在打印前预留好足够的空间。 材料 打印头骨（用砂纸打磨好边缘） EVA 毛布 打印防尘网（眼睛） 棉花 亚克力球（眼球，250mm,可选） 透明硬塑料片 牙齿（可选，打印或布） 工具 电动剃毛器 针线：粗针粗线 剪刀 美工刀 布基胶带 卫生纸或保鲜膜 记号笔 热熔胶和热熔胶枪 电烙铁、线锯（切割亚克力球，可选） 制作步骤 基于打印头骨使用EVA和海绵制作兽头的基座 将EVA裁剪成多条约3厘米宽的长条， 制作眼眶 将亚克力球放到头骨眼眶处，贴上布基胶带并使用记号笔画出眼眶的轮廓 使用电烙铁或者线锯将亚克力球根据记号笔的线条剪成需要的形状 使用剪刀剪出一条宽度约为3厘米的eva条作为眼眶的边缘，使用热熔胶围绕贴在切好的亚克力球 裁剪好突出来的部分，预留平均1cm的宽度，另外一面需要裁剪的平（贴在防尘网的一面） 先在防尘网的背面贴上一层塑料片，然后将整个眼眶贴到防尘网的正面上（瞳孔一定要对准，这一步容错率较低）并裁剪突出来的部分 将做好的眼眶使用热熔胶贴在头骨的眼眶上 制作耳朵 使用打板纸裁剪出耳朵大约的形状，比划比划 细修形状，并将转移到海绵上 使用海绵制作出耳朵的基座然后将耳朵贴在头骨上 使用保鲜膜包裹需要获取的表面，然后用布基胶带贴满整个表面 使用记号笔画上需要的花纹和分割线，转移到毛布上（注意毛向） 裁布并缝纫 使用热熔胶将缝好的毛布贴到耳朵的表面 打板 - 使用保鲜膜包裹需要获取的表面，然后用布基胶带贴满整个表面 尾巴准备材料材料成本材料采购截止时间为 2024&#x2F;6，除了头骨和部分已有材料和工具，其他材料均为网上购买。 下标仅列出购置材料和工具的成本，不包括已有材料和工具。 名称 数量 单价&#x2F;元 总价&#x2F;元 头骨 1 50 50 毛布（起司毛） 1 75&#x2F;半码 75 毛布（冰淇淋毛） 2 95&#x2F;半码 195 电动剃毛器 1 178 178 亚克力球 1 24 24 布基胶带 3 12 36 卫生纸 1 打印防尘网 1 电烙刀 1 18 18 不织布 1 8.5 8.5 棉花 1 17&#x2F;2斤 17 四面弹布 2 5.5 11 头模 1 30.8 30.8 拉链 1 4.4 4.4 其他 1 27.85 27.85 总计 12 注：头骨部分，截止时间代打参考价格为 PLA 0.15元&#x2F;g。","categories":[{"name":"微光","slug":"微光","permalink":"https://starcried.github.io/categories/%E5%BE%AE%E5%85%89/"}],"tags":[{"name":"手工","slug":"手工","permalink":"https://starcried.github.io/tags/%E6%89%8B%E5%B7%A5/"}]},{"title":"3.13 服药记录","slug":"3.13 服药记录","date":"2024-03-13T13:48:00.000Z","updated":"2024-08-11T15:47:00.181Z","comments":true,"path":"2024/03/13/3.13 服药记录/","permalink":"https://starcried.github.io/2024/03/13/3.13%20%E6%9C%8D%E8%8D%AF%E8%AE%B0%E5%BD%95/","excerpt":"本文含有隐私信息，如需访问请联系微光。","text":"cfa2926ad01c1ca5b72f4176a524df63b8ef215ab9ddd5fcf3035f1054938484b410bc6c8d8d8b3ea8dac432d7b89eac8f2cd150a58903adb14be53a0f356338bd9d3387b9a2d0ed62d5945146216b99030dc586075ff5e8a57f6cfa04f8e5c22f0fff5b4b289a482dce81d9416a8ce1300986d73cd5ac3bdec04a6942f033ccd7546ae8f1887cbf2d6c7b80b3227c226cbd9050bda9626ff2ca9b264e37cdc4e576126ad0ff1f2912dfc4d49f5e1b789c0d146ef4d659feac6558511c9220ce237cc68bc4bb3b6d7c653d6627766ed4eebe8bc685e589cae2adbf61326e51cdcd548e8174356334271d1a23f7d0ee3b96ec0cf9f1c0793ad8a8445d9813348c91697c1ce7ceb06bf2ce2365c84e499e4132a268b1733d31862f5ab994d17f767d3f0fcd51bfc0d6ad69f30b228431709dec4e89b70ac4aa33a36cfd26aecfa41de7aab6c8f878774f4aeff9b70ef089901e53bdcaadef9758d0a3a5879a132725fb3c4a900d766497ea24bff9351f429257c39759e5e3c29235436cc1be6b461775428b5b815ce40ca30d12bc9fc32b59e1e0f67ecf4d6d9e414ae3a66361704acffbf10a56f9b48a1e86fe9f9617a714958fc46ebc4dbddc3fc6a392fcd75f93d5710f08cf619b9d288a8efce8ec26dcf9cf2031f1f2845264e04f956ce612b75892c02e7bda08b1706057caf37b09bd998366974f733557716e885d187b26d1d2e6f883a2c1a2d479f34a74cfc14645003c2a0ba775e9db97ef5363185f7c9a71bd9842a8712d85feb3643168659f9e91e438ec43b3c56e521d5662771cf8f4b22efdb702e23f06e459d4115e12beed77e00e592db48548bf3576da0db750cacf18d748ec7269e54bb6ada962f59eaf09c90dfe2a996ae476251e233dd7000a6efd09d4664d4e9a2b912308debe07c7e843fab454a8d54ce6d5d07848172d27845173913da6a846bef6268c50317fba211a51ae927e1f4f4b5416c189aae1de0f2580e389923f940bd862512f0764b4348a24e15c5639d83e5a1889f134563e9a16c9a2f51c13e45f93b0a4ec30d89180e2a3406b981323d42a931682d6a0f69e83bb7e0fea7a7a3733bcdf66d75e82ebadd63d715c57d9ea905a41172e9faa33d288b9028054183dc86e5da02f34caed979f0556b5e9fed268df31c83af30dc21e8955a5dc2e74aa3f7f5fd27e3a14f9bf96322aad4369340301b4d4e282de2eacdc16181e5317e9f69bd3bd86d8decb4c7574cb2326d20f40e6fcb57878724ef418fa2a1143bbed600744a50872de12c31ad1fdeb8a044fe5fc941aa691bd4e5fc5934f400ced7eb62ebc02b6454ddb3cb4d9153cca3849834c14d5a3e5e354f240f92817ca05dd28d801ad5542d5283c740d3f2e453d77f2ae2421806ab058aa30f114035d6ba7f2a49c0b6be9020c06da9694eaeb25387015f5281a7855ae0700143ffa5f5105155751e3e9af713ded4779c56fee4625bb39dead044075c75607e4d9e2a90e2d5a916175bbca82b4dde97533c96ffe1b068155f85b7cea55498c8132d0339b59355ecf36e18526222fefe90c6e6d564a858b64274b4dbcbd8597175c903be9aa83819da1cae6d2d146c71d0c192bc0546d760d1b894adb3212121be6c1a7d1f5360e15c26efde664ddd05e9478ec5557f1af3188fb9121b7a3e8c94e86fb8e27f42c829f56fb60196839951a44a5e01bbebb6addbf322a5479587f3bfa0a9bd5a176261bc2648f7f20e1cc006da55f1c790087e95a094ebfa5879e5509a6befcb2e0028cce05bf4d874cf2eaa4ef9cebe5c2140e612c3b284cdbd03a7adedd03a423a773d7b9f71e28a33f9c757830338c1796053fa3f68c73b261faf079ce19a47fa665f1e4dd6eba521bfc2c4592bf6956927b8da9a986feface5dfbad90cb17cadcabf7b2ad4b6916c71bb9e93b100cbda9db7df756b24ba31e1507d1194a96f199cb695c0a309f45b1c55b4355767ef9852555dfe2646dfb71feefbff05117e677cb1b6aa50104c4a140ff10f98df48368a0d1efc9685f892da8f8385acbe7dce84cec61ead28eb338f6d9465ea021499272ff407400c65cfe30b5aa8a5c99a1316acbe09cdfc640375e3f994499fc9f3af47ff3b6a548c903fbdfb9221c4925d9e2dc383e30827fd54d218a4344cd44a05705af1479cbd7f0cc50dd401639b13e29c5e1c946adf110fa32f003f5e28028f060a91526c52c17b9ac183c20c287aca853797aa954b1acfdf44271921d62c1f7d143e5b7365eff6b6edd10cabd8c2d602c8262858f2508e8da24cc808a298686dcacd14f6fcab7485cc7586f54708e49f84f5595ae1f1f210c1e6576752d9db5a2c3bae8545af8d50e40e978636ee7ac72e88b7aae5205470e163f3a41bfb62da184a1ccd08152ccc430dd796c09c4b2f78fecd669209a78b09027e2b844ee68a27b31070b546ae7ee253d22269e434c02b9287e73f587ebbd984cd441bfd30c0ee37cef1da06c620caaaeec31c66de571348ea6ba2bfcd5973dcbcc341599ea219f87d39f72e171d71cac09aef0aec08d3c8d941a37514141f8672383d7c8ea336cf8d961d207b202b8319892f704b3332865e19b6e7a3b3109d0119d1f136406b24603adb21af7b8b47e5cbe2880e531b85ecfe1d8c1903a479ee9a5c367fd594a40c9bd0c4693d27e89175987d9a9cb2b1acbc251116676f0a77db7270764f8b7acee7c2586c73e36edc3088669577fd0d892931bbb6b7667cbe6e7d77b8bec3013f447d9c6d8636691e4a7e237e63c71ed1f650cbd7df3162e55c571a065e1502c773b360bc393be6d6fabe2946882fba40b78291ffbd2f11551a3fd8ac6eee224ad7df9ba53e8a533ed8556f5586ae7cfa948fd0294843919ad58b1c5fdb618f32d4440c0a3e8202fe0c411be225c618ba67f99d81abe21808b3620d074d47b0649b4c77c5080887e6269e0d981c6231cdcb0a10080ac8c43217a218721515aadd7c721f3e601e6c9912c89d0524b6675a2a98be5adcdacc5afb0fefa5fb7a42a9308ff39d40a259d526ff4624257a539d4ef95f3ea17e530253123b6abb37e21a146b975c006b99e4a9439c9e35c8bf7bc5f0a11837ea04ae29bed59b299f02ba46c1d2fd5529015e3e5dfe2efba020e2ab4c5030c7fb7f22a5cd3bb3e0e30 请输入微光提供的通行证：","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"Me","slug":"Me","permalink":"https://starcried.github.io/tags/Me/"}]},{"title":"新生……？","slug":"新生……？","date":"2023-10-09T14:01:00.000Z","updated":"2024-08-11T16:53:50.786Z","comments":true,"path":"2023/10/09/新生……？/","permalink":"https://starcried.github.io/2023/10/09/%E6%96%B0%E7%94%9F%E2%80%A6%E2%80%A6%EF%BC%9F/","excerpt":"","text":"2023.10.09 大概是国庆前一周的星期一，我去华山医院复诊，想去找z玩。然而他当天不在，回学校的路上冒犯了他。 也许是z的性格，他没有原谅我。这本来不是什么大事，但是我却无比在意。我自认为是因为他之前很照顾我，理所应当道歉。这种感觉持续了整个兽展，到今天。直到刚才，我可能对这种感觉的由来产生了怀疑。 我这种在意另一个人的看法的感觉，无比像之前的我。 从我认为之前的我已经死去时开始，我一直声称我目前爱的人只有我自己。既然如此，对于一个刚认识不久（实际上只有几面）的人，在确定对他没有其他感觉的情况下，我这种心情实际上算什么呢？ 这种希望取得他人认可或者谅解的心情，这种不适感，太熟悉了。如果把z换成任何一个另外对我好一点的人，我敢确定我会有相同的心情。 所以呢？我到底是想去的谁的认同？谁的原谅？我有我想象的那样，已经摈弃了之前的自己，获得了自信的、坚强的我的新生吗？ 看来过去的影子会一直笼罩着我。我不知道这是好是坏。至少我现在会很好地选择对象，倒也不是什么大问题。也许，我也不需要摆脱这影子。也许他会引导我做正确的事？ 无论怎样，我得先把这件事解决。 2023.10.27 停了一半的药（感觉确实有原因），借助 br 问了他一下，自然回答是没什么事。整个事情感觉就像是我莫须有地自作多情，然后骚扰他，然后自己结束。虽然我不知道他是怎么想的，并且他对我态度确实也没有很好，不管怎样我不能再想这件事了。 于是最近心情略乱，也没什么干劲。期中考结束，非常担心自己的成绩，感觉应该把更多的心思放到这里来。我心里分明知道，此时我不应该在任何其他人身上浪费时间。值得我花费时间的只有我自己。 我现在有很多想法，并且准备去实行。如果一切进展顺利，那么这些琐事自然也会按我的意思来。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"异维A酸","slug":"异维A酸","date":"2023-09-08T16:07:00.000Z","updated":"2024-08-11T16:54:42.425Z","comments":true,"path":"2023/09/09/异维A酸/","permalink":"https://starcried.github.io/2023/09/09/%E5%BC%82%E7%BB%B4A%E9%85%B8/","excerpt":"本文含有隐私信息，如需访问请联系微光。","text":"cfa2926ad01c1ca5b72f4176a524df63a6480dc114ce32dfc272f15a7d0ad2dc3cf08c8bd5d2be0a4814f3be4dcebb4a7a98d862bf956f1de75d9b8b957584bd58b5ee1d483a285e84d599a9ceb355f1de8a6916ee15dd3328357154aa933cc6ad1d4a812fabdab37b1df740732ceb5ca8ee75e6bee6a0c0b1580773d442debfc20e860ab92cdbf6dc02ef8892d637a7f25d9dfd354f41f44e38523ce286d1d198283be0078060f3d94ef57ceceb19b6bb2bbc2f07a8135574860097b78f16ef4864352283775d613a9e7cf877d6f88b9d90614169fe245bd9c2e8a81a2629e2a5332c676f374ec477df554c62f2453ca757c0d72b11538a410e85428fd403f22083350318597529352a2f6947bfac08cbb3b9d6f67f652a81372a5b8c96d677ad5855ebd6c5680f3a59481c0cd9030b9fbb9d487196da919362ec864215655a25f3c0b9be9ce21ef4bb398adadac32e45e2b04a15843e3b6f4feff36abeebb93a1a5ed5f39b3b90c0662d6ae7b36110196ea168ef202cb718db37108db1bed6f0f8240be374d01475ffed1438b97ec767490974f6e1e1c1046bcd019f1bb0481cf614f2968169b6a63d37759a25129a78227a1b0ff6b456b70cbb21fd6558c40050fd362e03eba65a6e50097e6ab5617f0810065a97db17fcf266e041c8373de70bd93f157607b385b3ac2654008270902f1cdf86be32000eaa56b6cb58edb23fd4b44733e0dafc774d1bd622fbfc19a79ec9503347cf01a04cd53c614779da634190419810d09cd7db9c7523ee2b21de501319608f5e5e199c4476d451caafade0c129fb69a23d0a771d47b50a5a99f30b94dc14567252c5b0d77ae5f061d0a986d7999ddd5026fe48be162c87c1ae0aa9649dc85c386638c1dc855d0803b268cb40ea43755cabcc14d6c0c7461ae60ad7c1eb8669eeda06f518347bdc06feb449d6aa626f51c230189d31afd2f88aeec676a74ff2b1a1ecc34e9f091089ffaf69b5be1682f71ae6feb01c0dcf8c00c2d6ebde2e411d05ba4376e9fccc386089cbd4b883dd6a046131f279b6c1c502a319f9038059238e45a232bb3667978aa346e3042997ecd36b9ed2b3746e9fd5e58a4f00c2227edb51ee55569c6e361f5f57b7fad63d88bfade974578513be6c13812ba71c629fab7bef6e1712c4fe487d997bd40e4bd57347c8eccb7138eec392498e7bfbde6cc3a20c4438f20bd44c5516d39e70d7da8a3584bec918fc213ebbaf9336eb3dfc938f4ebd11e30c6b9e90bcf6280d5fb768117f98bfe7d897eb1c3245804bea852f6504bdce0b50f93864fd469ebe0af92f98a8ac1242034b57e0c33a8d9782b048617625d7e6edcea1b95ade4a32a50629135bd6d30080fcf9f3ccc37f5a345bb7b86b5a45bed337e787a732e2c180d28b147ac9ec05bedcc5d56f1a8cd592e2cb63e08630b98cf055f7a1966483dd2f432a42af6cea9879f2b5016834beb8ca6d3b1fab473c9040c51271cce60bf8ed04d1ee30cdcc017bc8c728a3b43eafd5d1261c930b7d0fe19485e5e48da2de899ade0b5740d0d7e072c6ed696eb2968ef744a58873e8c738daf1d338fc86f0408aa61d110b701fca38ddf10dfed550151198164ebf1e8dd4644a6055ec32c73da863fb061bad0d894201e83c6064c82eedff34bb27177371d6c6032f6cac586a2d9fe543de6daf21f6f2f4f91c5288b5a80b81d54156d72b9d2d28986a572e1f95342b03501b4010650a53bf500fd727dd7d8a6c144277ce2ee63e48639c3ed4448d4f41f56287f5710f6d9a349dbe9a90aaf7b041cc440381251d5887668c7f7ad15dfabfe5daeb8a6fa0a375f9773b7b9ff82446f6c3a000b504e8d22fcdfde16871904674913d1de0a94f8e23ff039e5bc57fb7c44596d99a5d121e53fca1a90096a69a0d2f72053876f69487fc9421c5f8d2eceb8a040f77ec60c60b4553d29227cdb78c6b4e4b9cd46ddb6bf4662cfe09ee7ce684720bfbdd6d335f2f13f5b52f0ce09057f1cace0985175a17d0efb64e76f1fc9c3b15e6ba1d14a6b23aee967e6a228589da7911a0ad7f3cb4b860945c6a74e4fa98d17b7b7609ed27cc440fe5c8a53aba77267f9c52ff98eb8eff2090ee665b46d9c06587b3096e0b1d33f40e0cbd81e98ac2e26b421068b54bb42687ac522fbb1592797ab7ea71d263ee033f5d62f1cc59f4bf09ebe35c170c031f08697bd0977cae0ec26891be64a82f331eb69a51719e90afd4e2e9525b727d94ebca82792621ddb7aeaf23eed700155137bbb12d0612d67601f58ae7c46d6db6f00a8b526cb07882ff7e63ba99f509c6ddeaf2668403fd88d4fd447bebbab4feb700e2031359c19b9e7ffe6c948fd4a8133b4ca54e2c6cccb4b3feca059fcefbe55c89a5faca2b49f9fb6ac554e5903800c3e1e099a346779980549f1ca899d17defb22266909669994831251e53aea4c8586e5d9c44cea1f406d0dfdd5a752d111bb10c36e984f7cb341c4d17e82e7ac0927924403171253ed112066278e4b4fd4b6a147f0f953a80429a537c91a70011f31f0e91b58a2d9cd49a83c2d31617873a9184b9f0f46f7c2f40fdfb2b6924eff918d0cdc8643495f9dd73c7554982dab93ec24e3dbd5ed777f015fb159720b8f595aa8a0d37b5573a77756836a2111bda187d7456dbc43ea90074651a6a71be39e5f945901e158f4dd9d54b5c95658aff47481eec928eaf011dc42c6aeb031027527f27a2ea 请输入微光提供的通行证：","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"Me","slug":"Me","permalink":"https://starcried.github.io/tags/Me/"}]},{"title":"家庭作业","slug":"家庭作业","date":"2023-05-29T09:07:00.000Z","updated":"2024-08-11T16:46:00.354Z","comments":true,"path":"2023/05/29/家庭作业/","permalink":"https://starcried.github.io/2023/05/29/%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A/","excerpt":"本文含有隐私信息，如需访问请联系微光。","text":"cfa2926ad01c1ca5b72f4176a524df637f356b035596e206f391db36760b4c1717446eef0a67de34671e023f3c9c91b0286f9b8112ae531da3301874fec2e8fb1e47dbfa23c072ad22e028f2fad128e3ac8c65d6c6686f47fe0ce2755df8e12763d90a3c0cb6089ffdf6ce003a7c08f3f1961f0dc41cacf4cc8818c8513255fb0770a5ad221405d39babd04d3f041c6b4b195b380f0eb862e50bbe8a8f2d45e60e64e433884f867b2adaa932f51a91d614d8b2cdfa828f700d6b4aaf13db3882fc5be22d466a2dba6f1c62e8d0a8ad1780413741e659bedf7e8d25fbebc037f0b4d7b95f7ab11befa9686a9d4dd8419116173892f55adbe324bae866a07c1653d059404650604db461859d4c521bd17e4b46eb7b72372e9ea7a6edb5bd72cba65aa11f9e61dd9e78f8d5717d0b090752e24fff31fd7bd6440e4d13dc652afabd9457ccc0be29601c965a35d56372a0595304d471b374a1b6ca59bcd1e5fbd0ebfb5abf0429d0f778f4b4f58e4dc64e81075d032020a3c5a2bf4088c9a8073b0a16e6c9b669d9c32f14ee2af28ec0d2e3509af3e7b9461b658fe134081d1069852a458bc7e12652b2001b0958ea22fc013182ecd5151c2b4424d92085e0a3fdb4c5ffe28894c486d4fd46baf4fa205c784170467f873a57c3ea5313f98f2f171270122e265f712573242bef928ff9746f46ca66569b1baa05b087aa4048004c69e184de62d343da4b1f7e32f41fa3812063432b3930d130b0903fbab9f7295bf21603849c7ea7ab9d20de499c37193d4f4f4fbed68d7969b2ac59d667810977f1ae838c064fc605667c93270119bda40dc51b30b4e2cd36c5a02e17c1409b1c3d58b97d0254d626de508570d6e9f4c9c83b88cebe81cc9911b5ac3f53a3c0f7683939ee03d58684125b92776a4e5721e26f9f15b8b8132114341383a6d1497b4e32319b9e8efda036b44207e540b1ea4942a44bec34a1d6aeb6f8e93a950e37e624548d3fa69f68f1a61798a340f569d780b58cac045f067e5863aac7de5c35d2d3a971a251e6939e0abf38909224ab401e81fa26e2fcd1ec4256a7a080fca5b3388759cf34f29e8dcb01a31292f64ea71f10611ead715c9095e934d09828606e39c5b29db7c3edb6007a8ff708fa3c4a754cec231e6d265b78ddd06fdc96964a47b183434944a3359a4b1c2047bf6222aeafd2ac77589c2d0a1e9c0a031dccd576874b873aa241143634ed4e205f8854f2963fd797c799c88594fb9588de75eb3d83440733f5cc3c254f8c4dd83b27fa4b7c41b647fbf29e535a762d0f4adfc635a400bb41984739cb6e2e01ee00d2b19b6ddd3d523fd24b0bccb3f6a7489e584de76174009396eeee2a3b84c80f781b3aa534dc31023ec64922346b504008f2d55671f30adb33350767f9b255ed923d9953727e3b49fc56c8c38591b0110a9fc00625906459a7acb39dfe0c73ba17e94264381bb8ca86a62a6e260752c4e00da92a81f99c141d3a86104a511245eea33c11bfd4a795604772948b8e5d4cc61d45cebfd07c0cd6b98e076ab83006b7dde9d23cd34013037dc1abddefce84891869616fd00c6baecba198a9ade34763bcff22ddbf71f4a1d25b8a6f6b6a55f547db4c21f6e1f8cc689d7c1da169613a622a73260845882c56b2470f07d0f81813499f18bd53e0d125b6e2a8fe947c5a22c98391ea45662bf4d7ca857a61c00cccba2da89af78706ab0d982fe2e05d7b2e2dda2bd52a0376f1645d9a79b27bd2197b5ce9fa67f20ffd4afd9445cd614b5602a945630d89c942de5faeb0af30a965458e2af87b47e3227126b1e3c4976bade99c37c4b3887abba5b269aa825a69ef566d04a0464823be71818a040765895a73ea9b527642e71533961fdfc229d2770d46e745fefe4334c47449650a53f6701839474d4a9ac69b9f1410402ac30cfccdd4c34f28aa6ec56da32fb3fd729134705b9cb0efebe62747340015a072b483b18964126acf6b09515c02ff9ecfe384506b84f0c46af099b865f6ec435bdf13f0309499bff07b182ecedf8cd39bb0a5ef778f454a1c13c9f2eae20c8f51dd6ce3bd5053185df6b0d90e1c0ae1e3304c53842f3b50618c2c137e8d27048d6d50ef30768b8fc5c0cf21fee07e91b7c0ddc55f6a8fbd536a0aa0b7713ed83c02fe43d303767ae1b19c84c33b8815968ed876a235ed3bf6a6a3e87b5842c38e8169e8758d8ca0ec5607013465361c8ccb083c2c38b0bb8d7111406ce193237c87a8d399965b5ac40c38cd2f4cb5c7262fa365289ba613d0e9c0c3fc1311b49b1025c6cb9198b7ff7c930a5f83b9eb370c295f650858d1564ae9f9bc75758859264119ec263c294f075525765b81c012e7029d3bf9c46974ded2ac4772bc09fe33987b29e8986cbf6770635ab364ec13f60a665ea5b59ab6569909fe566cc801e2bee63c2f7e1ddbd5f90823898fb6299d409a61af9e16452054423c39e8e9916228ba047f7ee0dc78d46185b649a52cd5022d766258360a42d0d5375413e9de0d4c20a807d5b723ff3845129f7e99adc43c89324b723823a935b3bf4bcbc45900808945a205b6c3ecfd0090039c8772e5c5e1eff23ab510a1439e27d73099493bb2bdf89be7faa345174ecd728aca6d70230c965e5d347ffd3c10579b63bdc69a062a35e2ca9176060be48e989a17450f7e7d1f8e94ec7cb8ab8c0b4f5d0e4f40f61659461cbca7d61225a196272d81fcbaeb36783c97222714ffec3cb53e7f9e868355d2fc25b46768325b32a96e41b7ce31eb8ea93e6ad259fbd3c9be342b5325b79f9cf920310cbee348c50f55dc0d6173994c2c5c4e3315cafc28f5b32ffa11547f61565f8c855fa0ec0287c3178d6d83b942a6176c74633ab7163c6cdaec4b94bda833986e5a09da096bace4a5e9c23e19ab741b21814ffe6f61e042cd9a6ceabe3eddb5a316a97f32814692393531a5fa7e1dd2ee3b8383ee1716dc0ff379c1aea4ad460344d33d9d530e8fcec918446a51e84d70c72e2eeacfcfe8f1b05be26c659e26fdd7eaa038714d5a1cd90a6d56db1bada37cdf10721e5fc8a2c10f316552dcd08bc09499364f9b49da549be9ae9e5aaa46033a432274ebed930a164b2b08b8f91cef79c5cb1b62eef300008f47f70ae9d546691d74f1a2e591f0bdc4d2a1c519479bb7db67acf82ca30982936ecd1f910e10b7dccbbef8c91b0ae8d7f35e42db8fef41e1654f6e64264208d700f4cd7ec6e43f072ef07647eb842469e4dc0431c5ce83973a01e2a7475968513c1a737a30e78b8e285d8923ddf227f5292324d674aa8abf74e648a6e6118c405527533e873adb7ccf6ae86f17d6072167bda285c55c1318fadc0f53b77a4ea7a7aaf15555359ef441127a5cbcdfb467793c9db421ef40ce8719212494bd06cac682129356356c689a84bc691bbb7de01b5533365e8ca3285e4bd6b44f3923e06e05122a869687eb17e290dff566217fc00c2d29affd17c8452d35dd1e0ccbd5857c5f3a15aadaf2f9eb8c56bfc7bf64c376f7711f06b83623618293af92cf85ed16843942d0f43ac59224b20a8d03952bc6f13407cc97904667d0ea447f89ff371371cf1c5f26ec1181a0b4f521b8854d6b3784aba0ac7c4770dde67bcb6e08642b78c12bfd2a694f538118d49ca3ae5e6ccd8515ec3929ed02cbf1c77fa75940be15d6a1e47d32d82566462890ebb55dc014ed20bad789e5b874664d860e90e8f137c9fe8b1eb470aef6fbeed26c42e5b8d10e0514b569af3bb2753cc1b8ada3ca29caf2fd6430a3145d86bc8b673df32a85d310963988258df12c4a6eb22120f347181f63e3ffd7a7e5a9a86860576125e26104ac07381b57c4be0cabf15dc1724ec33767a3e60c5116cd0108c66ab5c097e3aca5496a15df6d574d0341957350a34f68b656c745804eedb4baadf916b9217331cdb9a169194a31d1aaee306f686d8a1254ee06ca0758a4ba5a1e3aed92daa9ae64f7c318d113b7ff8cba61a3813dc5be8724da77c08852e082577469d47d6348aaab7443baf344aecb81c84bc5c77a44ddebd57277fa66ed119e79f73e81aaf2639d7196e5c5738ff099b63688baa16e89c4f3852b2b269753f3ab15c7fdbc6b42a733102c2e2e82600b23598d9c5a5384425691c190b37da4eff76d4e30715598f82d43af30e2c0ff5b8091337bd54e6648a5e9622ec21c9e965fd8654ad0e70a684e839da952f396e8992c169f1a87a322e7ce8ea897d5772f5ec3a6fbbfd4c815fdefc0d2f8eccffdcd83334328b9be13770b2ae0ba436fae9774ec17467cf58c13d3fd6e1786cf69fdcbf4570a4ae1b5cb49f52923c7d247fce43a0233a54722a8582e490a8d6fca11eb1ba31726b375aea4c932ba69a8f56d53bb6cb3fe99fd714d98e1e3c10a0522a5a8fbc1f9ed7113a1f78aede3549ab00af65d898a36a982b04d5b32b99a341f5f57aaf768ea4446972d7ca83d387e7ca9fb118d52028a6e1c8e5650115ee3758b34f7e6781841d98d8bc6905eb95add4bc522998f8688e9e45a5efb67eb617ac393edeca0dda85bed85103dcc29d79499b76441eee7a218188f2cdfd3a0211b1f8f43370ed19529fe6219218015a935a3ffe64dbd15bfee518455fc44cf5620e97420f5bac36bf1fba2e6de1da3c8f714c0d1a14c03ed77e263657cb1f8aba5a339156c179c8418131566d1c118fe18e25258a2f8b37e81a7433926292834027a5b7ba9bbb40182b9f3765018186c1b9c13097a753267f411c80e6ab93a3a333c95bac15078382e4aeaf6b921a8e6ea552b9aecdc908c984af8c07a551a292ae1c7a380d18159b2ccadc86ccf04158684f20f91042558343eaa199610c4ae4699aacbc09c97f028e71f8fa01b3fde99ba90503814dae129fb6e2183d4f538ef63db1af157e2f76a83596109fd83dd98f243676828af09165e4eab3fdd27c23e9c57d1303a6c0b88067501a2945e3abd62805e048b98553aa605d36fef771bf2011d9df9ce05efea556ad75a7a612d2a63e8934c49eba797261b3864cf9c441f43e5e3ef13ad88f0d8ae01c9248a4882ae8993b6fbddb85fc26fc3e8c0217fa577ce3f3adecb6216ada9e469a95b052180892161ca33dab42ebade06acd9ef2105cebd4826554293d6f4fe7cfdad80113780608c2792b68ce8c7a56e253422ccccea4763bb2e7893265b52e6396cbb4cb72bbb041db521a65242562d9846b6b3f0809642a4b2af0bb67944abf8baac36709ad667f95d5fda38929b5430debe2e9a399340c8164355f0a3c0527b3548221574d164e56d7c2db4b4ee52a14ffe7ae3ebb73aa0d10672b260d1f816f44ae761c8f3bd8a15219ef2895a3316120b0a26c2ab6bb34143298d4c15d2358064c5ceeb8b9b119d8fa3d785ab501d823e14f756ee5c3c4285760e47cc59d65af17ae6a3ef0a25b5759e59cd1b003eed68f81e703da82a956a58a06213e1d3ebee002443a4617477c1d0fb8854c261f116aa291270a34e5a1a9134366cd5e2cae6658cb5949bdc38e9a7fb3bc53400d63339ac9e60065f259f6dc40f0eca50a0575345237b4e6fb12dac359347eae5eaa2404ba786c6009ea8e4c50cbb5577ec7f828fff53b82a269653a34606b518eff16ba35c6e8a2ec3090ccf6f0176f9b4c74039df0fc7d2dace39812133dea12e0ab581be333349847d27fbcbab763acf67309296d4f297b7cf8b0ae1e9ee01f6e73488145a75c39675cb1feac191eded8dee5dead8377d6eaa2036c2bfbe9dc7622a58fe72cac431977f9172760fa3a024a1c0e3327461f5576e7d2f53a7214914aa38ee98865a158c2597ff5d72c7f339e65abf1ca941e425670b8dffd173ab4cac50a539edb921df7a45192dc55653bac5fd3e19225001a0ac6d6866e5363a90f5840a156bbd7addbad58edc619e11fd089adf92c7bef9a05528dd128d820e89e59f1e69975b4aeebe1762349b274d561ebe94f1e959bc341697a078c9a29ddda6742dcb26ef3442fe8d7eb545f2de431c0157afa49d985149e30e15d79ae38ea8c6463e000b8268fce5a944555e4292323a5daf2d757674e46d93e13307290b0dcb4a6c6cd9d5e538ffe1e19f7b5b92600dc43109827b49baa46f9189882f9ccaf631a81464240e00b10a9e1f2c988e601870a84dd558b142b14e50236db1e93277476d6dea214fd301ca920750695eb3bbba9fdbd83e03bc66342163f50e5e02add17e20915116e8d403c9d7b696ab5720ac7dde56ab43620d4ae47eb8021d6b1dce4f274214b65aec189333593b788644a8defba968795be3261f3baf95eb00e728de677f72ee8e52b6e48e327d1d0074be56a129e0693a7daaa4433d9e1687dbb6d6e1df769a601976068a812b9abe09bd03cbf60eb0171c2abea50a67ade0f238c6d6bdf3e99c1c87ab9d9dbf40103af114ee0bd3da88c0a4a2abb5441f07e4cd07460bd383aaab9b7b3e41df0b38ad9bf963fb021185ada96cf61cb4e819cfbfbccc63cdd3b607ebe58e8df7ebc3ee6b9290a81002da55d375947c6744b415f0341ae9afb9147dbedc8f6dd5f94e955dab1e2e8558d9998fe7613f8bfdd330738e2db050a2f973073ac71f9041b0fdcf74e930dc106019417a0657ef06555bd6adc51c6ef565900c93ddbb1318399e280dae6778853333e78e6fc73a52f31139f2df30371b8897bb06663cd263066643f03d02e579070555cef13e861231f9f254f607a6d46f918b9c99efe602ef96af84f8270b2be937447f6ce8d307186debd23bfcb498e05bd6f4f09af56cffc20622a7326b3fd48f9b46941f0967265f16171dec84f246f849949222659d5d781d36277ce933b3078a47521b7f4f5f5c66d340037370b879e7c784edbde193a652022512878972c296c3b1ffbe2115fb4e8fa299ffacc12619faa0357bff98ff91ccc334e80c7c01a7c3d9f75d02f54ec91e6bcfc0c9a190bafbabf8cc13e09a86576eac14d7c61c39260677a27a43943654deb91c736b460ef2c6f28d673d2230af224aff10147a8c5cb85de74719b94311775c702f6d2dd9c8e79d40c4bc3f91fac6281d467ca93266d7744227c5c7ec2998281f0d5bbcf20ccd6a17de7e26386d8faad3a2295fefff497169ffe5be9120b4b6e314c8c81c59fcabf488a6476e8a3fee5731b1a055801908325f1bca4dba85e58c680bf21208ac7e573c6d687472be45ecac0d6e1956ac415ec1c8ef052af7362cf09d50671a3d013c262c973cd794cc63761dba5a358e003429b2a76c813c71e61e2619011731d2bf7685ca559df7619f8ccac18be6964e0eaae02a5884742bc5ba0758bb96ad4dd79a2c2db0df894dbe50159b93d603427ccdaf3fabfe19aae4278524e6e7b954c9f6946c1ae142a6314d2ce429bf58c138012cb76295fb0438dcc6b54b16f4f4bcab67e75bbceefcd6f176ffc7b2da8d5354dbc8ea8d011ff9433e62cdb386c8f863f77ab431c327f673ec204970d2321a07d29092eafc82a9a59ea58e90815b84f2bf052dc208cb70da6a45276807b21f29d302f15ffb2f5fde4ab20db54ee8be4f584d412b3539993455621b852d93977d7c9382ef56e9d24183b0675a5d83d92f03e282bddae90eb8cad01a014eaa9b3db247cca16f62c846d9b96c72775ec1dcbc6e5f219eb2cb6a007814adc8b85ce09a235428b1d954b017626794389ac62cfe9cff0124ce7b9c97f2c5f60cb3f21bd72e10522d8ed7d4c8679b5c9abe4bbd4d537c6a5979a5ef49ff3f03f1fbf994caebb63929e4786b017d65cf3ecbcd9e2f814de7ddd613f26138b71e2e37ff8920ca3e7a02a6abdfff94f1b66616c00b9b0b2e63d7acf334ccb93eaca698e9da4bda5515f04ff024d6060a7f3ce97c071f7ee833e703403d58f03d91d8d42779ae4017c23bc6caacd602e54b7cc4be9389bd25a01f41224aa0e2025d3786551f81bc98b14c07555ca6c88fda51a9a743f099a4682b18208bea74007e5e9640e1b15fbcc8b2c00a788b23818f682da10c3b13ceb79fe5a25246d99833d036de17224207935f2af79bab90cd9362bf0cf4d3754374534baaa7ca0a5a06b5f9a6d4bebbaf65c3ec55ced0c5b7901ca8efc6de2f7a52f54a50f5be02704f14cde93e2ac5abdbbedb5cb9ba9d0d85d0f24c7257fbadc44c6e50ead0fc10dc80b7dfdc6b3f0ccb5adcbc660a8bca030d835b878ea650a097908adeade92953aaa4a0777c034bb262454f2253ebd887dac2ba4ddf068b1347072ae10a8b1be801602c3441c3ce7879fda80cd02f743cc1d81d8321c0282fbaed78b1e69fafdd7996bd834bf9ef511b988d10f85ad76cc4a8f4029d2628bb887f7b27b4dc7902f63ff63ab5311813ed02a35629b2841bd405567adcbffe43d7083b28d65723002427abb8e2cef22df81e399c226446d96ebc8e3bc4d8cffabb40db62202a96762470a1b0f545fadc0f3c690573550d66576f74df251fbbfc0e86004fb13efd76eec9488903b3f0af8391866dd062b5223cec865312162b99ad25a546fbdc64472adcb8a4bb1d921d0f6c3abf83f4ff7213bc63f27a4f36d035b340466ef8deee542a2f0a5372c7f671fe2212c4ac9b8f97cccc66e18af3cad645c08f5f64573910d45f2493ce6875faa2c0860040ea92be7efaac2dbb00a5f2c75b737cace9adb203d2b221469d3b0d188079791501a74e9a3fbd497ec1e45a43a1a47b56a7109b45ce24024fce8ec853eb85510119a7b6a5a57ee0b0f75692b4221d2047f04a045024e9e3912b0a3345225ea572c99b634b9d6f58e0f450390b3d010d36a967bf2e5566927cca5517e07095df07eda89914a0ff8d7983f24b091f03f9738238df61b026b6e9a6287a0eb4aebaf3ec2920ea7acbc404eddeb556977010929666e0840bbce458c05a34b75f833b5fb7b8830d228870bcad5cac2b09f6a65f525f15ddf18a1388882338f291ac070086fe503bef10d69e0395eef5cf52b589070f5e9994a1abe6d7e23cddc2f1f6c8846bf2ed917ab7170e0d3bdeb5f92dcc07e7a374580b8eea4b8df4b38e644c189bd791007737456a3467141e39c1dd8c7153811eaf12eba4eea4f5e404f78d795d49f9603d2b69e50ebb9fe92e6536bf99b4212f75ddd9309343a56759845502ffaf36deab4de02510409ecdd65f4bee8961c2eae22402ad698e1d0138859ac4c1ba5d941eea17050eed2bdf350948e645e706fb3a28910974846dd8624ae43faf4a6c6d79fc744ff69f7588aa1d09b5dc7d66a22eff02e86a13641c3b4a615de0015e1d853dd4f3070e1dbad1a480ae612ad5b4c805636667326467b5ba22950cda88b3101800430f2674856bc1c3acac25a3f05870d08690e7ec996407c74a50a5b3ae2672f5abe769539c11c319ff970dfe294e87eee32b12abedb74662fca46d98b101c89f7f786076a00d5852cd07539e2cede25c9a7fae141d133fb850e15a9a6fde2e5459bc9f95d04c523e83bf62a78942a263b0cc3541bf3c52c6e98ad6fb6b607918c5cd6f12c8761e551c192fe6351863cffa3befc0de3814fe70fc6b617097fdcdda061e273e22c0df291785eab75f6df060a92e2c5b3829e907100321cd6f23714360d43c289df97f374ac31c9d38a7772d7d32d4bab42d48fe81e71ff56ecb498d4fced32cc5691a4bb28cd342b348ac749e440f8b5559c8b51a4af48f373d457bf60d64c23b367bea70f1c85d53ecebce69331890708585e5255c16f2929bb1ff721dd37a0547eee34ef3ff53ebae1b93eee3d6ba5a83bbf1888fe33b4459170bc25e3f25f5ba160179e653a4ff5d6ab5c20eb7b16fe501dfeb2348257b925ab284d3bf71cbca7330361085bc2ee52098995fbb466bd1aa68f88d50b2464ca82a04812201425a7bdc8ac76f474c6c2caa1b990540f18ab69157e909e3fa74b28bee96ff5a1fabf15aaa54fa70559e0071bc0deaa99793b1ee5854e7951bbed69903974c0cc4be920e668ea4250d86a59240c0c36438dfa52ea9f62009b6b71ba96dc1f135461f95c168e2c058c2b4be725832d8b7d91421830a5108e9a189dddfec1b8f72bd8fb0185e4342b1cd91ae63645eeb662461b61b57c01272b07c7a515476ede924725ccc1bb9a35a860dd8b90fe2d9ed2ad971d57b3b8a2b8bbc41a5809ccf2e1458d70cb5e424d07ec3d00f70740e294b8bf104705c5623e19d497ab070c2cfd167b7a1b8fa0a570ec9d91580ded4bd2295ea781c99acf446e54e9132deb079958f51b1d1bc09123a2713d682f9568ce2ae3494068d43848c45babad4dc1175893710dad8e63c8cedfd1c3494ae92bca0981ef9781f4975d23d482008ac2f684810f1a2a1942abd4f1b443d404f51ea5fe86c10ab68a1148f29d24cf0fdd5444d5204690f87d601d37babec267d738f4df8f5434a4c7ee933ab4e3a6b9e96144e6fdea9d6111daece50ed39d708ca90fff20906517a2e516930009a7bd29414554000c3142beca496968e935c4e843af447f511163adf80a3073a38b9463a30ef88dedabbc1a9469b5fa0e1b332d0b9e3aaa8fb592d3a4f16a7e3c1722e259f8fbb563916b5e02658054f91fd2cdd10db67799841b8bcdcebb0f7bcd83cadb92dd88fda75898004e2010160d33ebad8f46891153d33e14f7c29d9ddedbe5b0c6a6e086471b83ef958ea47b2bbd19e5a6fc164e94a6154ce2bfcc1f3d8ca1406113eff599014e19d81f819ecc5619de59270104c52de3d4dfb2c8c6edf990945b747ef3adbc30d076554ba36379d230a6c58f138b86b8e17903e63d727196963cf72818b0595358fa85400650ecc0bc780aa181ddcc68fa433386b10c596bcfdb2e1c0ec47a190eca8a25e380a008046f772a5e2b55d806dacbbf4b1e84520ba490543949e3a3ff81a096f957dbb0add3dafaf74d49238f3646d1b8cf3b4bb614499af124dc86c75f9646e163476511ee7b4f5f7ef99d1688e965a9111e3dd4823cb60dbd0d1634ef02f74440381fe7ed41e63c573d638911de511eabab33e3d8a141b9646ab47469a43d4046a08e52649ce0d8b168a42b3f9b80c70a1bfb794c93ce0489e8181838c29c0774c625a56793c1137575ba1d492e735b83c34b04300388bfe9f6cfa2d418442571ebe8f379c5958e8084ae577ab133640c38bbef7d1639978a9371ee402eeec8ab5fdbbb5ad9883034c27f911d0b910aab8a51b9005ef9ed84cddfdf54c34c55298693b053788a2cd6136cb0cf517d120c381fedb382280435419ad393a9b875a258204234eb682ccda404cbf55e9a32085cd3792e996be5c647d26ea847df94e45c76e039861094fd0282543a941d11b4895168a701c9e7df2a395de22c8692736b002291a62111f50e5bef2cae993471bc51e1d307fcd5d1d214315c0a52c0860964729ef09bd67ea473340054093d89e18a80f300b6398da0f20748d432407f94a9d12ef8831c723395df03644c27a382e5de451841b84610bca3e91dfcb0cc2c9fea68830cf3c147dbe39a227b170a791ffc6a38d4e50f6469263c0b9df2ff3cb2b62fdc543bcc9b732776006a8460eeec17993fe2d2afc1d7f39f16f0aff013fc7774d2b7cd9f7d7b6492bf8352ee1c4134d5f3dd1046f88f40d4cb430999969e536de2d5b90f248bf369f7640e55e67f944ef806fea44915a446457c6fcf07e6adb65bc87aa17bd0caa2aac552407c2926d937744ca2751f1d0ebe7cafa58ca2122afb5f6bab2eb54ac21ef153e16581118fb1b5b786056b605c6108ec27c54622c61b48df167d5116237cc3767035ac22deff9077df4d8a13617c0f616cfd6757802bc87d715b68e5dc9283ae2cd5130f52e8aaade2f15ce59592d88fc2c7d751ab18a3570a9da0ff7d7bc9d99eb578a75ed7c4fcdd5dec4029fb143ac25f73bf5c080765057dfbfd4f85e68ee5393e452cf677fe7f2282c53311551ac6f09a583a75e9cd4d2b2e5ba8d736b7f1d23871dc53b7648dcb54154b13205d2d932c947e5b36f714b56bcc6efffd7468318fc9feba628d9d421ffa2562ee002ab6cf86d7686d45c7833a603d495cc002ae7687bbe8a25eae33a5f276e27cc7f285bb1a396f0b1e71e56d3c5d74fb3d8e1cd376da461dd4ec0b16715122a7fb9446aa1556f0b6e7eac7507d4c0dca4d838eb9eeb0ee77fde73b0adc4d5b573348efc9d444b2626ecb627c4550080562a067df2e1a0e014873207d68fa5a8f2494967b96ecc5da75753a0e35e739742a4e4fcb893a8d9dcbcbd491282806784490749cf6b9f5d73a39fa647ac2c9363e49b681ff3da3e1345365647f6d3f74225fd9c7f3e437ef8cb3192a370724ff16cb68ecd642622695a6f944fd11b46c25c13c277efbfad83e358e3b3274207e2051597d126ef5c3ee8da8f42d408e5bcd67a568f65a0b784592f96bbd8ea48d41829eb63c6c4da165e9ea6083cea26a73c25a84e478772ac6959b9f127483daea9ce27b6581b8734a05608c1d6ced02b39791f11c472fc5dcdb6882b6bfa577565a99408b677f1c4cf6adf5b64698485875ab7f461d5fc2a2cea48046d0b5cf8b2f56c78875a388aaca5a1a42f56f24a23a2ec3375544f45ac4e9bee62676153fb483340044726daf6f3bb647d2d83908e7399f648398e6fb974cbba6d8266b63223319508e561ad5f69a0865fc9ffd88df9a7120a64a2b6ea8d9070aae589c45d960797d7fd39e5447e98d1f5358934aa25f7599f18f88a9922380f005071c85177a52c02a62a39fdcbf31ac137f93129d2b1127d5850d12996fc84a738073e3069782e2769868ff969c5f56bec7d60ceac6690fbc58b251cb12594bf25c0954d9c5b9e990932fbf6193f42afef09061e7e751c42b4a84fcfc7934e4eea3b9a73be54e61adc5c0220f3db311bb9fcf23a8dfc4c4e0f4689c82304322c444da97d2cb1174eefa4d1ce076d77ccc75d5fdf2fb008461cf706ce47571d9520c20cc324590f7ff1703674914e0ad4384b670abefbfedaaeb644c75dcc40fb158d53e24513e28d75162cb79d96b6f154fccccf4b50197827cf631c181785dd4d93f4704c25dad280bd994785f2af957c49d07c80ba87db484a0b83b595fb092962814cd925d3d359ad6544e594b7894253feb39a91eca38425891b1fd4af193ea3fed3f8adff713989145e26e9f1ba89d9881b3923655e01be45aa8f2ecba1f448d84e86cba779888b71c3892ff8db6e1491e4f4556fb65a01f55ddcae673319216fd3d61ed0d2841e4a2f1bdcf3ef9b333b8229491160bd9988c266154a4c6ee94d93087ba5710f444f6d6e8ef80215c52070fb8185be8e17edc7a23608447a1073e7e2c2237a3cf0b884127aa7e77513849092e4a9694c0c9eafc0c0b9e4cdaff9f4c73162fd6883eeb53b8eaeb2298a89d29f1ee5d38d185469f3b37fa7d1a9233894acc15a7e9d735148ec195eb1d4229c548e541cf58ed30600bb14cce0ccaadcbf59ca9e4f4c8218002d93ddb2d8fd07ac3b110bbf1588ca940f53f91ff1ac17be0659d07f15218242aa5917ae306ec60df4369e1b94931ab18e094f07da78011d426bf78f70f843884697c03b00a89219f8fb43e1c11af664153ec4c8bdadba6202c578fe3774a257d560a322a0d1b1c0a68374cc9a323823526de3c4df320931f79002705f860720527c9f817d46df6eae7811ec882f0f223edcf96790208d90c5147b9a6b406fa96c5d29553d69e026c8e0626f0f3f1ae071bad7589d739f9c06fe6de008aa06be5e8d645d7e5550ede141d6b28b9de680f4d9dab2763353d4baa7591e9e0f02d81e74e3bb72870f3336ebf7047b60b132e108f6c4aaf703d50afbb634580f181e5ae5aaece7f1fefc3abf9c74dcf440c37cb1cfec0507003e93bbd9988726784af9c3473bcc1503b283c6e4746054e1593e5db70b183913d3d52ccc62038a73355fc84f6348f12d2dda0956612f2dabf72119da9620ed7682c34f574c199b77603322c4160338403f460505eb6e67a75be935d6e4cf51c3531c571864b4871c7a39e1fff13292b49d0afc2dcb98effb0c773a3dbe8d44de4dd7c997154005079287f6848acf2436e48b77b4cc1feba4f586fe747e55ab0fcef340721f3f8b7e34671224b86a05abe0501601c6d38de169775a26e9c784d4e3db34a2b311aedb5bea5ff057ae226e942e7cdd163c11f54a0a5327aba4e7a14f3030a54f6eb486cac41eb1e18ff7b55c832164edb8c0afd7f276cb4d488121e7cf4e355f9542374e830326c53a81fb507bca71126cf03df21643957e9fb9c29476f39fcf170b80769a2a9c739010ab3143e670233c9aa11b3a739682bc722db77b20060104c8009bcc42dc824f4e8dc0d277f90ee4e30a7ee327859cc84aa86a0cc487deee0f76967b2e7c15d9d9ef32fbc3f3b078f81168e1816dc13bce6f22aff2b5682fc9b5e3e7a9ce734fa3d8106ecba7f573b024c16656725991f433df804d2bd4b34659b62f25ff87117441a7c8470508c9aa65167060931bc696c372f37c5a266e98603d9017302d46fe64709e224df8c3db836d5b241ddd30dd088a75742fdcff8f576c7d055aa220a18e4a384d18f051f72055c4971a6770eef100769fa252028905a013fe0616b998aad4663214f12d284da44345c887d3e1464ee59f1ca3ed0bc675113c29319b111733f8736ef813df32fdb423e46eac821a5eeca813b9eafaa05550375d2d5512ae1a95c32515a1e1467e1907295a5b41f81a597af6a42036bc0789f2d101fca22314f0eb3c7982540817235698237aabd5907c80f2fb37e787065841107adc8dc304264efc340f8b2c245d7820c9e88a8bed098db85a649500544f85fe4c0d5cf866a81137fd66d56ce5865f8511217af0eb83a7c449cefa1facf0b03ef5caaa29afd6b2aa398c12c87aa47849117b074a48c9d64b387079e37bf225a48475090146e8911c3453d307bac01b2678c1f32e93f45f68b288403413efdc27e68d5ae55622422d1c6bec3a36b45e56824424eb17fdfa66078df53a4441a838c0b8b67d983a35697f9c6499617d87f507088e537656d037dac7938d53679cd54d2bfbb655980aa19a224c2f732974a84c6fca087956af014b0a0da0040189d02324aeece8ed1de4442c204523131fcbe502883ddb6243eeb5fadc673621bf646c916a97d26fa0eda729e8409a9801607a4f84e425d1c2b2e1a9b7a31d0afc686725a3a92515e6d9588d64357a07a17995364a50016a4bbafcd836fa62459bbf6f6d44c305c31083388995a59089e22a4024dd7d91a091e6ab84019b1b7daddce3d9dd63cd4838b6e5613e917cb13e023a7ec548e512caefb08308c83af3b55e90c7116afbe23d820713cd81ea78556716ad68f9a7a46d46cfe9f02492906c3a5dc360a85e4451b50b303bc7c85a57a59761d6758514079b84dddfecb05c1b22bab1fce82e172205f2f6fc8f1973a7c162e272e242510991d451b230783bc04180642e150305062b8c6002ae649f77a2607f486ada521b00faa1d09945fba31721d02adf4cd300d8b803c248641c4336308330829129817f83fc28a24a861c4605c4716c0b09b8551e9e406cf7c279bfea02d3437427648edd7a3684f1bb0006c6e5cdc4cb38a78ebba9dcf0dd45f5337f171d5604822f43fbf0a07e69f9d2ea3c04fb16e7d88e7a9664d511d9f81245d62e6e11219c3eb9a9ed25e51ec427d1fd5ae9d4f48ddb8ed983135f0005958879a3cd7a5bda1bd11a461ae6a336f04f4c544270b69c4850feb12f088f26edc2183296e0cc151b4013c00688d9229f0e379cfcc94811709ca5f6d76bb81578e9e3610e7bc5a7e76820ec9a9b8bdf597d894342e9032b0422691d82642cf37d173b94e1c49c1d97404aff2d61bd6d87b47fc058bd1a6c9c0d722f8633cca9442c9bbf3d0a31892fa6972aaa3b50a1f1f23f8b6b9a1d973a4e8607266bb790bbf2841202dc37211f8d428bce9688f029bc6eb982aff6a721d926933a4f499decedfb1ee0bf123e06b3ca442ecf4935617679db9216f7cc3ecde5fc9e4bd8554cc7d3b4103e225e9d61fd1c8124f3d871392b81fdcdf17a2650129984d6d11544650b00a4e30d461b6c8368035ca742490d5d44fe1f717bf856333db0fadb6101d199c7fc27b0136bfd05f008f94718968959a4a066beaffb354e9a5e32f341f2359e4e133b2b40c865d15816b22afea765835a273cd26f2a27cad9948c56a1e9202def9d70f88a28a2d3eab780a2d92df8dcc771baac05b9bdeb2a85d65e46bf27b465e0a9ded009a7a9431a4aea399dc364d533afada007fb00bfafcd560b6622b3470f31a2ea2f7ce34c7ce463aa71c7250cbb638dca9752adf630f8f465a482ee52c0a9a5866f5d7b4bd39085c107ce11e44e5305e3f426e60df0dc61ce612c9f269a523858127344a3839eb385fe892d703007ceaa05b428c31dc73c9d114eb29091158c75b1927761de17280b848780e6f3898786b0a0ff00e548568696afa67e95b26a080b2321b26cfc23441947ac545f888eaa7af8b4a1636f45271ef52fb60187a8bb173aea714fd6f5b7f912d3d45a0b9a49e12e486c7c018ba7688f24aaa8ae0a8f4b8ff1e27e569b82b9685fa24d9d72425f83ad3afb278ae9c2705592559e20647ee6224aef8e19eb753ec373470d6a5ce5aa365d861bd28642036da0cce4898d3e709b835d5552508587d9cc10a1e9d3443fdb9b592f8ae9ee71e53f84bd9382c89e6d751e303b093fa93364a6566b0841c04bbecb4a95a01b814ed6a2f93c44652143f412d918b56ad4c126c8b6ab980f6373e34d31b8978782647bc5deb7d27cc3c7606effda91f2298787c73e5c80c20aeb1ff21edf362f64838f8e548a53cd30eaac8eddad00eb0f124c53183e1a1f8cc269dfe2c51edfc8195e6cea91ea4c039018d8654f8289aa36cf5c7cc68ea9a18f5f0c814a08dd017ff488295e07b0045a1d594ea985767b9e5f7b956b38ef19ae6e719fe70a66b0a5dd76ce3bf1f64eec453210f11a2e003d8ea3e9f71a8be3e7e066df0309e202d892d89761620a1bd044529e7374b6dc6c05b48f7867dfd5b8557357a080f1a8fbb023855d6ba230c7733cb86758e6b778dbf93fef69b46cd53db0e19884a5d366d371d2c34e67f1b94c1b374e0e49edbd75810d5b9137e0b0ace4aaf47c2e9e34377ea884ff49accc8b24d647745a73f29c0b6694bf94b70880f0dd0df6b40b68f1387981d4dee2bc338dfa7a6d6008c75278689c60112f591674c293c516815e62f4ff2f791873e0c4855ad08bd46cad517607e86a800b948590d680338598ebc5d0228d236db61715e36521e23704602fd060655cc2c4c3633244d23896dce92dd2a1766a5277f7a6ee8f59180a25332045cb023e359463a6dfad9bcfdd582dcd260b52940c267bacc8fdde37a7ef8c515ac199e28f1da4e4ed59529d9a0f7412fb9168a546f4546e4a363d83eadeab810803ec95ee608f2b0837481083eeef4984226c2803fe59895c9feed7af4921cd065884a37db8dd8d4649290c6fd083e8a18685b6fc6d74c4e5e828f4ca1d46810dfce8215db0cc68354d6c332b0e53a1a7ef6859c2129c331e26e93b870d124850b329d998433709dd63d62b7d5b6a5dc9caaedfa1ad958d2ebe1a588394b0b53e1a7fe6e3d632433ccf373d2e1f03ef0e7060f2ed306bb79c97d371061e0e9a6be02d36feacfb8e1af6205635b73ce193f7f094966caebb5761c380e9d655c3d7a14d0b9f6076bc98f73c1a7a325866ab6222b3f44f32b5d9a05c6b7da8b3b4cd1a78d88c068faa2d981cd1eeea935fadfa19910d9121c5c951f15cf6cd90dd7d17eb2fa08273aeb310bbf2bf7f5963d0ea8b76bc4569aaf7a51fd660e02868585c02644f861a3c130c7c525f4c7ba02c24e36a28855dc71416d64a47249664b2404e9689e9384ac06388d87bc7e628b1bb82d2c0eccb98d05c5a74cacaae25541790bb7e3b962a57b273b40fd1dd64be018c08c97065e8c50811ab3b242ca10ec901dfbdcd971b6e876ab0578468f236a38dd807067a65f04b7e24d96e05c76a42700cec638900a9c1b990c2bc957f099210a441c509f7a122c612d26f0b45eb14a7c3e73af0d1fd76f9e7d7a92311d14d0a698651683945a0d2677f6050d7d41c6a44fa385ce3ee86b693f1607c80ca93e8eacce696408f5c637b730aec87be464213d93ee558786b4653d650b1eacdcee04c72fbebcc7e2d889a81707eb5d18a4469468260aa58b6773748b3b2a027964b91ce53295ee26231f1f436f92bfbb863e4269d0a55dac1ac25761ba82c41ca099361dfe867e98d054c633a6b1bc8a5d7be82dd45b904d4a34370d902d387b595a39ed8ba85f18e65c5dc420c29d875d225ec7d92e2ed09abf926f12bddf4096dbb20cbc940f7aee9f761e5ce84e3fa72f2a9da8976e458d64fb3b6c4280dda982dd4517c0ca6d9601ae053b33cc57cdd5a5dae6c96a060c5fcde2fbb7c259ea54f8249c693d521a39f23fc9f32ef5d5ada6bac7cad1d7c847e0c6b34730414953be688330dabf806c814814ce8450a3244811036f5c29cfc5723c1f0854e4f25dd78cda2c73543e862c266064b4b5d7280b6dc257659eb64aa6ac8208f369389fedec455f54089646ce5b92c7f43f722b1255c717de81cbaf7370ef27bbee6e5c94817595945dfe7172cb072fc73a5928f977701fad6b9d7025f1b48bf313852c3697dffe4aa21d18889cf0408a4353b8807f1a143dd25ef8f29f1eb99748824765c91093f59d3adafd91d3be39ee49d85505c33664cd081d18556a0ae9576ed2935c2eb6497dbd3c6895bd0bad0532eaae17b877345e9d8b1501f87d1e19ab587a431e7a06d9d28b6822bb8f7c4b8cb8f2822e948082edb210b21c56a69c346e90073071cb0415fc8b65feb69d7183dd079de7f3dfbcb3db12906671082f5101c1e44210eeef086fc6a6709dcb3e6c164302b321b19d30ebec15b9ba823bc6c17138d1bf0816eebe97011a863e80897b622e23b27f1ab187e99d2a2f0561e6a764a0c4ca905b60fa75fc1cc60c24137700b1b4fbd26ccc50d931ef93b8c41f0bcf79312f5f4c1b75902af6c06641468318a1eff9dc0303ba9c6c13fc60bb5460a71b63ac23976adb4070ab32723a9f24c6020e1cf1d18184a435b2ce85097b7e325df7950d24d306795e9332bfd25fb286947e104851602e362d268169ccb6620a90c253cd0994149b0a6129e4683bdcf51a52eef5f05999d8bb8109965d339016322b2b1053734cdf91d51fea12b78b89c2ce9a057ceb8f88e18d638810be0a9a879800d67f1c8634df5ec36894ad3e253baf6fb31dcf263d0c657f3c300e7603c3e20c1d075e19ddad9247f7a54198a83ab66c1cb2637d8449fc42c67658d48cba06d901d85f3ae4ec5885a6755ac1e7a90e01a3e3c9cc0ed869196b8d8adc15820310418601b73a62807459a7f64e048ab4dce862ebe63a63f7c506fcc3d3014b9b6be504fc9c16286627843c71ec456f7b7857ff02ac9b087b11e60ce8c7ad896e2e9a2a39db6eb09bee448cad1c7a74948f6101c115d269eb399973910eb23d96919a0e99537f3d1f1637ff4e8bbafe861c876d56ff427649b67ee6aa74db57460da4538928bfc1b94a99876656bac7cc09bda946695d71e153e24b907ca5c7190ccf37b9478d7964d88dc3a3909d44f4be33c4d1630d27dcd58ee310b8dfe0c93c4231ac4f97fa9941534d9a54450d660c06cc7d85132267faf7dd56fef754960b83235f3cc9b70dfbfb49264181136a1665a66bc7d8727b725cca41ce4cacff99f8466bff20e42633da9100fa033c4ac9334945ac588f493dcfef787655b2d062f89e89d3bf3e443d10239f719431c67e4974e34b84283159ae6b377b028f76d0e1c17fc72cb171f92c218d3627bfef7273d4b56b5b5a719d4d0106173c61640f0b6dc1551314e5dd14e7d6ff989c38a3f43dc8d16929ee565f45f14cbe7c8a640268054abc73d0c773539f782c689fd55958ad4b3aa962a36ec85ac54036b4504ccf6eba6e065c30c14dfebe0b3592f7ea57e31dc4553021170d77a83b08b20a9441b8b4ed35f129f40a5c1018c6ea262238b3906b827feddf9d94378cb125bc1dc2cbdf1a84177356c97dc7c98c35cf8f7a9f407071e782fb76bbc6dd2d81a5bc1e82f196a7383e955c0b18d78c6b733bd532b34b04fbfcfe328c06e031b89826d2ae8e8c772b21b9742bf6d4f218a89b10fb2ddf6e22ba075b65c2df00478fcfb2cb99172ecdd29b87422f5839650076abf3a361db1d9b7c09b7625938c0ecd0be7d2ec876ff992396e0080281c09f01fca84fc419a13a9512eeaedfdfa3344e7bd3c11dbdd03786e79fa5aba2a844e48afe7834665995fb38b464c297ee50741f4191d676390736e65120b202cd298369972429e685435f94d0bfe82261e2f14e9e8269b355588b44094a7e77cbc7d91411879b39498731b4589fbacc2c47dd35ede39816a03814ddd5609ebe422cc739a89cd8f7b00be6168eb9512b01568276f6529f5dad4edad5f8c32aaec32d3c17b91e6abc30001303496a0493d0120383c947d95ab93c277234590a504c17298761cfb42cefd1b2cfc6c0d87b85d4b060164e5f8a3f9c64f452af1ebf82c5a15b4ee100aafb11dc4e0b5771e7987a6e1acccabae6ddf2621484aaf9ea250d5478d78ddc9ab4d54a09c445e85a6f61c849d443b6cfc7b80cb57e0898c02df946f95cbb9bbdb7eab5c93ef0a3c705d8ac2b123ca3e93a5d1927bf66e9563f35710b48da518aeb7dff3c6c1e453ed87492f4d386b32ef80e0c549f95b682896d7786a576fe4129a84d5e1a0c03adb0a83a519660c50b1bbed0cb553d1f48e3b428ce9b43809a55d00953e2f54e0c9781489b74bc582d667b41c781fad5bd3ce79aa57136d50bb89cd5559e2c81ec8edb33452f482f6e4fed288c92565f4ee79dcd86888ec7bbcbba012248e7696d0ab40c8f34e2d9a78065474c21078f6bd4ca322e7e3648db81854a8bdc3da4c9fa9e820e344a432989e36f5d60b6d63f2b9a2699832e8290a94a6c203f377358b9baa0d5dfa33fadd423db84ae6b5d1da73ca6ce4dc9e94d187ec696c59cb05cdfa2dab5b3c7df11734c9ced9a27cc6c9b4ad24f60aaeca1f148743b4596e2bf972666345a5c3dabe1afe88d8c082059d311372fe8f97c078536925eb172745ad189a4f9c44c0cc1841bb94e8b6168044b4d060aa48ebd8189500f6b6c1c1e19df7d35410b8fbcc19dae12ce9993e14e1da72fb292b2ce37c6f7516c5a2b7323fec3a9ca47466b8221043ee34feb9eee032176b1de8aee703f045fec3870908701579dc1b716facc0888bf2c5f931fe03212f55acdd762da057bd107a2ff8926e5f4277956c3d53750c057a9028480993207977c717a70dd1ca56c5d55263087b2a2a289b11c57eac9c3bdd7a80fce43d4881c569f98f8aec81d6cf0bd13a763f1443a50d903241a02f17a947300c087699f1ae048ab19ea917462b6dfba4e272dea14d45ee8ab25ea4f8881374b7bfb266d6abacd69ef486f77d0559ae19ebd792722ced46fd504add8f63cdcc766b00168b33867e073f542ebc3f7c889f2b0bf67757ebf1189bf0a6c1814e4cbf4db4b91773207d10ce41e6d57f920f587d44c6a96d7971191e5d8b5c5827908d218be0b868a16109509e713530b2f091ca3299380571d9515fe88489a578483891052f09ce10b9027eba69f827f4f16115ca10fa31e873ad68354c9f5b5c16d355a231f8520da98943fb2b68ddc716527fdfc27913470e2e12837945c4e3d111c2091fb48087d97df9335ff6f4f42df1d562f706813efc87f46878ed9e69c73712a307a35e172fe62e99f32a7555363b818e32a81df1bac6ece7d6d9a5077e7a149e2c1fb42d5ad3a7492193284bb4bdf264743b9387688f495ace992eb94ffc1c3ae50a61374e2f8b834d65ae46b1425903d46b821ed5e6501956ceee33ce5a572fffe9aea9dde4188933ba23a51c3e470ecf7cea5afac689cd8142f8667f93a1295808d223f88233c5d682819489b4d30f28dffa2f0ef051c9fad46e65d500c159cd1a4fd1ca395b8cdb7d683570447984a7a95d566458258f1c94d57826b0c6b9f461f3586ee5dd0f2a4b472f21dbdda70bfcc483855353560e564d23ffcae2277e9a352c795f5adb2c09b575c2480fac994cea84b0e414f95f55fc3901d4462013796e8ddae740dc5db72e1a1b97be00226b14f3abbdd49fdcfa0ae069dcb12a62d8820b862adb70415e8f32f1cc4584853785c91fd260231d41a8035ff2ac4d4616e2d9abbb378d3a0207584cafc1630285fff14fea3009693d30c2bdcd4ee4e6d7ac49a6804abaefc6c51c47a8d01b5e2122c6a44132e1e1c77235edd5610ca2d7ecad9a4b6c9bb4badf3468cb68b5e5a8ee3e7a8252e45393e05aa9ab75ffe694c5c6d4d48f59ee7202c6d93fbfa6f6897ee93e913e86743b2ce2b119ecbe59376a54af49047841c2cc9d90c2f384b9df48db39941b9d9ecaf9c35547cf1b440c93d83faf8b71a27324fcc64c2c32baa5eb6c374d2cf416f995e0dd834c549f559760f2b7d7ac2630b0035fb1e1e0215e7d37ae8d5cf0aa969eca32a8156c8faff3052722f2272b0a544158e9205d8cb0f5b2a83b66d342eb9befa51e308d629f90e52dadf27edf74b87e5178b42939fcdfff57b010398ecf494d05e93b33b840da28d61d0860a844857c2b6eca9a1f2b196a91f2169ffcbc5e7839547ef29e38627eba7c26e1047a149e2f119d87492a0b4c5047411e625049defba68f3896b61453450667944423b9626aa21c25ea6953fecbb5e64364f4ec081fba7580159dc7edeae372b392013da6385b5747439c2d532cace47ff9bdffa33b67e5d9dca980c7b3f16ff5421498b54ca33ce2d190d465918dd8c6f537062f842ca53724da30c6080b28947ce3a504357dd29bed4bb4f161cda0e382a0d33788e7a45bcff8a6ae1505ae8025c3f10732081bc9a9ef9fdc07ab1a4d99f02fd518286766b1a7505fa6103c17a18c388b83577c145a738a23d018a29cdd196c2ec9eb415227e77b7d1a0f10b61aa4bd8f0b6c6ceda98ccd7c0ce76a3c60d7542d9674b4d51e5a83aa47ab70f6bba2fd52e7e03fe275749c251dd01d2dcaab556891cbb6d1f97d336b6df223c8d8e919ae1a4b0ec0be47a3c3c76a29d6c0b239ce5df8a6f2adab00521e25e8bf7989e618f6595b416b1fe83e8b6d565b1118023db16238aa4f8aabe832fcd2de3a9809cbedf7df37574531603eb5369faf584bd7c340d9ebcf1742496577924d0731d926ee6e3b132a17d4a55a3925994325d7e0b2b44b016b1b017b1320d1c24df443fae25e3d3ce435ae543a583622063514bda564be9b6fc67e388f29debbbad3ba0d4da2e97b4c3d27ff37bfe7bfd29b6ae194b5dab0f438b993a58de6d38cb36dcc8560c4e1a3119979eebe27ae81b22a91167199bde94becfc68e7c9342759c34e44ae41a69bde1940fccfad8c7dc62f32dc23b2b299abe45210cba61b45523117edd211319f08da87e6907c5d7a944c523315cbeb3c9701ebe63c3e303bdb4d70b8cd51e80c40466a6063b1c9c31923d5392bd7e586f8b152ca2d86b776a8916b36f28a1e396d25a1ebd848baf3df9482c52ab53d30b5dcb95081925714de5ed6bb72308a2ef15049d338590418a450ef2af4154bcd9dcc7662e48e0db2f986ba22be9673c78aad31ee4aef580537e7bfbaccd877de3a801277d196ff3f00ac32abc25abbef36392930fd124119194060be261a79177be38a57ebe13f9541e2b4476c0c3e24fc68472f532ef59153a81cb6a34793800fcc0d6109d0f2908e07057318bc973bf296be3e9721058a0905c219b07b29d181824fcf420e3015a89086a6f0a9e463803b8ac572b9efd5c686289562e3d6519fcb8ee8a2fa4a893105a5fc8690af9c511a6a7680e560900be0f33885327591902578477da793ef5757e4cc4f269fe96aa48107734dace90840691bd45e9a18875fa94fc381e7404ab34f3797e5715145fe5b94c5d9709430118825601395ba6ad8934daec43462cab22b03e336247d373ed9fc45a7d9736abdb613377ea645ba4c350c9c44d64afa5b4329d11f2a0978b433b3468f701241a3f46a331195bc571b864a2f96dd54e3a00a3879b79fa63ede9d7de1a0dbacdacbb4566b74a5c5cd053f3d114476772c27de16d7abb3466dcfd0a65caf370ad93454b44afa69ae07f358d683828d8318d6e7647afadf5e89df1d57e9cede87bb20162a8c4ccb2a54a9ef36d9b4f5c62712a52a89f14143650d73aded302b8e1f538926ce4df9d94c88c450a24ed72bd1ac1d9089c7f47a6bee47a402237887383a9a2a14f1e2357951cd09c8bb04f23b53760dcc764f42435c0cde2783209caf4ce20c9543905e064c7b518f3508159292c8a0be59c53c4c5d60e07104bd34f3e9274f95ba890e650dbca31b913ac15799c85d81485dbd7ddab9c6f4a8e57d737d2427c3f70d2804b646f6769d653091d086fc2841c180481974bdab3e891217701e0bd79dbf3ee2a90c9c4cc66b8f8f3a1abd5a56d206d7fda68b4ed4bb1df45cc79d88bfffdf74d11ef3531afebed41583e1958a0586a7e369ac394737d7c4db2c09c7442ee72cba11e05bd0ff91aecd0e18eb9d5c59fd54257e49ccf72668082a4c0a1f48e896eecdb393e4e8a92366826067ba959f7c08d506e2a72bb5423a33a3d20ddb12855df45ca7009553b0d7586a74f8b3e853cdb71b74eae6888a502f9b715a496a084d0c3015321f4b5cbebdcb0e80937024b2cf34ebb3f53f0a97132cc517ad6f92570978c0b7f6f7ba801e69807a05afdee3adcc89716c1e39db510c7cbfd6adc60a38b694ddcc62f745c2663e6c7a1b5fa24d58f6e7ae6439b47365a9a0ce9bfdc890c7c4e00508f3784236df51d8d77e841f5a02da2d7db10d267060a18d90b7ff0710fb957d4ce8d5fd3f1ab02472a52e10b0bc4ce3439781643a15b56506f01773a72ffeddb889b09def51ca4c9f14933849ed76bfc4b5883f707410da90920b6b3a49d393bf224a647685c1e93878f15fc406dff82e85ac62f3058a475702462ccd387b75724336d46efe1adb822cc574425cdec3bbf8cba092b0a2056506c802073c3b61b3b2ca51fb2f4873d4eab299965531250ec36170acf48aec8ea35afa923f3a8f11ea079bc2aa18bf7fc266042de51a8404077f68365a1e0ec1c08f358154bfa32c735b5c02e5c16af6a64a495ba80f864f04d7e38d462c175bf10db4bb2c6e39351739e569f60a9f80cfca81e30a8d7a81bd1aa2bef42cce3fb862288ed92885f370d4467e38f90e839ecd3bf71f76af1d96f5b27fb1e8e205e5e369788e2bb666decd72b553abf270648ab9531957a7df582e919ba9527374a00f1f67684199c663e8caab7066baa9a1f0d9ef7eecadf81e14962b489c43d6a22784c0d486c669d9cb30ac5fd4e4cbb94cf4af0aeecdc59bd39db844e11e3b39002bd1c005ad955cb4fb7efe4770601ece3c84dea4c1b83317ce77e43c99432529edce6aba093c88f42e04dfc5c803834bbeeae2b4344fc87b3f975f7c31ca3ed6f159625cf1573df2f4886dec8de7f6996e42b2250ed34d7d2bfa1dbcbd7374cacb527d83fe4ae91fbd7129b4b727a44b82eabfc4c79fd23f2d92207c6b2388e62583677827a3e60e07e1434a2e21c5390e051990ba4d2707e7b355ae43c8c9a573ed7d5253535666b830bb31d6a61f70fd321edfc7d3db8fb8954999791cd6a35d642a3295f9049f59610b375939bea8417754744b687e55014266fed9245d868091264ee818dec9604bd9931c34a3dcbd4e984d7e134c3b1a66ee931842423af1dd2d23510d83da1063a83170d568ff8530f7b992831ce680cde6618fb860d2256984cd09bc34e705533ec66408ecb9d85f6376f96ab50d8bffd6cde0aae983c918d1683f8317d60543382aa5b929a0d8e5ff0c260cd1b0d6dce466e09898073e3ff396993ecb1b0292d99b02628d35d2197f5c47feae5e03f00824ab519cf3438b8284d97600743e3b1ea6e7028d67c9e5cc0cfba2afffc81bd841f3a3b4836a48156708f7c9920769aa9fb704e1d4122a8a0ca37507ed36b1b7c2390805b113227463c35c02f8f53a63b6ccaf234553f6b752d3d4788b38c1c73a6c3036c9a7dafa0ea78c88fac696e6a44bf1628fbe6b7f9cf703fc8ee4b51172072744b29e5148f5d88263f86eb64453c571775ef0d97d17c6aa9f052ec8b6189a2a517af33b366050f8ccecf450bb9f204c8bb56835c0294d8a7afcd871f13d2da6837232d42d6c8282af47d30c7c20f981270d59bf9b5c277d44eab5e64422af39a3670e3ea125b645cf2764ec9a3ca4cdc2f24f712c4476e9e3a9bf177a79d07c5b5d421b5a0baef27961488e64060e432cb2c9b1c46eca9b1400cc0423328a6cb7dd786d34fccb55bd17e193ba22f0786fb9d0ed4af30d80deef4727ad9d82df41251d0178570adca60e22ba3689fdacd22d398cd01abdd9c16fda5b1f57d8751df85ff6de617ece85afc07fca767fe2ff55e3a0d8077d0f7f924bf25cd3d24761f7301dc05db4c32dea8dd77602dd306c5e48955597b14c291a04b25fdc09a243d4a8669d5d32c7365b101e81dd3d52c10451bdf22753ab351547b4a4c3de298022214f6261a49a49e70fb466af23779b00a91523f00e557da160831366fd67e991343824d1192a39bd2851fe2e07d45d149624a750c54654d3d35ec6b1339c28e39464793672b5f6603f476f91a3b1fc75dad59dd7afb07d946778594d23a629554a54acef049d708d6af1888e4b8c952ffd6f0af93b78be317a44b359b736ff742d3e05bb354f834764e7472074d0eae0720ee739348d8591e47c4cd0e7f8d6f30410801bba47cb942abe58cbf3f491c515c1af39fbec41 请输入微光提供的通行证：","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"Me","slug":"Me","permalink":"https://starcried.github.io/tags/Me/"}]},{"title":"伤","slug":"伤","date":"2023-04-26T15:40:00.000Z","updated":"2024-08-11T16:49:55.635Z","comments":true,"path":"2023/04/26/伤/","permalink":"https://starcried.github.io/2023/04/26/%E4%BC%A4/","excerpt":"","text":"膝盖有一处伤，大概是初中得的，竟然连是如何得的都已经记不清了。想来，大概是当时受到冲击。不过膝盖这种地方多多少少都会被碰一碰，何况我还小，碰的又不很疼，应该很快就会好的。 在高中不知何时，膝盖在桌子上又磕了一下，我感到针刺般的痛。摸一下，竟发现那个位置凹陷下去一块，像被粉碎了一般。我开始慌了，赶忙告诉父母。因为高中学业原因且此伤并无大碍，拖了很久才在我的坚持下顺便去骨科医院看了医生。 医生问我有什么症状，我说，没什么症状，只是受冲击和过度运动后会痛。然后我指了指我的膝盖说，就是这里，摸着像感觉碎了一块骨头一样。 医生没去摸，说，拍个CT看看，骨头没事就没大事。 掏了钱，去做了CT。骨头没事。医生说没事。家长说没事。我说，有事，你摸一下，感觉碎了而且会疼怎么会没事。 医生仿佛很不情愿的摸了，一下，然后说，骨头没事，其他软组织结缔组织什么的我们骨科医院也看不了，你要是不放心去别的地方看吧。 父母很开心，没事就好，骨头没事就没大事。我没有时间再去其他医院，无奈只得离开。 上了大学，不到一年的时间里，我多次花费大段的时间去骑车、滑雪、打羽毛球。在滑雪时，不可避免地会摔跤，膝盖高速磕在雪地上的痛感十分强烈。可我又不愿放弃滑雪的机会，于是在几天时间里，每天晚上用云南白药涂抹膝盖。即便如此，我仍感到我的膝盖逐渐连弯曲都会疼痛。这下我一定要再去检查一遍了。 于是最近去了医院。医生说，有什么问题。我回答，膝盖几年前受了伤，一直以来没什么影响，但是如果被碰到会疼。 医生说，哦，那你这次来看什么的。 我很疑惑。这难道不算伤吗？还是说只要不影响所谓“正常生活”的伤都不用看，非得等事情严重化了才配治疗？还是说，我去滑雪，去骑一百多公里车不算“正常生活”？ 医生说，那你去拍个CT吧。我说不，我拍过了，骨头没事。医生说，那就去做个核磁共振吧。 掏了钱，两周后做完了。脂肪点损伤及关节积液。医生说，没事，回去休息，少运动，保护好，消消炎就行。 我休息了多久？我难道要一直休息下去吗？…… 我有一处伤，很久以前得的，至于是怎么得的我已经记不清了。 他们说，这是小伤，没大事的。但是每次我被戳到痛处，那个地方还是会疼。 我把那个地方指给他们看，他们说这种伤无关紧要，甚至不愿意去触碰我，不愿意去了解我的伤。 我很害怕伤会扩大，于是不停地问。他们的无所谓失去了耐心，说，如果你戳到痛处会疼，那就不要被戳到痛处啊。 可是，我要去做自己想做的事啊。他们说，你不是怕疼吗，那就别做了呗，又不是活不了。 也许，并不是这么回事。只是我觉得这件事会有更好的解决办法，一种不需要我承担艰难抉择的办法。 有时候，我会希望他们注意到伤本身。有时候，伤本身似乎并不那么重要。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"2022 ECfinal 赛后","slug":"2022 ECfinal 赛后","date":"2023-03-26T06:42:00.000Z","updated":"2024-08-10T13:34:35.069Z","comments":true,"path":"2023/03/26/2022 ECfinal 赛后/","permalink":"https://starcried.github.io/2023/03/26/2022%20ECfinal%20%E8%B5%9B%E5%90%8E/","excerpt":"","text":"情绪倾泻警告 3.26 1:30他妈的…… 这种感觉，这种在决赛场上失利的感觉，THUPC，NOI，三年的 ECfinal，全部都是…… 他们在祝我成功，每次都是，但我每次都…… 整整一个下午一个晚上我都在阻止自己想这件事情。我把平板的电量从满格耗完去看从没看过的克苏鲁恐怖游戏，看到眼睛充血。我点了凉皮和肉夹馍，但是却难吃的要死。然而我竟然把它们都吃了！ 我不想去我队友的房间，不想去见他们。刚好也没拿充电线，明天的华为挑战赛也别他妈的去了。 已经到凌晨了……也许我去补补我那该死的没写完的作业会好受点。 我觉得我已经做得很好了……但是却总是不够好……明明有些题目、有些问题是可以解决的，只要再给我一些时间…… 我不想去埋怨队友，他们真的很棒，并且埋怨有害无利。我很清楚这点。可这样我就只能埋怨自己……为什么非得去埋怨呢？那为什么不能把事情做好呢？ 我不适合做队长，肯定不适合。我不知道明年我是否还要参加 ACM。上学期的驴日的成绩已经足够我警惕了。 可是我不想离开……我真的很喜欢和大家一起解决问题、一起赢得荣誉的感觉……然而我却不能承受失败的后果…… 是我做得不够好吗 是我还不够努力吗 是我的错吗 我还有改正的机会吗 我还能得到原谅吗 求求了 求求了 我好想和人诉衷肠。但是说话没法解决问题。 我好想放弃睡大觉。但是没人为我行为买单。 我好想得到认可。但是我总是一败再败。 没这本事却想名扬天下。没那富贵命却养了富贵病。永远达不到的要求，永远低不下的头，永远无法得到宁静的灵魂。我不想屈服，但我也不想永远无止境地跋涉。我想解脱，我想解脱，真的没有其他办法了吗 3.26 11:30现在是第二天中午。又看了一早上的 不得不说，这种复古酒店的氛围太合适了。 今天就要离开。本来很正常的作息被搞得混沌。在这里毫无意义地浪费时间。哦，早上的比赛没有去。 我开始理解为什么有人喜欢恐怖游戏了。这种廉价的精神感官刺激可以逃避现实，欺骗自己的大脑假装自己在面对威胁生命的恐惧，可以忘掉现实中这些有的没的东西……","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"ACM","slug":"ACM","permalink":"https://starcried.github.io/tags/ACM/"}]},{"title":"微光","slug":"微光","date":"2023-02-14T15:59:00.000Z","updated":"2024-08-11T16:51:42.085Z","comments":true,"path":"2023/02/14/微光/","permalink":"https://starcried.github.io/2023/02/14/%E5%BE%AE%E5%85%89/","excerpt":"","text":"“微光”的来源我很小的时候，总是喜欢一个人胡思乱想。 当夜幕渐渐地压下来之后，母亲会拉上窗帘，关掉卧室的大灯，然后打开只能模糊照亮大床的床前灯。灯光在母亲那边，被母亲坐起的身形挡住。此时她会去做一些用针线修补的事情，而我就贴在她身旁昏昏睡去。 可我并不总是很困的，但我又生性安静不会闹腾和打扰母亲，于是就在令人昏昏欲睡的微光下尝试入睡。闭眼时感受着被窝的温暖和身旁母亲的温暖，拉拉被子，和母亲贴近些；睁眼时试着看清没有光亮的熟悉又不熟悉的房间。没有照明的屋子比白天神秘得多，天花板是黑色的，吊灯只有浅浅的轮廓，微弱的灯光打在窗帘上显现出渐变的明暗效果，帘布上的花纹变得神秘莫测，显现出不同的图案。我会饶有兴味地看着这些图案，有时会渐渐地睡过去，有时睡不过去，就会在脑海中想一些奇异的事情。倒不会有窗帘上的花纹飘到我的梦中去，而是想一些虚无缥缈的事情，或者没有事情，单纯的想一些“虚无缥缈”，像在浩瀚的宇宙中自由地飘荡，无助的飘荡。 有时候飘荡的久了，我会感到控制不住的孤独和悲伤，然后流泪。我和母亲都还记得，有一天晚上我止不住地哭出了声，母亲见我没有任何预兆地哭了非常惊慌，忙问我哪里不舒服，我说我没事。 宇航员在宇宙中脱离了牵引，在太空里无助地飘荡。他能看见宇宙中发来的微光。在上学之后，我知道这些微光是从遥远的恒星传播了无数年来到眼中的。 这个距离，对我们来说是永远，是遥不可及。 可无论怎么想，微光仍源源不断地从遥远的星星来到眼中。 大概是我上高中的时候，有一次我过生日，父亲送了我一本书。那本书很有年头，我查了一下已经不再印了——杰克·伦敦的《热爱生命》。是一本他的小说集。里面有一篇《雪狼》（又译为《白牙》），讲述了美国阿拉斯加淘金时期的一只灰狼，作为纯种灰狼和猎犬的子代，从野蛮的雪原经历生命中一次次的机缘巧合和一次次的生存绝境，最终得到了属于自己的安宁的故事。我反反复复读那篇文章。在读的时候，我能感受到我就是雪狼它自己，面对生命中的种种磨难和痛苦不竭地寻找希望，在被伤害和驱逐后仍能够勇敢地信任生命中存在的爱。这首生命的赞歌深深地影响了我的人生观。 生命的意义是什么？在茫茫宇宙中，我们也许不值一提，但生命对于自己这个个体来说就是一切。生命也许没有意义，但若你坚信它有，并努力地寻找，也许本身就是一种意义。 就像在追逐宇宙中的微光。 上高中后学信息竞赛，要给自己想一个网名。思考良久毫无头绪，情不自禁地打下 Star_Cried 这两个词。星星在呼喊。星星的呼喊是什么呢？是燃烧自己的生命爆发出巨大的热和光亮，不远光年来到你的眼前，化为无尽黑色宇宙中的一小点微光。 设定外貌种族：北美灰狼；配色：整体为北美灰狼黑灰白配色，眼睛下和胸口为白色，眼下左右各有点黄色。黑瞳带深蓝。 通常着衣，带兜帽的长袍（不一定戴）、披风或大衣，披风为左半边披风。披风：星空带渐变。 衣服配色：类似披风，深蓝色。装饰：不同世界观、不同时期，不同服饰、不同装饰。 世界观可存在于任何世界观。在每种世界观中独立。 经历：一只普通的狼，有对世界美好的幻想和期望，在经历很长一段时间的漂泊、体验过人生百态之后变得些许麻木，但也因此有很多技能和经验。有过朋友和故事，寻找生命的意义。 性格：智慧，冷静，热心，幽默，理性思考，但是浪漫主义者。重视亲情和真挚的友情。讨厌麻烦、重复、枯燥，缺乏耐心。不喜欢承诺，因为会尽力去履行。有一套自己的行为准则。 喜好：神秘的蓝黑色；凉爽的天气；静谧的环境；甜味和咸味；音乐（乐器和演唱）；默契的朋友和完美的合作；喜欢涉猎各种技能。 讨厌：虚伪；政治；孤独；无力感；酸味、辣味","categories":[{"name":"微光","slug":"微光","permalink":"https://starcried.github.io/categories/%E5%BE%AE%E5%85%89/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"The Truman Show","slug":"The Truman Show","date":"2022-10-02T13:52:00.000Z","updated":"2024-08-11T17:00:29.419Z","comments":true,"path":"2022/10/02/The Truman Show/","permalink":"https://starcried.github.io/2022/10/02/The%20Truman%20Show/","excerpt":"","text":"The Truman Show Is that the best you can do?You are gonna have to kill me!!!What will we do with the drunken sailor…(Drunken Sailor) 非常激励人心、有启发的一部电影。 我不知道如果我是楚门的话，我能否抛弃家庭、抛弃朋友、抛弃现有的一切去追逐自己的梦想。或者说，当我身边的所有人、所有事、整个世界都在否定我时，我是否还能够坚持自己那“不切实际”的执念。我不知道我是否有勇气和整个世界作对。 我觉得大部分人都有过像楚门一样的执念。可是相较于电影中比较明显的破绽，以及从上帝视角来看的结果，现实中我们的执念或许更加难以实现，或者是错的。比如说，我曾经猜想有没有可能我才是世界上真实存在的人，其他人都是为我服务的。即其他人“存在”是因为我和他有交集，在我观测之外的人根本不存在。这和《楚门的世界》的演出非常类似（如果我之后有幸能钻研唯心主义的话，也许能找到更系统的理论。至少我现在仍然认为这种观点是有价值的）。 但是即便我是对的，即便真的我是生活在虚构的空间中，这个空间的边界也可能没有电影中那样具体可触。假如这个“边界”是真实存在的，也许它在更高维的空间，也许你穷尽一生也没有办法到达它（这可比楚门遇到的“风浪”困难得多得多）。在这种情况下，可能“边界”对于我们而言存在与否都无关紧要了（可以说是错的了）。因此，我认为绝大部分人都无法到达他们的“执念”。我们也许尝试过，但无数次的失败总会将我们的想法否定——这就像是从小孩的异想天开转变为大人的现实老道（没人逃脱过这点）。我不禁思考，在电影中，楚门一直有被困住的想法是因为周边环境一直在阻挠他实现自己的目标，他从未真正地尝试过一次。如果剧组有能力让他误以为自己已经尝试过但仍然无法到达边界，他会不会真的放弃，或者接受自己精神有问题。 Seaboard Island，中译为“桃源岛”，代表着楚门的舒适圈。它就像一个世外桃源，就像导演所说的，待在里面完全可以度过你的一生。从出生到死亡。导演有句话没说错：在外面的世界，你会遇到比在这里更多的谎言和困难。但楚门仍毅然选择了踏入从未涉足的黑暗。或许，生命从来不害怕迎接挑战，生命只会害怕平庸和一成不变（算是另一种死去吧）。至少在楚门身上，在少年的心还未燃尽的人身上，是这样的。 After all, it’s a “Truman show”. 我们每个人都有自己的世界，都有自己的“桃源岛”。但并不是每个人都能克服心理障碍向远不可及的天际义无反顾地前进。 当然，我也在电影中得到一些非主线的感受。 电影中时常穿插一些观看节目的观众的画面。我们这些观众的观众，看着可能会觉得他们仿佛很关心楚门的一举一动，甚至为他欢呼喝彩。但在电影最后楚门走进那扇门，意味着节目的结束时，两位刚才在为楚门的成功泪流满面的警察紧接着讨论“接下来看什么其他节目”。楚门经历的一切对他们而言只是一个节目而已。这也许是在警示看电影的我们——当你看完楚门所经历的一切之后，你会怎么做？很大的可能是，什么都不会改变。我想到一种家庭妇女，在家里看那些大城市的商人或者富有家庭的电视剧，乐此不疲地欣赏这那些与自己毫无关系的脱离群众的商业产物，随着 BGM 的渲染或者一两句大声的台词为那些不属于她的故事哭得稀里哗啦，然后继续做自己的事。 楚门出去之后的故事也令人遐想。他将抛弃自己从小到大所经历的一切。他将重新接受他的身世。他能够到达芝加哥。但是，他会遇到新的边境。他永远会的。 还有一些，不再细说。 影片中有一些非常经典的镜头。比如楚门触摸着边界，缓缓走向通往 exit 的台阶。有趣的镜头有，所有人手牵着手地毯式搜索楚门；太阳突然出来后所有演员归位一动不动。 镜头运用和艺术处理也非常有趣。影片前半部分在卖关子，我们和楚门一样用局限的视角观察，和楚门一样感到怀疑。有一些有边框的摄像机镜头和场外观众的镜头在不断暗示。在与父亲重逢后，我们恍然大悟，用观众的视角观察楚门的一举一动。但我觉得我们存在第三个身份：观众的观众，也就是我们自己。影片的开头，导演在向观众讲话，我以为是在给我们讲，但实际上是在给楚门节目的观众讲话，但只有我们在恍然大悟后回过头来看才能明白这一点。以及最后看观众们的反应，目的也是留给我们自己的反思。 其他地方我也不太会分析。总之，这是一部经典的电影，而它的经典是有原因的。 Oh, and in case I don’t see you…Good afternoon, good evening, and good night. 顺带一提，Drunken Sailor 是我在玩 Assassin’s Creed: Black Flag 时很喜欢的一首船歌。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"观后感","slug":"观后感","permalink":"https://starcried.github.io/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"}]},{"title":"I ❤ SJTU","slug":"I ❤ SJTU","date":"2022-09-06T15:02:00.000Z","updated":"2024-08-11T16:56:20.644Z","comments":true,"path":"2022/09/06/I ❤ SJTU/","permalink":"https://starcried.github.io/2022/09/06/I%20%E2%9D%A4%20SJTU/","excerpt":"","text":"最近更新：2023.3.26 I ❤ SJTU 这个家伙愉快地踏入了上海交通大学的大门。 他将在上海交通大学闵行校区度过他的若干年大学生活。 让我们看看他会变成什么样子。 这里会记录日常，也会记录他可能有（回忆）价值的思考碎片。 2022.9.6军训已经几周了。如果算上之前 ACM 队训练的一个月，时间也许更长。 上海交通大学，全国最大的校区，我即将在这里度过四年或更长的时间。虽然我已经在这的一会相对来说只是很短的一部分，但是却有开启我成年人生的重大意义。 学校课程还未确定，但真正的课早已开始。军训开幕当晚我请教母亲针线活，参加军乐团，训练和报名 ACM，打听消息、咨询学长自行车的事宜，并且从家里借了第一笔钱。我很幸运这里基本上都是非常善良耐心又高水平的老师和同学。在大学，你可以轻易找到专业特长的学长或者老师进行帮忙。而这就是中学以前所没有的全新资源：人脉。伴随着这项资源的，是对交际能力的需求。是时候增长这方面的能力了。 从高中过渡到大学得十分顺坦。也许这和我初中离家高中住宿加疫情封校、高中就开始竞赛生活、高考之后没有查成绩志愿随便报、提前到校学习等有关。所以我并没有有什么不适应，也没有体验到很多同学所经历的非常强烈的“思乡之情”。相反，倒是父母经常打电话来抱怨我不和他们联系。几乎到了那种除了要生活费就失踪了的状态。也许之后这种心情就会愈发显现。不过就现在看来，很快适应自己生活也许是件好事。 高考好像离我很远了。开学之后我就很反感讨论高考的事情。不过似乎在上交的也没几个很乐于讨论这件事的。所谓英雄不问出处，我们很幸运迎来了一次重新出发的机会。上交的资源也是极好的。生活学习条件也很好（物价也许有些许贵）。非常期待之后的课业学习。 感觉上大学之后，能推动自己学习的最大动力来源就是自己。没有人规定你什么时间必须坐在哪里学习，甚至真的翘课没有人管了。学习也是自主学习和交流为主，这和我竞赛阶段倒是有些类似，因此我应该可以较为快速的接受这样的学习模式。还有就是奖学金吧，真的很想不给家里添负担，顺便能自己支配钱款去做自己想做的事。 真的是，每次都感觉自己有一大堆心得体会，但确实去写的时候又发现是如此之少。我还没有什么成就呢，没有什么可记录的。 说起成就……差点忘了一件最重要的事。一定要尽快搞清楚自己的目标何在。 想起来之前被拒绝之后一直想吐槽的一句话： I’m Shanghaied by THU. 当时就是非常的愤愤不平。现在看来倒觉得那时十分有趣。也许我能为 Shanghai 这个词赋予一个新的含义呢？ Hello, SJTU! Hello, Shanghai! 2022.10.23小时候，我经常在晚上莫名其妙地默默流泪，却不知何因。 刚才正在做自我人格分析，突然想到这件事。很奇怪，小时候我几乎每天晚上都会哭（不出声那种，经常吓到父母，但是我什么事都没有），却不知道原因。并不是我忘了原因，而是当时就不知道为什么，父母问我的时候我也不知道为什么，就是“难过”，那种没有缘由的感觉，像心痛，但是我的心脏没有问题。 突然很怀念那种感觉……这样看来，我现在每天都有点没心没肺。虽然那种悲伤根本……毫无意义，但是我觉得却比我现在做的所有事都更有意义、更令人怀念。 明明这一个多月以来经历了很多事情，有很多值得纪念的事，认识了很多有趣的人，但是能驱使我再一次动手写博客的，竟然是这种莫名其妙的想法。 也许我现在看起来心智健全，但可能我内心深处真的需要一点心理治疗。或者……让我能再体验到小时候的那种虚无的悲伤。 2022.11.9自觉现在是十分懈怠了。不好。但又不知如何是好。 习惯了翘课，但是翘了课又不知道干什么。不过至少没有了以前的那种紧迫感。不对，早都没了。 翘课是坏习惯。尤其是借着竞赛的名义翘课。 有很多事情想做，但又不是特别想做。没有动力。没有吸引力。没有兴趣。怎么年纪轻轻就萎了（不是） 每天晚上打好长时间游戏，打完又觉得空虚，觉得虚度光阴，却又不想上课。 想找一个每天都能让我鼓起干劲泡着的事情……或者……人。不会觉得无聊，又充实有所收获那种。 无枝可依。 2022.11.18成绩出来果然差的离谱。从小到大最低的成绩吧。如果放在以前，我估计会慌得要死然后奋力追赶，但现在我只感到慌乱却不想动。不过让我感到宽慰的是我们 ACM 队出线了。如今可以赶紧调整状态和心态到正常的学习生活了。要不然，就晚了。 感觉自己有心理问题，结果这个念头马上在和学长的聊天中消除了。果然还是缺少交流和宽慰。大多数心理问题都是这样。找个人说说话就能解决很多事——原来我仍然喜欢钻牛角尖，只不过现在是把自己牢牢地包裹住，然后对自己进行过量的批斗和贬低。但身边从来有温暖和美好，只要能主动去探寻。 聊天的时候总是执着地去否定自己，否定他人给出的建议，认为对方的建议和分析没有直击要害，没有告诉自己问题的答案。但实际上这种问题根本没有答案：自己要去寻求什么，自己的热情在哪里，没有人能回答。在他人身上寻找这种答案只会自讨无趣。但聊天的重点不在这里。我可以倾诉，可以分享，可以从别人解决问题的方法中学得东西，即使不适合自己也有借鉴意义。不管怎样，这是一种缓解问题的方式。真正要解决问题，还是得靠自己动起来。 睡了一下午。 2022.12.22学期快要结束了。自视半年以来，仿佛什么都没干似的。期望年后如果疫情政策能彻底放开，可能就有动力去干很多事情了。不过话说回来，数学本来就是在室内坐板凳的专业，封闭应该对我没有影响才对。 前几天看到一年前发表的说说。那天西工大附中晚上突然封校，半夜十二点全校走读生回学校拿书本。当时避之不及的病毒如今不得不与之共存。现在母亲也患上了。未免让人思考如此长时间的防疫是不是真的有必要。可是这和我又有什么关系呢？不防疫会改变任何事情吗？ 不知道自己要去寻求什么。从上海回来之后坐车环绕老区，越觉得这个我生活了数年的地方是如此之小，从汽车站到家门的距离不及学校周长的四分之一。在学校时常绕校园骑行，限制速度的只有遍地的减速带，而到了家里，限制速度的是这时感逼仄的空间。如此多人生活了如此久的地方，说到底也只是个小山沟罢了。随着我们这代人的离去，这里居住的人只会越来越少。对我来说，我想去更远更广的地方。 梦想总是很大的。但不是为我这种每天睡到中午起床、晚上打游戏的三更半夜的人准备的。总是期待着明天会更好，却不去付诸行动。知道自己错了却没有勇气去改变。好消息是，我变得不再在意别人的目光；坏消息是，我难以为自己而活。看来我只是丢掉了自卑，而并未变得自尊。我本觉得对不起的是家人，但现在真正对不起的是我自己才对。 想赢得别人的尊重首先要尊重自己。这事还真他娘的困难。 2023.1.2前几天得了新冠不知道什么毒株，第一天发烧在床上躺了一天，第二条严重鼻塞，第三天失去嗅觉和味觉，直到今天才基本恢复。 失去味觉和嗅觉体验很奇妙。能像吃橙子一样吃柠檬直到牙齿发酸，喝骨汤能尝到油脂的感觉却没有肉的味道。没有感知地就尝不出任何东西了，却感觉非常平静，仿佛身体什么都不知道似的。实际上这次新冠我的主观感觉也就只是大号感冒而已，但实际上身体内部发生了什么变化我自己也不知道。如果哪天我真的永远也尝不出味，我可能也不会有什么太大的感觉，甚至回忆不出之前能有过的味觉刺激。如果哪一天我得了老年痴呆，我自己应该压根不会意识到，也不会为我自己感到悲哀。我作为一个高级神经中枢能掌握的事情实在太少了，甚至无法掌握自己的身体。 希望这次得病的效果（指抗性）能持续一段时间。如果一切都能回到三年前的正轨的话，我可能就能体验到真正完整的大学生活了。 2023.3.16昨天是母亲的生日。一定要记住。记住关于你爱的人的事情是很必要的。 好久没有更新博客了，主要原因是上学期数分挂了。很显然，上学期并没有“很快回到正常的学习生活”。之前与一位同乡学姐闲聊，她让我不要像她一样太一心卷学业。挂科后我只觉得可笑，没想到我有的是完全相反的问题。从结果上看，还是我的这种问题更严重些。这学期一来，才知道强基计划对于不及格的学生只有一次宽容的机会（我已经用掉了），意味着以后四年内我如果再有一门科目不及格就必须退出强基计划。于是尽可能推掉其他活动，有时间都泡在图书馆内复习，没什么娱乐（但仍然参加了 MCM 和 ACM 训练）。 由于我可悲的自尊心作祟，我没把这件事写在博客上，直到现在补考过了。希望我能记住这次的教训：只要在学校，永远是学业第一。如果想像比尔盖茨或者乔布斯那样的话，最好先辍学。不过话说回来，一有时间就去图书馆的做法挺好的。钱老就喜欢泡图书馆。虽然我不去看书，但和大家一起学习总是很有动力，何况上交的图书馆离得又近设施又好。 前几天水灯节，下一周又有百团大战，菁菁堂也开始放电影了。水灯节那天的人潮我真是数年未见，十分感动。我们很幸运能体验疫情结束的大学生活，之后也会有越来越多的活动和机遇的。 （所以我为什么给自己买了个显示屏） 补考完感觉又有些松懈了，仅这一周就骑了两百余里的车，给学习的时间又少了点。明天晚上去图书馆静心学习。 补考之前非常焦虑，感到自己犯了难以挽回的错误。事实上也是无法挽回，但人生就是如此，每一次抉择，每一个分数。好的是学校给了我第二次机会。焦虑时问了同 ACM 队的学长，问了 yyu，问了班主任，问了导师，他们给我的建议都是：有能力，没问题，就是没上心，都觉得我很有希望，并且建议我减少花在娱乐和社团的时间。看来我的能力没法两把都抓。必须得舍弃些什么了。比如昨天就推掉了不太感兴趣的数学 prp 科研项目。这是好事。 很多事很麻烦，很糟糕，很渺茫。但是学校的朋友都很热情，并且都是和我一样的人。我们面对着相同的事，相同的前景。我喜欢上交，以及这里的人。 2023.4.26总感觉状态很差，不知为何。明明有那么多值得高兴的事情，却一直不觉得庆幸，反而不断抱怨自己遇到的各种困难。对学习没有很高的兴趣。 说到底，我还是认为自己不是非常乐意学习。我多么希望自己能从数学和学业中得到乐趣和满足。也许这是一件好事，逐渐认清自己的兴趣位置，更能指导我过自己想要的人生。不过现在我只是纠结。 我在学很多东西。在学如何学数学，如何上大学，如何做好自己，如何去爱他人，如何平衡生活，如何处理情感和情绪。也许……也许我太急功近利了，太焦虑了，太迷茫了。我需要时间，并且需要在这些时间内先撑住。 2023.5.5前一段时间迎来了微光的诞生，我的生日。人生第一次有朋友来庆祝我的生日，人生第一次骑行百里去看日出。虽然腿受伤了，但可以一起去健身房。感觉整个人都被治愈和感动了，现在（至少今天）做事好有劲。被关心的感觉真好。 再一次的，我喜欢上交，喜欢这里的人。 假期给了我足够的时间去调整和休息。倒是没有花费很多时间思考，但是无论在学校、去城里玩、骑车还是睡觉都是很放松很自由的状态，和亲友在一起可以很放纵不担心社交，不用紧绷神经担心和计划自己的每一天。甚至自己没事的时候会想去主动学些东西。说实话，这就是我想要的生活。是微光在过的生活。 总有那么些微光能够照亮我的生命。我更愿化为一点微光。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"结束了？结束了。","slug":"结束了？结束了。","date":"2022-07-06T12:56:00.000Z","updated":"2024-08-11T15:52:49.356Z","comments":true,"path":"2022/07/06/结束了？结束了。/","permalink":"https://starcried.github.io/2022/07/06/%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%9F%E7%BB%93%E6%9D%9F%E4%BA%86%E3%80%82/","excerpt":"","text":"2022.7.6 昨天是清北强基计划出结果的日子。班里许多同学都考上了清北。至于我，早已被上海交通大学数学与应用数学系录取。 我不知道心里面是什么滋味。在班里能前往我心心念念学校的同学中，没有我的名字。 或许有人会说，行了吧，上交还不够吗？相当于上海的清北嘛，虽然总排名差了一点。或许我的家长会说，不错了，现在你是家里学历最高的人了。上交对于你来说不一定比清北差。诚然。在我此前的无数篇碎碎念中已经说过，我不适合清北。诚然。去上海和去北京有着截然不同的命运。到时候我会认识完全不同的人，经历完全不同的事，谁又说这种可能不会比去北京的可能更好呢？ 可是，可是，在给亲戚朋友说我要去哪的时候，我总是心里不舒坦。“上交”的名字总没有“清北”的响亮。这种感觉，就好像别人买走了你最爱的玩具，别人实现了你梦寐以求的梦想。尤其是，我之前立了那么多的 flag，到最后没能实现。心里空落落的。这种事的原因，也许是因为长久以来别人的耳濡目染，也许是我对自己的心理暗示，也许是我的学途之前走得太一帆风顺了。无论怎样，最痛苦的事不是你无法实现你的梦想，而是你能够一窥梦想殿堂的景色，甚至拥有进入其中的可能，却在踏入大门的最后一刻，踩了个空。 然而，路还得走。为已经发生的事情难过不能解决任何问题。况且，上交很不错不是吗，我又不是全盘皆输，只是跌到了之前已为自己找的退路上罢了。虽然如此，克服这种心理估计还得好一阵子。 我是一个极其自负、自满、叛逆又懒惰的人，万幸的是还有一点点学习的天赋。凭借这点天赋和我的自负，我从小县城一路爬上西安最好的高中，并且在高中参加竞赛，停课一年拿到信息学竞赛银奖。但是在清华学科营和高考中失利，最后考入上海交通大学。 许多老师都警告过我：像我这样的人，早晚是要耐挫的。我已经在我成人的那天感受到了。 性格决定命运，我知道，这只是我将来会耐的无数挫中的有显著影响的第一个。如果这第一个我都撑不过去，那么我将没有未来可言。 我的高考分数只有 646 分。这远远跌出了我的预期（因为我考完没有估分）。因此我们开始担心上交的强基是否通过。强基录取结果在高考出分后一拖再拖，直到拖过了一本志愿填报的 Deadline。于是，不可避免的，我得面对填报志愿这件事。 但事实上，我没有勇气去面对。当我在设备上查询我的分数能被什么学校录取时，我发现我的分数连华科大计算机系、浙江大学、甚至南京大学都上不了（而这些是我之前瞧不上的学校）。于是乎，我开始躺在床上摆烂，脑袋空空。父母急匆匆地问我想去什么学校，我却什么都不回答，一心只想着上交的结果出来把我带走。对我这么自负的人来说，我实在是无法接受比上交更糟糕的结果了。而这些结果从我父母的嘴中传出盘绕在我的耳边：哈工大深圳校区，南开大学，西安交通大学……还有一堆我听都没听过的大学。我觉得我神志不清，根本没有心思去想如果我连上交都走不成，该怎么办。我之前的说法一直是“如果走不了上交我就不上学了”，意思是，如果我真的到了这种地步，我大概就会在大学摆烂，那么我去哪个大学也就无所谓了。 我没有勇气去面对完全的失败。 这是一种懦夫的行为，我知道。但是我一向都这么脆弱不是吗？我什么时候表现出，面对挫折能顽强地挺过去？一直以来，我的自负自满，都有我的实力做支撑，最后也都很幸运没有酿下恶果。但是，面对真正的挫折，完全的失败，我完全束手无策，无法接受。我的心理承受能力在这种事面前展现地十分脆弱。也许我平时表现得很理性，比如舍弃什么应该去干什么，但是那都是属于在可接受范围内的利益最大化的决策。上大学没有这样的决策。上大学是一刀切。学校，专业，两个名字便是所有。 所以，到志愿最终提交的时候，我甚至没有去看一眼——全部都是我父母填的。我多次焦灼地给上交招生办打电话，得到的回复总是“希望很大”。于是，我抱着这很大的希望，幸运地等到了我想要的结果。 然后在清北强基结果发布的时候欲求不满 估计以后还要耐挫。 高中生活对我来说过得真是好快。我难以想象，不到一百天前，我还在教室坐着刷理综题。三年以前，我第一次自信地踏进这个学校，对未来满怀憧憬。 高一的时候，听说有竞赛。当时的文化课成绩比较稳定，但是不在顶尖水平，然后根据之前的经验觉得自己裸考上不了清北，就来信息学竞赛碰碰运气。一开始学竞赛真的是煎熬，因为它不像文化课有老师带着你走进门，真的就是直接上来就给你讲东西，语言和基础知识全靠自学。反正我当时听得一头雾水。而且因为是少数住宿的竞赛生之一，没有晚上练习的条件，所以基本上什么都不知道，模拟赛全在乱搞。教练让刷的题根本不可能完成。于是，我多次在晚上躲在阳台里哭，给父母打电话，颤抖着诉说我的痛苦：文化课学不上去，竞赛也搞不好。甚至多次教练也在劝我退出竞赛。 高一期末之后，我跟着 fgf 选择了停课训练。当时的情况是，教练劝我别冲动，家长为我的文化课担心，我知道自己什么都不会，却对而不明真相的班主任说自己成绩还行，使他支持我停课。现在看来，当时属实是孤注一掷，我的赌徒心理也展露无遗（但是我却没有坦然接受失败的勇气）。与其说是心理，不如说是我的性格，那种不服输的性格、叛逆的性格、自负的性格、不顾一切的性格。而且，计算机是我喜爱的东西。我很幸运，我的父母最终选择了尊重我的意见，允许我去做我自己喜欢的事。这样看来，我也是遗传了我父母浪漫的优点呢。 至于竞赛时的具体细节，我的其他博客已经记录地很详细了。总而言之就是，我并没有拼尽全力。 高三回到学校开始学习文化课，也是一段非同凡响极度叛逆的经历。我凭借着自己的银牌成绩，无视学校制度，几乎每天早上和中午都迟到。晚自习翘掉的时间多于我上的时间（我没有翘晚自习去外面，只是回宿舍睡大觉。因此我高三甚至拥有我初中都不曾拥有的十多个小时的优质睡眠）。作业没写的部分远超我写的部分。如果下午放学之前是连着的语文课、英语课或者自习课，我就会直接回宿舍翘掉下午的课。这种事在西安最好的高中里，实在是不常见。我敢说以前的古人和后面的来者肯定没有几个（当然是要考到和我一样的成绩的）。甚至在疫情期间坐在班里上网课，我曾把手机带到教室使用（最后因为经验和技术不够被逮住了，虽然也没有惩罚我）。老师布置的作业总是做不完，而我又不屑于去抄作业，于是便每次上课站着就是了。总之就是，在义务教育的最后阶段好好体验了一把放荡不羁的青春。至于这样做的结果，现在已经知道了。不过至少到现在，我还没后悔。 当然，我回宿舍并不总是睡大觉。在早期，我突然想练吉他。于是我在高三完成了吉他的入门，基本可以完成 C大调 的和弦，可以弹一些简单的曲子。加上我唱的歌也不算难听，最终可以完成简单的唱奏，在晚上宿舍聚会的时候来上几曲。在中期，我又捡起来我许久未动的小提琴。小提琴声音的穿透力特别强，我很庆幸我的水平没有差到让宿舍同志们厌恶的地步，甚至偶尔会有几个人进来看是谁在演奏（不是因为太难听）。经过舍友的推荐，我在手机上搜到《告白之夜》的谱子并联系到能接受的地步。没有小提琴架，我便把手机架到上铺的床上，看着小得可怜的谱子练习。加上我初中自己练习的一小段林赛的《千本樱》，在宿舍整个活还是可以的。到了后期，同学们都开始使劲卷了，为了不打扰他们，加上强基被清华拒绝没了动力，便大多数时间躺在宿舍的床上睡觉。偶尔会和其他一起摆烂的同志玩几盘三国杀。直到最后。 值得一提的是，虽然我违反了规定带了手机，但我在学校的时候没有在手机上下过任何游戏，只是用来聊天（虽然也非常耗时间）、通讯、疫情期间扫码和搜索（比如小提琴谱）。即便如此，我觉得我还是没法控制好我自己。聊天真的伤神伤心。 致我放荡不羁的青春。 感觉高考后突然忘记了许多事情。或许是因为精神突然放松罢。忘记的不只是知识，还有过往的经历。 高考前想在这个假期做很多事情。不知道是不是因为上文提到的情绪的原因，现在没有什么兴致。 我现在脑子里想的只有一件事：骑车骑到上海。最近已经成功让母亲同意买一辆自行车了，虽然代价是答应她不做长途骑行。当然，为了我的梦想，我会毫不犹豫地在自行车到手之后撕毁这个协约。我知道母亲是担心我的安全，但是我更担心我能否完成的梦想。在经历过落榜清华之后，我不会想再让我的另一个执念妥协。即使代价是对母亲食言。即使代价是承担长途骑行的风险。 我相信我是那种为了梦想宁可放弃一切的人。 那么，一切都结束了，我的少年时光。 我将以全新的面貌去迎接新的挑战。我必须不断地走出我的舒适区。我必须抗击许多压力。我必须学会决策。我必须提高效率。 我必须为我向往的生活奉献生命。 2022.7.29 已经在上交待了好几天了，认识了很多新同学，和舍友也处得来。 突然在空间看到一个平时并不很突出的同学考上了清华，比较惊讶。又看到平时考得很好、老师很赏识的同学的说说，不知道他去了哪，于是仔细研究了一下前几天做出来的班级蹭饭图。 中国地图上布满了那些熟悉无比的名字。有一些名字出乎意料地出现在了清北，有一些应该在北京的名字却不在那里。有许多学生在高考中出色发挥，而有同样多的一些发挥失常，与梦想失之交臂。 看着这张图，我不知道心里是什么滋味。曾经的同学天各一方是一回事，但更多的可能是为那些被一次考试失利打倒的同学鸣不平。就像我当时在清华学科营一样。仅一次考试，便被分配在另一个城市，另一学校，多年，从此走上完全不同的人生道路。 不能说不公平。更多的可能是，命运。这就是命运。我能做的只有感慨命运。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"}]},{"title":"LA LA LAND","slug":"LA LA LAND","date":"2022-05-28T06:54:00.000Z","updated":"2024-08-11T16:57:12.455Z","comments":true,"path":"2022/05/28/LA LA LAND/","permalink":"https://starcried.github.io/2022/05/28/LA%20LA%20LAND/","excerpt":"","text":"City of starsAre you shining just for meCity of starsThere’s so much that I can’t seeWho knowsI felt from the first embrace I shared with youThat now our dreamsThey’ve finally come true 很久没有看过一部能让我流泪的电影。 从来没有看过一部歌舞剧和爱情电影。 但《爱乐之城》惊艳到了我。 电影里的配乐都十分动听悦耳，演员们的歌舞也美不胜收，更不用说出现数次的一镜到底将演员的实力体现的淋漓尽致。电影里光影和色彩的使用也赏心悦目，并且运用了多种艺术手法，让人感到在欣赏艺术而非观看录像。同时，故事也非常真实感动，没有某些文艺作品的矫揉造作，让我拥有共情。人物形象塑造和感情表达淋漓尽致。基本上完全对我胃口。 虽然自己没有过，但是我能感受到电影里感受到的真真切切的爱。那种知音相遇和双向奔赴的美妙甜蜜。那种在爱情和梦想与现实间的徘徊和冲击。那种对彼此和人生的浪漫。 我想做一个浪漫的人。 爱是能看到你成就自己喜欢的事时，自己也感到欣慰。 爱从来不意味着永恒。爱有春夏秋冬。 -Do you wanna stay for another?-No, we should go.","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"观后感","slug":"观后感","permalink":"https://starcried.github.io/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"}]},{"title":"2-SAT问题","slug":"2-SAT问题","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-10T13:28:12.433Z","comments":true,"path":"2022/04/30/2-SAT问题/","permalink":"https://starcried.github.io/2022/04/30/2-SAT%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题描述SAT(satisfiabality) 是适应性的缩写，一般称 k 的适应性问题为 k-SAT。适应性问题指有 $n$ 个布尔变量 ${x_i}$，加入一些限制然后求限制内的解的问题。 因为 $k&gt;2$ 的 k-SAT 问题是 NP 完全问题（没有一定的算法和正解），我们只讨论 2-SAT 问题。 Tarjan一般来讲，我们会想到把变量 $x_i$ 的两种状态（比如选和不选，记为 $x_{i0},x_{i1}$）抽象成两个点，将限制条件转化为有向边，然后通过求强联通分量求解。连边 $a\\rightarrow b$ 表示条件为满足 $a$ 必须满足 $b$。 如果有条件 $a_0\\rightarrow b_0$，$b_0\\rightarrow a_1$，$a_1\\rightarrow b_1$，$b_1\\rightarrow a_0$，我们把它想成一个图进行连边，发现 $a_0$ 和 $a_1$ 在同一个强联通分量里。也就是说要符合条件必须同时选 $a_0,a_1$，即 $a$ 变量同时选且不选，这显然是不可能的，所以本例无解。 那么我们就可以得到普遍解法，即求强联通分量：若存在一个元素的两种状态在同一个强联通分量里，此题无解；否则有解。 得到一个解的方法为：选一个未被确定的变量，可随便指定其为一个状态，将所有与之相连的变量状态确定，重复此过程直到所有变量都确定。 模版P4782洛谷模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;const int maxn=2e6+10;int n,m;int ecnt,dfn[maxn],low[maxn],head[maxn],to[maxn],nxt[maxn],cnt,_n,belong[maxn];vector&lt;int&gt; g[maxn];//inline void addedge(int from,int too)//&#123;// to[++ecnt]=too;nxt[ecnt]=head[from];head[from]=ecnt;// to[++ecnt]=from;nxt[ecnt]=head[too];head[too]=ecnt;//&#125;Wrong!stack &lt;int&gt; st;bool vis[maxn];void tarjan(int x)&#123; dfn[x]=low[x]=++cnt; st.push(x);vis[x]=1; for (int i=0;i&lt;g[x].size();i++) &#123; int u=g[x][i]; if(!dfn[u]) &#123; tarjan(u); low[x]=min(low[x],low[u]); &#125;else if(vis[u]) low[x]=min(low[x],dfn[u]); &#125; if(low[x]==dfn[x]) &#123; ++_n; do&#123; belong[x]=_n; x=st.top();st.pop(); vis[x]=0; &#125;while(dfn[x]!=low[x]); &#125;&#125;int main()&#123; n=read(),m=read(); for(int x,y,x1,y1,i=1;i&lt;=m;i++) &#123; x=read(),x1=read(),y=read(),y1=read();// addedge(x+n*(x1&amp;1),y+n*(y1^1));addedge(y+n*(y1&amp;1),x+n*(x1^1)); g[x+n*x1].push_back(y+n*(y1^1)); g[y+n*y1].push_back(x+n*(x1^1)); &#125; for(int i=1;i&lt;=(n&lt;&lt;1);i++) if(!dfn[i])tarjan(i); for(int i=1;i&lt;=n;i++) if(belong[i]==belong[i+n])&#123; printf(&quot;IMPOSSIBLE\\n&quot;); return 0; &#125; printf(&quot;POSSIBLE\\n&quot;); for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]&lt;belong[i+n]); printf(&quot;\\n&quot;); return 0;&#125; 例题洛谷P5782 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10005;int n,m;vector&lt;int&gt; g[maxn*2];bool mark[maxn*2];int sta[maxn*2],top;bool dfs(int x)&#123; if(mark[x^1])return false; if(mark[x])return true; mark[x]=1; sta[top++]=x; for(int i=0;i&lt;g[x].size();i++) if(!dfs(g[x][i]))return false; return true;&#125;inline bool TwoSAT()&#123; memset(mark,0,sizeof mark); for(int i=0;i&lt;n;i+=2)&#123; if(!mark[i] and !mark[i^1])&#123; top=0; if(!dfs(i)) &#123; while(top)mark[sta[--top]]=0; if(!dfs(i^1))return false; &#125; &#125; &#125; return true;&#125;int main()&#123; int u,v; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); n*=2; for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); u--,v--; g[u].push_back(v^1); g[v].push_back(u^1); &#125; if(TwoSAT())&#123; for(int i=0;i&lt;n;i+=2) if(mark[i])printf(&quot;%d\\n&quot;,i+1); else printf(&quot;%d\\n&quot;,(i^1)+1); &#125;else printf(&quot;NIE\\n&quot;); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"https://starcried.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"2-SAT","slug":"2-SAT","permalink":"https://starcried.github.io/tags/2-SAT/"},{"name":"Tarjan","slug":"Tarjan","permalink":"https://starcried.github.io/tags/Tarjan/"}]},{"title":"AE 制作简单动态壁纸","slug":"AE 制作简单动态壁纸","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.421Z","comments":true,"path":"2022/04/30/AE 制作简单动态壁纸/","permalink":"https://starcried.github.io/2022/04/30/AE%20%E5%88%B6%E4%BD%9C%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%A3%81%E7%BA%B8/","excerpt":"","text":"成品B站链接Wallpaper Engine 可用：搜索 Alice_StarCried 简述参考了B站的两个自学教程，都是直接搜能搜到的。PS、AE 零基础。因为需要渲染所用电脑配置有一定需求，额外用了数位板。AE 使用了现成脚本。从学习到制作完成总用时不过四天。 所需技能为 PS 基本使用，包括抠图、补图等，以及 AE 基本使用和脚本使用，都很简单。最耗时的部分实际上是 PS 部分，一开始不会用一些技巧导致进度缓慢和返工。成品依然有些瑕疵。 流程设计想清楚你需要使图片的哪些部分动起来，只要是和附近部分分开动的部位都需要扣下来作为独立的图层。 想清楚哪些部分动起来会露出背景，需要对背景空的部分进行补图。 提前设计好避免返工。 抠图使用快速选择、选择选项以及钢笔工具进行抠图。 智能选择很快，但不精细。需要用钢笔进行修补。 补图前景扣剩下会露出来的部分和画布外的部分（动起来会进入视野的部分）适当补图。使用钢笔、印章、画笔、涂抹等。PS 技巧不做讨论。 AE 导入 PSD 时会自动删除画布外部分。请提前扩大画布大小。之后可在 AE 中缩小。 设置动效随风摇曳用人偶工具和 AutoSway 插件设置随风摇曳动效。插件下载和使用方法自行搜索。 变化直接手动设置关键帧改变人物各部分的位置、旋转等属性。 眨眼动效用 Alpha（透明度）遮罩实现眼白的消失。用人偶工具实现睫毛的移动。 尽量不要直接在 AE 内使用画笔等工具修改图片，这会成为一个动作。 导出这里我出了一点问题。在导出选编译器时选择了 apple 的导致渲染出来的结果只有一帧然后全是黑屏。实际上是渲染失败了，但是 AE 并没有报错，ME 会报渲染失败但搜不到解决办法。实际默认是正确的，但是我手贱改了后没改回来还忘掉了，导致了长时间的无用查错。 剩余设置按默认、推荐值和网上教程来即可。 结论只是非常基础的动态效果。如果需要更多效果可以进行更多 PS 和 AE 的学习。总的来说难度不大，可以自学。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"AC自动机","slug":"AC自动机","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.420Z","comments":true,"path":"2022/04/30/AC自动机/","permalink":"https://starcried.github.io/2022/04/30/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"AC来自一个大佬的名字，并不是写了就可以自动AC的意思 XD AC自动机是建立在trie树上的一种优化手段。trie在每次查询一个字符串时，如果在一个子树查不到就会回溯再查，效率会很低。我们考虑在给每个节点加一个如果查不到就跳转的指针fail，那么如果找不到的话直接跳转到fail就可以了。fail代表的是拥有该点的最大后缀的点的位置。 那么怎么寻找这个fail呢？因为我们要寻找最大后缀，深度就是一个比较重要的条件。于是我们bfs。注意了，设一个点now,tmp为now的子节点（从a到z任何一个），有以下推导： （第一段使用结构体存储了点，第二段是用数组） e[tmp].fail=e[e[now].fail].nxt[i]; fail[tmp]=ch[fail[now]][i]; 首先我们知道trie是有一个0节点的。那么0连接的所有点的fail就连接的是0。如果我们接下来遍历每个点，对于任何点的fail都是其父节点的fail的子字符。因为是bfs，所以这样做一定是正确的而且一定会找到其最长后缀的点。 这里注意一下：如果now点有该字符是按照上面记录的。如果没有（ch[now][i]==0）就需要转移记录一下nxt： e[now].nxt[i]=e[e[now].fail].nxt[i]; ch[now][i]=ch[fail[now]][i]; 这样的话我们查询的时候只需要令now不断等于当前点的nxt就可以快速遍历啦~如果遍历到0，说明就end了。 让我们在打板子的时候顺便A一下洛谷的模板题： P3808 【模板】AC自动机（简单版） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e6+10; char s[maxn]; int n,fail[maxn],ch[maxn][26],vis[maxn],val[maxn]; struct ac{ int cnt=0; inline void insert(char *s) { int now=0; for(;*s;s++) { int t=*s-'a'; if(!ch[now][t])ch[now][t]=++cnt; now=ch[now][t]; } val[now]++; } inline void build() { int now=0,t,tmp; queue&lt;int&gt; q; q.push(0); while(!q.empty()) { now=q.front();q.pop(); for(int i=0;i&lt;26;i++) { t=ch[now][i]; if(t){ if(now) fail[t]=ch[fail[now]][i]; q.push(t); }else ch[now][i]=ch[fail[now]][i]; } } } inline int match(char *s) { int now,ans=0; for(now=0;*s;s++) { int t=*s-'a'; now=ch[now][t]; for(int tmp=now;tmp and !vis[tmp];tmp=fail[tmp]) ans+=val[tmp],vis[tmp]=1; } return ans; } }ac; int main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ scanf(\"%s\",s); ac.insert(s); } ac.build(); scanf(\"%s\",s); printf(\"%d\\n\",ac.match(s)); return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"AT2304 Cleaning","slug":"AT2304 Cleaning","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.421Z","comments":true,"path":"2022/04/30/AT2304 Cleaning/","permalink":"https://starcried.github.io/2022/04/30/AT2304%20Cleaning/","excerpt":"","text":"AT2304 Cleaning题意一个树上每个节点有一些石子，每次只能选取两个叶子节点并将路径间的所有点上的石子数量减1，问是否能将所有石子取完。 思路设 $f_x$ 表示从 $x$ 节点向上的路径条数，$s_x$ 为子节点的 $f$ 值的和，则有：$$a_x&#x3D;\\frac{s_x-f_x}{2}+f_x\\f_x&#x3D;2a_x-s_x$$我们只需要保证以下条件即可： 从子节点传上来的路径条数的最大值小于等于该点石头个数； 向上传的路径条数不为负且小于等于该点石头数。 也就是说，在合法条件下，我们令能在子树内匹配的路径数尽量多，然后向上传路径。 可以证明，在满足上面两个条件下，总能构造出一种合法方案使这个点合法。 其他条件： 子叶节点的 $f_x&#x3D;a_x$； 根节点不能为子节点； 若根节点的 $f$ 值不为0，判定为无解。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int n,a[maxn],root; int ecnt,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],in[maxn],f[maxn]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;in[a]++; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt;in[b]++; &#125; void dfs(int x,int fa)&#123; f[x]=in[x]==1?a[x]:(a[x]&lt;&lt;1); for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==fa)continue; dfs(u,x); f[x]-=f[u]; if(f[u]&gt;a[x]) puts(&quot;NO&quot;),exit(0); &#125; if(f[x]&gt;a[x] or f[x]&lt;0) puts(&quot;NO&quot;),exit(0); &#125; inline void work()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;n;i++) addedge(read(),read()); if(n==2) return puts(a[1]==a[2]?&quot;YES&quot;:&quot;NO&quot;),void(); for(int i=1;i&lt;=n;i++) if(in[i]!=1)&#123;root=i;break;&#125; dfs(root,0); puts(f[root]?&quot;NO&quot;:&quot;YES&quot;); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"AT2390 Games on DAG","slug":"AT2390 Games on DAG","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.422Z","comments":true,"path":"2022/04/30/AT2390 Games on DAG/","permalink":"https://starcried.github.io/2022/04/30/AT2390%20Games%20on%20DAG/","excerpt":"","text":"AT2390 Games on DAG题意$1,2$ 号点各一个石头，每次沿边移动一个石头，不能动者输。求所有连边子集中先手胜的情况。 思路发现对于两个石头的 SG 函数是独立的，输者两个石头 SG 函数异或值为 0，那么先手胜的情况就是所有情况减去这种情况。 对于所有 SG 函数为 $v$ 的点，它们必须向 SG 函数小于 $v$ 的所有点连至少一条边，对大于 $v$ 的连边没有约束，并且互相不能连边。 所以我们可以枚举当前图的 SG 函数为 0 的点，这样所有其他点都至少向它们连一条边，而它们之间不连边，它们向其他点连边任意。于是对于剩下点的连通子图，我们又可以将所有点的 SG 函数减 1，使它又可以枚举 SG 函数为 0 的点。 于是我们可以 DP。设 $f_S(1,2\\in S)$ 为对于 $S$ 所有连通子图满足 1,2 SG 函数相等的方案数。 转移时枚举 $S$ 的子集 $T$，使 $1,2\\in T$ 或 $1,2\\not \\in T$。对于前者情况，$T$ 对于 $S$ 的补集为 SG 函数为 0 的点，从 $f_T$ 转移即可。对于后者情况，1,2 SG 函数为 0，$T$ 中的边随便连。 DP 前预处理出所有集合对每个点的连边条数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=15,mod=1e9+7; int n,m,a[maxn][maxn],f[1&lt;&lt;maxn],c[1&lt;&lt;maxn][maxn],pow[maxn*maxn]; inline void work()&#123; n=read(),m=read(); pow[0]=1;for(int i=1;i&lt;=m;i++) pow[i]=(pow[i-1]&lt;&lt;1)%mod; for(int x,y,i=1;i&lt;=m;i++) x=read()-1,y=read()-1,a[x][y]=1; for(int d=1;d&lt;1&lt;&lt;n;d++)&#123; int j=0; while(~d&gt;&gt;j&amp;1)++j; for(int x=0;x&lt;n;x++) c[d][x]=c[d^1&lt;&lt;j][x]+a[x][j]; &#125; for(int d=0;d&lt;1&lt;&lt;n;d++) if((d&amp;3)==3)&#123; f[d]=1; for(int t=d&amp;(d-1);t;--t&amp;=d) if((t&amp;1)==(t&gt;&gt;1&amp;1)) if(t&amp;1)&#123; int res=1; for(int i=0;i&lt;n;i++) if(t&gt;&gt;i&amp;1) res=1ll*res*(pow[c[d^t][i]]-1)%mod; else if(d&gt;&gt;i&amp;1) res=1ll*res*pow[c[t][i]]%mod; f[d]=(f[d]+1ll*res*f[t])%mod; &#125;else&#123; int res=1; for(int i=0;i&lt;n;i++) if(t&gt;&gt;i&amp;1) res=1ll*res*(pow[c[d^t][i]]-1)%mod*pow[c[t][i]]%mod; else if(d&gt;&gt;i&amp;1) res=1ll*res*pow[c[t][i]]%mod; f[d]=(f[d]+res)%mod; &#125; &#125; printf(&quot;%d\\n&quot;,(pow[m]-f[(1&lt;&lt;n)-1]+mod)%mod); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CDQ分治[非公开][草稿]","slug":"CDQ分治[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.424Z","comments":true,"path":"2022/04/30/CDQ分治[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/CDQ%E5%88%86%E6%B2%BB[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"CDQ是陈丹琦的意思（又是一个大佬） CDQ分治是离线算法。 主要思想是将一个区间分成两个区间[l,mid]和(mid,r]，然后 处理左区间 处理左区间对右区间的影响 处理右区间 就是用一个子问题来计算对另一个子问题的贡献。 三位偏序问题 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF175E Power Defence","slug":"CF175E Power Defence","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.426Z","comments":true,"path":"2022/04/30/CF175E Power Defence/","permalink":"https://starcried.github.io/2022/04/30/CF175E%20Power%20Defence/","excerpt":"","text":"CF175E Power Defence题意一个塔防游戏：给定一个无限长的数轴，一个无限血的敌人要从正无穷走到负无穷。你的任务是放置三种塔，包含两种攻击塔和一种寒冰塔，使得敌人受到的伤害最大。 其中，每种塔的攻击半径可能不同，每种攻击塔的攻击力也可能不同。而寒冰塔没有攻击力，它的作用是使范围内敌人的速度减速，即一段区间若有$k$个寒冰塔覆盖，敌人速度变为$\\frac{1}{k+1}$。 敌人初始速度为1格每秒，攻击塔的伤害值也是以秒计算的。 思路首先有几个基本结论： 若没有寒冰塔，整场游戏答案固定。 若有寒冰塔，让所有塔挤在一起必不会更劣。这里对挤在一起的定义是：所有塔至少有一端上下对齐，且左右两端距离最大不超过$\\lceil \\frac{n}{2}\\rceil$。 寒冰塔的能力实际上是将范围内基础伤害增加一倍。注意这里的伤害是忽略其他寒冰塔效果的。 发现序列长度很短，排列的方式也很有限，于是我们就有了一个大胆的想法：模拟退火。 然后便是裸的模拟退火算法：随机出来两个位置进行交换，统计答案，若答案大于当前答案，接受之；否则以当前温度的概率接受之。参数调整得好的话多做几次便可。 然后是统计答案。我有一个$n^2$的想法：扫描序列，每扫到一个寒冰塔就再次扫描整个序列的攻击塔，计算出两个塔间相交的范围乘上该塔攻击力加入答案即可，当然最后别忘了加上不计算寒冰塔的基础伤害。正确性也显然，因为显然寒冰塔的贡献是可以对于每个其他攻击塔单独计算的。 具体实现我耍了个小聪明：将所有炮塔放进一个数组中，这样交换的时候就不用分上下位置了。统计答案的时候计算出该塔的实际位置就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#define T 10000#define eps 0.99#define kb 1.38e-23#define endt 1e-12#define INF 1e19using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=45; int n1,n2,n3,d1,d2,n,a[maxn],m; double r1,r2,r3,res,ans; inline double getsum()&#123; double sum=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i]!=3)continue; int x=i; if(x&gt;m)x-=m; double L3=x-r3,R3=x+r3; for(int j=1;j&lt;=n;j++)&#123; if(a[j]==3)continue; int y=j,t=a[j]; if(y&gt;m)y-=m; if(t==1)&#123; double L1=y-r1,R1=y+r1; sum+=max(0.0,d1*(min(R1,R3)-max(L1,L3))); &#125;else if(t==2)&#123; double L2=y-r2,R2=y+r2; sum+=max(0.0,d2*(min(R2,R3)-max(L2,L3))); &#125; &#125; &#125; return res+sum; &#125; inline void solve() &#123; double t=T; double ans=0; while(t&gt;endt) &#123; int xx=rand()%n+1,yy=rand()%n+1; while(a[xx]==a[yy])xx=rand()%n+1,yy=rand()%n+1; swap(a[xx],a[yy]); double zp=getsum(); if(zp&gt;ans)&#123; ans=zp; star::ans=max(star::ans,ans); &#125;else if(rand()&lt;exp((ans-zp)/t/kb) * RAND_MAX)swap(a[xx],a[yy]); else ans=zp; t*=eps; &#125; &#125; inline void work()&#123; n1=read(),n2=read(),n3=read(); r1=read(); r1=sqrt(r1*r1-1); r2=read(); r2=sqrt(r2*r2-1); r3=read(); r3=sqrt(r3*r3-1); d1=read(),d2=read(); res=2*n1*r1*d1+2*n2*r2*d2; if(n3==0)return (void)printf(&quot;%.10lf&quot;,res); n=n1+n2+n3; for(int i=1;i&lt;=n;i++) if(n1) a[i]=1,n1--; else if(n2) a[i]=2,n2--; else if(n3) a[i]=3,n3--; m=n/2+1; n=m*2; random_shuffle(a+1,a+1+n); srand(time(0));// while((double)clock()/CLOCKS_PER_SEC&lt;2.7) for(int i=1;i&lt;=100;i++) solve(); printf(&quot;%.10lf\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 总结这题正解是DP，爆搜也能过。 codeforces的题目，如果我现场写模拟退火的话一定当场去世。毕竟我因为一些奇怪的原因交了好多回。 所以骗骗分还是可以的 by ysr UPD:2020.12.29 发现这个好像是个爬山","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF1166E The LCMs Must be Large","slug":"CF1166E The LCMs Must be Large","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.425Z","comments":true,"path":"2022/04/30/CF1166E The LCMs Must be Large/","permalink":"https://starcried.github.io/2022/04/30/CF1166E%20The%20LCMs%20Must%20be%20Large/","excerpt":"","text":"CF1166E The LCMs Must be Large思维好题，结论好题。 题意一个长度为 $n$ 的未知长度的序列，有 $m$ 个限制，每个限制形如给定一个集合 $S$ ，使集合内元素的 $lcm$ 严格大于其补集元素的 $lcm$ 。问是否存在这一序列。 思路要注意我们是要尽可能使序列有解。 先给出结论：若所有集合两两间有交，则有解。否则一定无解。 首先有一个结论：若 $A\\subseteq B$，那么 $lcmB \\geq lcmA$ 。 因为考虑 $B$ 比 $A$ 多的元素，只可能增加贡献而不可能减少贡献，所以上述结论显然。 然后我们回到题目：若一个限制的集合 $A$ 与另一个限制的集合 $B$ 不交，假设 $lcmA&gt;lcmA\\setminus S$ ($S$表示整个序列集合)，那么一定有 $B\\subseteq A\\setminus S$,即有 $lcmA\\setminus S\\geq lcm B$ 。显然不符合要求。 然后证明结论的充分性。这里我们考虑一个构造的方法：假设所有元素初始都为1，我们将每个给定的集合内的元素都乘上一个互不相同的质数，那么如果集合两两相交，每个集合的$lcm$就是整个序列的$lcm$，并且每个集合的补集因为没有乘该集合的质数所以$lcm$一定小。如果有两个集合不相交，因为两个集合的质数不同，所以一定会出现一个集合的$lcm$大于另一个集合的情况，一定无解。 实现12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e4+10; int m; bitset&lt;maxn&gt; a[55],now; inline void work()&#123; m=read();read(); for (int x,i=1;i&lt;=m;i++) &#123; x=read(); while(x--) a[i].set(read()); for (int j=1;j&lt;i;j++) &#123; if ((a[i] &amp; a[j]).none()) return (void)puts(&quot;impossible&quot;); &#125; &#125; puts(&quot;possible&quot;); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF1032G Chattering","slug":"CF1032G Chattering","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.424Z","comments":true,"path":"2022/04/30/CF1032G Chattering/","permalink":"https://starcried.github.io/2022/04/30/CF1032G%20Chattering/","excerpt":"","text":"CF1032G Chattering 题意 思路 对于每一个位置，它转移的范围是确定的。 对于一段可以走到的区间，我们可以求出区间中所有点再能走到区间范围。 于是这个就可以倍增进行转移。 如何快速求出一段区间能走到的区间范围？也就是分别求出一段区间向左跳的位置的最小值和向右跳位置的最大值，发现这其实就是一个RMQ问题。但是因为还有倍增的时间复杂度，而且是没有修改的，那么我们可以利用ST表做到 查询。 于是时间复杂度就变成了 的。 这个转移的思想和ATcoder的一道题比较像。 实现 题目是一个环，所以我们需要将序列延长成三倍，然后在中间段查询。 倍增时，若倍增到的左右端点距离已经超过 说明使完全覆盖，不优。 最后需要将答案加一，因为第一次的时间并未算上。当 为 1 时，不需要传播，答案为 0。 代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cctype&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#39;-&#39;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; &#125; namespace star &#123; const int maxn=3e5+10; int n,a[maxn]; int log[maxn]; int l[20][maxn],r[20][maxn]; struct RMQ&#123; int st[maxn][20],val[maxn]; int op; inline int MAX(int x,int y)&#123; return val[x]&gt;val[y]?x:y; &#125; inline void build(int *b,int n,int _op)&#123; op=_op; for(int i=1;i&lt;=n;i++) st[i][0]=i,val[i]=op*b[i]; for(int j=1;j&lt;=log[n];j++) for(int i=1;i&lt;=n;i++) st[i][j]=MAX(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]); &#125; inline int query(int l,int r)&#123; int k=log[r-l+1]; return MAX(st[l][k],st[r-(1&lt;&lt;k)+1][k]); &#125; &#125;L,R; inline void work()&#123; n=read(); if(n==1)return (void)puts(&quot;0&quot;); for(int i=2;i&lt;=3*n;i++) log[i]=log[i&gt;&gt;1]+1; for(int i=1;i&lt;=n;i++) a[i]=a[i+n]=a[i+n+n]=read(); for(int i=0;i&lt;=log[3*n];i++) l[i][1]=1,r[i][n*3]=3*n; for(int i=1;i&lt;=3*n;i++) l[0][i]=max(1,i-a[i]),r[0][i]=min(n*3,i+a[i]); L.build(l[0],3*n,-1),R.build(r[0],3*n,1); for(int l1,r1,j=1;j&lt;=log[3*n];j++) for(int i=1;i&lt;=3*n;i++)&#123; l1=L.query(l[j-1][i],r[j-1][i]); r1=R.query(l[j-1][i],r[j-1][i]); l[j][i]=min(l[j-1][l1],l[j-1][r1]); r[j][i]=max(r[j-1][l1],r[j-1][r1]); &#125; for(int i=n+1;i&lt;=n&lt;&lt;1;i++)&#123; int u=i,v=i,ans=0; for(int j=log[n*3];~j;j--) if(max(r[j][u],r[j][v])-min(l[j][u],l[j][v])+1&lt;n)&#123; int su=L.query(l[j][u],r[j][v]),sv=R.query(l[j][u],r[j][v]); u=su,v=sv; ans+=(1&lt;&lt;j); &#125; printf(&quot;%d &quot;,ans+1); &#125; &#125; &#125; signed main()&#123; star::work(); return 0; &#125; &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF437D The Child and Zoo","slug":"CF437D The Child and Zoo","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.427Z","comments":true,"path":"2022/04/30/CF437D The Child and Zoo/","permalink":"https://starcried.github.io/2022/04/30/CF437D%20The%20Child%20and%20Zoo/","excerpt":"","text":"CF437D The Child and Zoo题意给定一个无向图，求所有点对间所有简单路径上最小点权的最大值的平均值。 思路 首先，我们可以将点权转移到边权上，边权为两端点点权的较小值。正确性显然。 然后，对于任意两个点之间的贡献，只有路径上含最大点权的简单路径有贡献，于是就可以把无向图转变为最大生成树。任意两个点间的贡献显然是在最大生成树上路径的最大边权。 考虑对于一条边的贡献，其实就是对于当前两端点连通块的大小相乘再乘该边边权。计算后合并两个连通块。 完了，一个最大生成树即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int n,m,siz[maxn],fa[maxn],a[maxn]; double ans; struct edge&#123; int u,v,d; inline bool operator &lt; (const edge &amp;zp) const&#123;return d&gt;zp.d;&#125; &#125;e[maxn]; inline void onion(int x,int y,int k)&#123; if(siz[x]&lt;siz[y])swap(x,y); ans+=1.0*siz[x]*siz[y]*k; fa[y]=x,siz[x]+=siz[y]; &#125; int find(int x)&#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125; inline void work()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),fa[i]=i,siz[i]=1; for(int u,v,i=1;i&lt;=m;i++) u=read(),v=read(),e[i]=(edge)&#123;u,v,min(a[u],a[v])&#125;; sort(e+1,e+1+m); for(int cnt=0,i=1;i&lt;=m and cnt&lt;=n-1;i++)&#123; int u=find(e[i].u),v=find(e[i].v); if(u!=v) onion(u,v,e[i].d),cnt++; &#125; printf(&quot;%.5lf\\n&quot;,ans/n/(n-1)*2); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF459E-DP","slug":"CF459E-DP","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.427Z","comments":true,"path":"2022/04/30/CF459E-DP/","permalink":"https://starcried.github.io/2022/04/30/CF459E-DP/","excerpt":"","text":"CF459E-DP核心代码15行 思路观察数据范围，我们建m层分层图跑最短路想到DP。 DP最大的特点就是无后效性。那么我们这一题哪个条件无后效性呢？ 发现DP值一定从边权小于当前点的位置转移而来。 这不就无后效性了？我们按边权将所有边排序即可。 然后，枚举边，将DP值记录到点上，每次用起始点的dp值加1更新到达点的dp值。最后输出dp值最大的即可。 然后，您会发现第一个样例过不去。 因为题目要求边权严格递增，所以我们需要同时将边权相同的边用上次的dp值更新，即我们需要临时记录一下。 样例非常良心。 实现12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=3e5+10; int n,m,f[maxn],g[maxn]; struct edge&#123; int u,v,val; inline bool operator &lt; (const edge &amp;zp)const&#123;return val&lt;zp.val;&#125; &#125;e[maxn]; inline void work()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++)e[i].u=read(),e[i].v=read(),e[i].val=read(); sort(e+1,e+1+m); for(int i=1,j;i&lt;=m;i=j+1)&#123; j=i; while(e[j+1].val==e[i].val)j++; for(int k=i;k&lt;=j;k++) g[e[k].u]=f[e[k].u],g[e[k].v]=f[e[k].v];//只有这些dp值要用 for(int k=i;k&lt;=j;k++) f[e[k].v]=max(f[e[k].v],g[e[k].u]+1); &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans=max(ans,f[i]); printf(&quot;%d&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; postscripts目前rank1，可能只是因为写的人少。 是一道不错的DP练手题。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF487E Tourists","slug":"CF487E Tourists","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.428Z","comments":true,"path":"2022/04/30/CF487E Tourists/","permalink":"https://starcried.github.io/2022/04/30/CF487E%20Tourists/","excerpt":"","text":"CF487E Tourists前排膜拜T神 上面的话和这道题一点关系都没有 题意给一个点带权的无向图，每次询问查询两点间所有简单路径上最小值的最小值，单点修改。 思路 一眼圆方树。 ​ ——@gxy001 这种题只有在树上做才比较好处理这么多次询问。考虑广义圆方树，缩完点双连通分量后建立的方点和圆点。 因为我们找的是最小值，所以必须将代表整个点双的方点的权值设为与其相连的所有圆点的权值的最小值。用一个 multiset 或者一个可删堆（或者堆带懒惰删除）维护即可。 这样我们就可以在树上使用树剖进行查询了。 但是这题带修改。也就是说，按照上面的方法，更改一个圆点就必须遍历与其相连的所有方点进行修改。这样会被菊花图卡死。于是我们用一个经典套路：方点只维护其儿子的权值。这样我们查询时方法相同，只不过如果求出的 LCA 为方点的话需要再考虑一下其父亲节点的贡献。 由于我们需要区间查询加修改，我们可以将圆方树树剖并用线段树维护最小值。 代码如果您追求更快速的代码体验，建议使用手写堆+惰性删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;set&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=2e5+10,INF=0x3f3f3f3f; int n,m,Q,a[maxn],cnt; struct gragh&#123; int ecnt,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt; &#125; &#125;G1,G2; int st[maxn],dfn[maxn],tot,id[maxn]; struct SegmentTree&#123; #define ls (ro&lt;&lt;1) #define rs (ro&lt;&lt;1|1) #define mid ((l+r)&gt;&gt;1) int mn[maxn&lt;&lt;2]; inline void pushup(const int &amp;ro)&#123; mn[ro]=min(mn[ls],mn[rs]); &#125; void build(const int&amp; ro=1,const int &amp;l=1,const int &amp;r=cnt)&#123; if(l==r) return mn[ro]=a[id[l]],void(); build(ls,l,mid);build(rs,mid+1,r); pushup(ro); &#125; void update(const int &amp;x,const int &amp;ro=1,const int &amp;l=1,const int &amp;r=cnt)&#123; if(l==r) return mn[ro]=a[id[l]],void(); if(x&lt;=mid) update(x,ls,l,mid); else update(x,rs,mid+1,r); pushup(ro); &#125; int query(const int &amp;x,const int &amp;y,const int &amp;ro=1,const int &amp;l=1,const int &amp;r=cnt)&#123; if(x==l and y==r) return mn[ro]; if(y&lt;=mid) return query(x,y,ls,l,mid); else if(x&gt;mid) return query(x,y,rs,mid+1,r); else return min(query(x,mid,ls,l,mid),query(mid+1,y,rs,mid+1,r)); &#125; #undef ls #undef rs #undef mid &#125;T; void tarjan(int x)&#123; dfn[x]=id[x]=++tot; st[++st[0]]=x; for(int i=G1.head[x];i;i=G1.nxt[i])&#123; int u=G1.to[i]; if(!dfn[u])&#123; tarjan(u); id[x]=min(id[x],id[u]); if(id[u]&gt;=dfn[x])&#123; cnt++; int now=-1; G2.addedge(x,cnt); while(now^u) now=st[st[0]--],G2.addedge(now,cnt); &#125; &#125;else id[x]=min(id[x],dfn[u]); &#125; &#125; int dep[maxn],siz[maxn],fa[maxn],son[maxn],top[maxn]; multiset&lt;int&gt; q[maxn]; void dfs1(int x,int f)&#123; fa[x]=f,dep[x]=dep[f]+1,siz[x]=1; for(int i=G2.head[x];i;i=G2.nxt[i])&#123; int u=G2.to[i]; if(u==f)continue; dfs1(u,x); if(x&gt;n) q[x-n].insert(a[u]); siz[x]+=siz[u]; if(siz[u]&gt;siz[son[x]])son[x]=u; &#125; if(x&gt;n) a[x]=*q[x-n].begin(); &#125; void dfs2(int x,int topf)&#123; top[x]=topf,dfn[x]=++tot,id[tot]=x; if(!son[x])return; dfs2(son[x],topf); for(int i=G2.head[x];i;i=G2.nxt[i])&#123; int u=G2.to[i]; if(u==fa[x] or u==son[x])continue; dfs2(u,u); &#125; &#125; inline int LCA(int x,int y)&#123; int ans=INF; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ans=min(ans,T.query(dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])swap(x,y); ans=min(ans,T.query(dfn[y],dfn[x])); if(y&gt;n) ans=min(ans,a[fa[y]]); return ans; &#125; inline bool gc()&#123; char c=getchar(); while(!isalpha(c))c=getchar(); return c==&#x27;C&#x27;; &#125; inline void work()&#123; n=cnt=read(),m=read(),Q=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=m;i++) G1.addedge(read(),read()); tarjan(1); tot=0; dfs1(1,0); dfs2(1,1); T.build(); while(Q--) if(gc())&#123; int x=read(),w=read(),u=fa[x]; if(u) q[u-n].erase(q[u-n].find(a[x])), q[u-n].insert(w), a[u]=*q[u-n].begin(), T.update(dfn[u]); a[x]=w; T.update(dfn[x]); &#125;else printf(&quot;%d\\n&quot;,LCA(read(),read())); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF404D-DP【成就达成】","slug":"CF404D-DP【成就达成】","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.426Z","comments":true,"path":"2022/04/30/CF404D-DP【成就达成】/","permalink":"https://starcried.github.io/2022/04/30/CF404D-DP%E3%80%90%E6%88%90%E5%B0%B1%E8%BE%BE%E6%88%90%E3%80%91/","excerpt":"","text":"CF404D-DP正经的东西 题意给定一个字符串，只包含’0’,’1’,’2’,’*’,’?’五种字符，其中’?’可被替换为其他任何一种，求使序列符合扫雷地图定义的方案数。 一个数字字符大小表示与之临近的位置总共有多少个雷。 思路DP。 和其他题解不太相同，我们每个点只记录三种状态：0,1,2，分别表示此点的下一位不为雷、为雷，和本身就是雷的此位以前的方案数。 注意，这些状态除了最后一个，与该点本身为何没有关系。 考虑每一个点分别为何的情况下从上一个位置的什么状态转移： 为0：继承0. 1f[i][0]+=f[i-1][0] 为1：自身0的状态继承上一个为雷的状态，为1的继承为0的。 12f[i][0]+=f[i-1][2]f[i][1]++f[i-1][0] 为2：只能将自身为1的状态继承上一个为雷的状态。 1f[i][1]+=f[i-1][2] 为雷：继承上一个为1、为雷的状态。 1f[i][2]+=f[i-1][2]+f[i-1][1] 为？：将上述所有状态全部转移。 123f[i][0]+=f[i-1][0]+f[i-1][2]f[i][1]+=f[i-1][0]+f[i-1][2]f[i][2]+=f[i-1][1]+f[i-1][2] 至于上面转移的原因显然，即每个点后面的点能继承当前点的哪个状态。 注意：初始化f[0][0]=f[0][1]=1，后者是为了计算第一位为雷的情况。此外，所有该点未被转移的状态都为0。 于是我们线性DP求解即可。 不正经的东西 首先，显然上面的第一维可以滚动数组优化。 然后，我们可以边输入边计算，就不用数组存东西啦。这样我们将空间复杂度优化到了$O(1)$ 最后，你就会发现吾的做法即好想又好写又省时间又省空间 达成成就：内存使用小于代码大小 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;using namespace std;const int mod=1e9+7;int f[2][3];int x,i;char c;inline void qm(int &amp;a,const int&amp; b)&#123;(a+=b)&gt;=mod?(a-=mod):a;&#125;int main()&#123; c=getchar(); while(c&lt;=32)c=getchar(); f[0][0]=f[0][1]=1; for(x=1;c&gt;32;x++,c=getchar())&#123; i=x&amp;1; f[i][0]=f[i][1]=f[i][2]=0; switch(c)&#123; case &#x27;0&#x27;:&#123; qm(f[i][0],f[i^1][0]); break; &#125; case &#x27;1&#x27;:&#123; qm(f[i][1],f[i^1][0]); qm(f[i][0],f[i^1][2]); break; &#125; case &#x27;2&#x27;:&#123; qm(f[i][1],f[i^1][2]); break; &#125; case &#x27;*&#x27;:&#123; qm(f[i][2],f[i^1][1]+f[i^1][2]); break; &#125; case &#x27;?&#x27;:&#123; qm(f[i][0],f[i^1][0]); qm(f[i][0],f[i^1][2]); qm(f[i][1],f[i^1][0]); qm(f[i][1],f[i^1][2]); qm(f[i][2],f[i^1][1]); qm(f[i][2],f[i^1][2]); break; &#125; &#125; &#125; x--; printf(&quot;%d&quot;,(f[x&amp;1][0]+f[x&amp;1][2])%mod); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF710F String Set Queries","slug":"CF710F String Set Queries","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.429Z","comments":true,"path":"2022/04/30/CF710F String Set Queries/","permalink":"https://starcried.github.io/2022/04/30/CF710F%20String%20Set%20Queries/","excerpt":"","text":"CF710F String Set Queries题意动态支持加入删除字符串和字符串匹配 思路动态 AC自动机 先不考虑动态情况。对于加入一个字符串，直接插入到自动机即可。 考虑删除。发现对于答案具有可减性，意思是对于同一个匹配串，答案可以表示为在自动机中匹配的答案减去删去的所有串匹配的答案。那我们考虑给所有删除的串也开一个 AC 自动机，每次询问在两个自动机中匹配将答案相减即可。 现在考虑动态情况。因为强制在线，且 AC 自动机是离线的，我们每插入一个字符串相当于重新建了一个自动机，每次在所有自动机中匹配结果的和即为答案。减少时间消耗的唯一途径是对 AC 自动机进行合并。 考虑如何合并时间复杂度有保证且优秀。有很多办法，比如根号重构、二进制分组等。后者比较优秀也比较好写。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;namespace star&#123; const int maxn=3e5+10; struct ACmation&#123; int tot,son[maxn][26],val[maxn],fail[maxn],st[maxn],N,n,siz[maxn],beg[maxn]; string S[maxn]; inline void ins(string s,int ro)&#123; int x=ro; for(auto t:s)&#123; t-=&#x27;a&#x27;; if(son[x][t]==ro)&#123; son[x][t]=++tot; for(int j=0;j&lt;26;j++) son[tot][j]=ro; &#125; x=son[x][t]; &#125; val[x]++; &#125; inline void build(int ro)&#123; fail[ro]=ro; static int q[maxn]; int hd=0,tl=1; q[tl]=ro; while(hd&lt;tl)&#123; int x=q[++hd]; for(int t=0;t&lt;26;t++)&#123; int u=son[x][t]; if(u!=ro)&#123; fail[u]=x==ro?x:son[fail[x]][t]; if(son[fail[x]][t]!=u) val[u]+=val[son[fail[x]][t]]; q[++tl]=u; &#125;else son[x][t]=son[fail[x]][t]; &#125; &#125; &#125; inline int query(string s,int x)&#123; int ans=0; for(auto t:s) x=son[x][t-&#x27;a&#x27;],ans+=val[x]; return ans; &#125; inline void merge()&#123; siz[--N]&lt;&lt;=1; for(int i=st[N];i&lt;=tot;i++)&#123; val[i]=fail[i]=0; for(int j=0;j&lt;26;j++) son[i][j]=0; &#125; tot=st[N]; for(int i=0;i&lt;26;i++) son[tot][i]=tot; for(int i=beg[N];i&lt;=n;i++) ins(S[i],st[N]); build(st[N]); &#125; inline void insert(string s)&#123; st[++N]=++tot; for(int i=0;i&lt;26;i++) son[tot][i]=tot; siz[N]=1; ins(s,tot),build(st[N]); S[beg[N]=++n]=s; while(siz[N]==siz[N-1]) merge(); &#125; inline int query(string s)&#123; int ans=0; for(int i=1;i&lt;=N;i++) ans+=query(s,st[i]); return ans; &#125; &#125;a,b; inline void work()&#123; int m;cin&gt;&gt;m; while(m--)&#123; int op;string s; cin&gt;&gt;op&gt;&gt;s; switch(op)&#123; case 1:a.insert(s);break; case 2:b.insert(s);break; case 3:cout&lt;&lt;a.query(s)-b.query(s)&lt;&lt;endl;break; &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF494D Birthday","slug":"CF494D Birthday","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.428Z","comments":true,"path":"2022/04/30/CF494D Birthday/","permalink":"https://starcried.github.io/2022/04/30/CF494D%20Birthday/","excerpt":"","text":"CF494D Birthday题意一个1为根的带边权有根树，每次询问给定两个点 $u,v$ 求 $\\sum_{x\\in S(v)} d(u,x)^2-\\sum_{x\\not\\in S(v)}d(u,x)^2$ 其中 $d(u,v)$ 表示 $u,v$ 简单路径长度， $S(u)$ 表示 $u$ 的子树内点的集合。 思路考虑 $u$ 在 $v$ 内和在 $v$ 外的情况，发现可以通过每个点维护四个值——子树内所有点到其距离的和、子树内所有点到其距离的平方的和、所有点到其的距离和、所有点到其距离的平方和——来回答询问。 具体转移细节请自推，这里总结一个重点： 设 $v$ 与 $u$ 两点，$f2[v]$ 为 $v$ 子树内距离平方的和，$f[v]$ 为 $v$ 子树内距离的和，$siz[v]$ 为 $v$ 子树大小，$w$ 为两点间距离，则 $v$ 子树内所有点到 $u$ 的距离的平方和为$$f2[v]+2*f[v]*w+siz[v]*w^2$$深度优先搜索两边换根处理出以上信息后分类讨论即可。 代码请注意取模。 代码中的一些取模可以被优化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10,mod=1e9+7; int n; int ecnt,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],v[maxn&lt;&lt;1]; inline void addedge(int a,int b,int c)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt,v[ecnt]=c; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt,v[ecnt]=c; &#125; inline int up(int a)&#123;return a&gt;=mod?a-mod:a;&#125; inline int dn(int a)&#123;return a&lt;0?a+mod:a;&#125; int f[maxn],f2[maxn],g[maxn],g2[maxn],dep[maxn],fa[maxn][21],dis[maxn],siz[maxn]; void dfs(int x,int father)&#123; fa[x][0]=father;siz[x]=1; dep[x]=dep[father]+1; for(int i=0;i&lt;20;i++) fa[x][i+1]=fa[fa[x][i]][i]; for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==father)continue; dis[u]=dis[x]+v[i]; dfs(u,x); siz[x]+=siz[u]; f[x]=up(f[x]+up(f[u]+siz[u]*v[i]%mod))%mod; f2[x]=((f2[x]+f2[u])%mod+(siz[u]*v[i]%mod*v[i]%mod+2*v[i]*f[u]%mod)%mod)%mod; &#125; &#125; void dfs2(int x)&#123; for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==fa[x][0])continue; g[u]=(g[x]+(n-2*siz[u]+mod)%mod*v[i]%mod)%mod; g2[u]=((f2[u]+(g2[x]-((f2[u]+2*v[i]%mod*f[u]%mod)%mod+siz[u]*v[i]%mod*v[i]%mod)%mod+mod)%mod)%mod+((g[x]-f[u]+mod-siz[u]*v[i]%mod+mod)%mod*2%mod*v[i]%mod+(n-siz[u])*v[i]%mod*v[i]%mod)%mod)%mod; dfs2(u); &#125; &#125; inline int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); for(int i=20;~i;i--) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=20;~i;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125; inline void work()&#123; n=read(); for(int u,v,i=1;i&lt;n;i++) u=read(),v=read(),addedge(u,v,read()); dfs(1,0); g[1]=f[1],g2[1]=f2[1]; dfs2(1); int Q=read(); while(Q--)&#123; int y=read(),x=read(),lca=LCA(x,y),d=dis[x]+dis[y]-dis[lca]*2; d%=mod; if(lca==x)&#123; printf(&quot;%lld\\n&quot;,(g2[y]-2*((((g2[x]-f2[x]+mod)%mod+2*d%mod*(g[x]-f[x]+mod)%mod)%mod+d*d%mod*(n-siz[x])%mod)%mod+mod)%mod+mod)%mod); &#125;else&#123; printf(&quot;%lld\\n&quot;,((((f2[x]%mod+2%mod*d%mod*f[x]%mod)%mod+d%mod*d%mod*siz[x]%mod)%mod*2%mod-g2[y]%mod)%mod+mod)%mod); &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF833B-线段树优化DP","slug":"CF833B-线段树优化DP","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.429Z","comments":true,"path":"2022/04/30/CF833B-线段树优化DP/","permalink":"https://starcried.github.io/2022/04/30/CF833B-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96DP/","excerpt":"","text":"CF833B-线段树优化DP题意将一个长为$n$的序列分成$k$段，每段贡献为其中不同数字的个数，求最大贡献和。 思路此处感谢@gxy001 聚铑的精彩讲解 先考虑暴力DP，可以想到一个时空复杂度$O(n^2k)$的方法，即记录前i个数字分成了j段。我们现在来思考几个问题来优化这个操作： 对于一个数字，它对那些地方实际有贡献？ 每次分割出一个区间段对后续操作有影响的位置在哪？ 每次转移都从哪些地方继承？ 下来一一解答这些问题。 对于一个数字，它能产生贡献的区间其实就是该数字上一次出现的位置的后一位到它本身的位置。 对于每次划分，它以前的位置的贡献已经被考虑，所以我们只能考虑后面的位置。 相应的，每次转移会继承前面所有DP值的最大值。 那么我们可以将k提出来，每次循环继承上一次所有的dp值。因为只考虑从前面转移dp值，所以不会对之前的决策产生影响，所以是正确的。 看看1、3问题的答案，是不是想到了RMQ和区间赋值？ 于是我们可以通过线段树来实现DP优化。 具体来讲，迭代k次，每次线段树更新为上一次序列的dp值，然后从前往后扫，每个数会对其上述区间产生1的贡献，转移继承前面所有dp值的最大值即可。 时间复杂度将一维优化为log。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=35005; int n,k,cur[maxn],pre[maxn],f[maxn][60]; struct SegmentTree&#123; #define ls (ro&lt;&lt;1) #define rs (ro&lt;&lt;1|1) struct tree&#123; int l,r,tag,v; &#125;e[maxn&lt;&lt;2]; inline void pushup(int ro)&#123; e[ro].v=max(e[ls].v,e[rs].v); &#125; inline void pushdown(int ro)&#123; e[ls].tag+=e[ro].tag;e[rs].tag+=e[ro].tag; e[ls].v+=e[ro].tag;e[rs].v+=e[ro].tag; e[ro].tag=0; &#125; void build(int ro,int l,int r)&#123; e[ro].l=l,e[ro].r=r; if(l==r)return; int mid=l+r&gt;&gt;1; build(ls,l,mid); build(rs,mid+1,r); &#125; void rebuild(int tim,int ro)&#123; int l=e[ro].l,r=e[ro].r; e[ro].tag=0; if(l==r)&#123; e[ro].v=f[l][tim];return; &#125; rebuild(tim,ls);rebuild(tim,rs); pushup(ro); &#125; void update(int ro,int x,int y)&#123; int l=e[ro].l,r=e[ro].r; if(l&gt;=x and r&lt;=y)&#123; e[ro].v+=1; e[ro].tag+=1;return; &#125; pushdown(ro); int mid=l+r&gt;&gt;1; if(mid&gt;=x)update(ls,x,y); if(mid&lt;y)update(rs,x,y); pushup(ro); &#125; int query(int ro,int x,int y)&#123; int l=e[ro].l,r=e[ro].r; if(l==x and r==y)return e[ro].v; pushdown(ro); int mid=l+r&gt;&gt;1; if(mid&lt;x)return query(rs,x,y); else if(mid&gt;=y)return query(ls,x,y); else return max(query(ls,x,mid),query(rs,mid+1,y)); &#125; #undef ls #undef rs &#125;T; inline void work()&#123; n=read(),k=read(); for(int x,i=1;i&lt;=n;i++)x=read(),pre[i]=cur[x],cur[x]=i; T.build(1,0,n); for(int i=1;i&lt;=k;i++)&#123; T.rebuild(i-1,1); for(int x=1;x&lt;=n;x++) T.update(1,pre[x],x-1),f[x][i]=T.query(1,0,x-1); &#125; printf(&quot;%d&quot;,f[n][k]); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CF896D Nephren Runs a Cinema","slug":"CF896D Nephren Runs a Cinema","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.430Z","comments":true,"path":"2022/04/30/CF896D Nephren Runs a Cinema/","permalink":"https://starcried.github.io/2022/04/30/CF896D%20Nephren%20Runs%20a%20Cinema/","excerpt":"","text":"CF896D Nephren Runs a Cinema题意售票员最开始没有纸币，每次来一个顾客可以给她一张、拿走她一张或不操作。求出不出现中途没钱给的情况 $n$ 名顾客后剩余钱数在 $l\\sim r$ 的方案数。 思路这是我们一道模拟赛题。 解法 1：套路组合计数。先不考虑不操作的顾客，那么就相当于是求二维平面不过一条直线到达一点的方案数。直接枚举操作顾客数，用组合数减去另外一个组合数然后乘上所有顾客中选这些顾客的方案数即可。 解法 2：暴力动态规划。每次从至多三个方向转移。 赛时我先想到第一个解法但是没想到枚举操作人数，以为不可做，于是想到了优化暴力的解法。 解法 3：解法 2 的优化。求出 $F&#x3D;(x^{-1}+1+x)^n$ ，然后 $f(x)-f(x+2)$ 的第 $l \\sim r$ 项的和即为答案。 $(x^{-1}+1+x)$ 表示三种转移方式，但是求出来的 $F$ 显然不是正确答案，因为会有从负数幂的贡献是应该减掉的。 那么我们就考虑减掉它，实际上和解法一相同，$f(x)-f(x+2)$ 相当于减去了错解，那么减完之后就是答案了。 因为每次要倍长多项式，使用快速幂一样的方式卷就可以了。根据主定理，时间复杂度 $O(n\\log n)$。 考场上有部分分，模数为 $998244353$，那么正解只需要改成任意模数多项式乘法就行了。 代码注意，此代码不可 AC 此题，仅在模数为 $998244353$ 时正确。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cstdlib&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c)) w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c)) x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=2e6+10,mod=998244353,ge=3,gi=998244354/3; inline int fpow(int a,int b)&#123;int ans=1;for(;b;b&gt;&gt;=1,a=1ll*a*a%mod)if(b&amp;1)ans=1ll*ans*a%mod;return ans;&#125; struct NTT&#123; int r[maxn],lim; inline void getr(int li)&#123;lim=li;for(int i=0;i&lt;lim;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(lim&gt;&gt;1));&#125; inline void operator () (int *a,int type) const &#123; for(int i=0;i&lt;lim;i++) if(i&lt;r[i]) swap(a[i],a[r[i]]); for(int mid=1;mid&lt;lim;mid&lt;&lt;=1)&#123; int rt=fpow(type==1?ge:gi,(mod-1)/(mid&lt;&lt;1)); for(int r=mid&lt;&lt;1,j=0;j&lt;lim;j+=r)&#123; int p=1; for(int k=0;k&lt;mid;k++,p=1ll*p*rt%mod)&#123; int x=a[j+k],y=1ll*p*a[j+k+mid]%mod; a[j+k]=(x+y)%mod,a[j+k+mid]=(x-y+mod)%mod; &#125; &#125; &#125; if(type==-1) for(int p=fpow(lim,mod-2),i=0;i&lt;lim;i++) a[i]=1ll*a[i]*p%mod; &#125; &#125;ntt; int n; int a[maxn],ans[maxn]; inline void work()&#123; n=read();read(); int Lim=4,lim=2; a[0]=a[1]=a[2]=ans[0]=1; int x=n,Len=3,len=1; while(x)&#123; static int res[maxn],tmp[maxn]; if(x&amp;1)&#123; for(int i=0;i&lt;Lim;i++) res[i]=a[i]; for(int i=Lim;i&lt;Lim+lim;i++) res[i]=0; for(int i=0;i&lt;lim;i++) tmp[i]=ans[i]; for(int i=lim;i&lt;Lim+lim;i++) tmp[i]=0; len+=Len;lim=Lim; while(lim&lt;len) lim&lt;&lt;=1; ntt.getr(lim&lt;&lt;1); ntt(res,1),ntt(tmp,1); for(int i=0;i&lt;lim&lt;&lt;1;i++) tmp[i]=1ll*res[i]*tmp[i]%mod; ntt(tmp,-1); for(int i=0;i&lt;lim;i++) ans[i]=tmp[i]; &#125; for(int i=0;i&lt;Lim;i++) res[i]=a[i]; for(int i=Lim;i&lt;Lim&lt;&lt;1;i++) res[i]=0; Lim&lt;&lt;=1;Len&lt;&lt;=1; for(int i=Lim;i&lt;Lim&lt;&lt;1;i++) res[i]=0; ntt.getr(Lim&lt;&lt;1); ntt(res,1); for(int i=0;i&lt;Lim&lt;&lt;1;i++) res[i]=1ll*res[i]*res[i]%mod; ntt(res,-1); for(int i=0;i&lt;Lim;i++) a[i]=res[i]; x&gt;&gt;=1; &#125; int l=read(),r=read(); for(int i=n;i&lt;n&lt;&lt;1;i++) ans[i]=(ans[i]-ans[i+2]+mod)%mod; int Ans=0; for(int i=n+l;i&lt;=n+r;i++) Ans=(Ans+ans[i])%mod; printf(&quot;%d\\n&quot;,Ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"CSP-S2021","slug":"CSP-S2021","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.431Z","comments":true,"path":"2022/04/30/CSP-S2021/","permalink":"https://starcried.github.io/2022/04/30/CSP-S2021/","excerpt":"","text":"这不是一篇严格意义上的游记，因为我已经退役了。不过是借题写一点在文化课生活中突然回归了一下午 OI 生活的感受罢。 先走个形式。 T1第一眼看着就挺简单，考虑了一下发现对于每个区域增加个数时单调，但是没完全考虑。于是便写出了三分两个单调方向相反函数的和的垃圾。离谱的是，样例全过了，于是花了四十分钟直接就过了没管。 T2一眼区间 Dp，看了眼数据范围更加坚信不疑。但是看了试了很久都不会，准备先读完其他题。 T3感觉就 CF Div2 CD 难度的样子，仔细思索了一下，发现只要确定了两个起始点后面的都是向左右扩张，贪心之后，也就是确定好的。而起始点只有两个，大力模拟两遍即可。 T4一眼网络流，没别的想法了（没想到对偶图最短路）。本来只是想得 $k&#x3D;2$ 的分数的，就没去想其他分数，发现 $k&#x3D;2$ 就是网络流。我记得我国赛前专门训练过一段时间 dinic，于是凭着一点记忆就写出来了，竟然没写挂。不过因为期间又在 T2 上耗费了许多时间，并且建图方式反复横跳了好几次（因为要多组数据忘了前向星怎么删边了，后来想起来又写回来了），耗费了一个小时，最后很紧张地把 $k&#x3D;2$ 调过了。其实再多给我点时间我把其他边加上就能多得好多分。 比赛打完第二天，lwc 跑过来给我说我爆零了，然后他直接没影了，留我一个人一脸懵逼。下课之后赶忙跑去机房，结果没人。一上午浑浑噩噩，像丢了魂，无心听课。 然后，突然意识到，为什么我会变成这个样子。 因为 OI 真的对我很重要。 我意识到，我爱上了 OI。我爱上了陷身艰深题目的感觉，爱上了和同志们一起激发想象和思考火花的和谐，爱上了因为学艺不精却自信无比而针锋相对的激情，爱上了要么是灵机一动、要么是无奈看题解后的豁然开朗，爱上了和全国甚至全世界同志追求共同目标的归属感，爱上了不吝赐教的学长学姐们的个性张扬。有一次，有外国网友来问我题目，我曾用蹩脚的英语尝试向他解释数学问题；有一次，我写的题解被一个陌生的选手指出错误，我花了一个下午将这道题重新学懂、弄透……有一次，我一个人坐在机房里，担忧着自己的前程，感谢着自己的选择。那些的时光无论有多么难熬，现在被岁月洗涤干燥下来的，只有最纯粹的、最美丽的结晶。 我从来没有这么在乎过一件事，即使这件事已经不会影响的我的学业和前程。我在乎它，是因为我对它动了真感情。它是我现在所引以为傲的一切。最近一直不好好写作业，一回宿舍就弹吉他，全然没有了高一时候的那股卷劲。如果没有这块银牌，我根本不可能像这样生活。要么会闷头学习，要么自暴自弃，怀疑自己。现在，这块银牌提醒着，我有能力，我有价值，但是如果突然发现它只是我一时运气好所得到的，那么它就是一块铁锥子，把我的心扎穿扎透。 我记起来，我最开始学习 OI 的初心是什么。 我很庆幸，这份初心从未变过。 经历了这么多，你还是你。——UNDERTALE 回去问了之后发现，sys 第一次测的确实有问题。实际得分应该在 125+。 也许，这就是天意。 我要珍惜这份感情、这份经历。我会将它贯穿我今后的人生。我会去不断证明，自己的价值。 我明白了为何 LCA 要一直献身 OI 教学事业。 附记： 一位同学反复在我耳边重复的一件事情。中考前其实我已经被 xgdfz 点考选中了，但是还是去参加了 xtyz 的考试。面试时老师问，有没有人已经和其他学校签过约了。我举手。问及为什么，我回答道： “为了看看我是不是真的有上 xgdfz 的实力。” 最后没被录上。看来是没有 2021&#x2F;10&#x2F;30 补记 最终成绩 $$ 90+0+100+25&#x3D;215 $$ T1 我直接震惊拿了 90 分是没想到的。CCF 的数据还是一如既往的水。 心里还是挺高兴的。能看到自己宝刀未老，说明我这一年没有白白度过。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"DFS序","slug":"DFS序","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.432Z","comments":true,"path":"2022/04/30/DFS序/","permalink":"https://starcried.github.io/2022/04/30/DFS%E5%BA%8F/","excerpt":"","text":"DFS序 DFS序，算法如其名就是用DFS搞的序。没有学过DFS的同学先去看看吧（基本中的基本）这个算法就是依靠DFS将一个树状图用线性结构进行排列。因为树形结构每次更新查找总是很费时间，如果我们可以用某种方法把它转变成线性结构就可以用线段树或者树状数组很轻松地记录了。 要将一个树进行线性排列，我们就需要记录每个根所含的叶子。这个问题可以用时间戳来搞定。（其实这个戳就是个记录的数字，每次dfs一个点就++，当一个点dfs完所有子叶之后比较之前记录它自身的记录的数字就可以确定他的子叶个数和分别是什么了） 废话说太多。我们来看下这个图（转自网络侵删） DFS一般从根节点1开始，每次深度优先遍历点，一般是【根，左叶到右叶】（这个叫什么序有同学知道告诉我我忘了）比如这个图的次序就是[2,4,7,1,3,6,5] 时间戳怎么实现呢？用两个数组in[] out[]和一个戳cnt，每dfs一个点i就cnt++并in[i]=cnt,遍历完子点再out[i]=cnt（cnt是全局变量） 实现 int time = 0;inline void dfs(int x, int fa) { in[x] = ++time; num[time] = x; for(int i = 0; i &lt; G[x].size(); i++) { int cnt = G[x][i]; if(cnt == fa) continue; dfs(cnt, x); } out[x] = time;} 当然，dfs序也可以变无向图为线性结构，就是把图变成一个生成树。 tarjan就是基于这个算法达到的。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; struct gh { int v,w; gh(){}; gh(int _v,int _w):v(_v),w(_w){} }; vector&lt;gh&gt; g[100];int k,d[1000],n; int sech(int); int main(){ freopen(“dfs.in“,“r“,stdin); int x,y,z; cin &gt;&gt; n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) { scanf(“%d%d%d“,&amp;x,&amp;y,&amp;z); g[x].push_back(y); g[y].push_back(x); } sech(1); for(int i&#x3D;1;i&lt;&#x3D;n+1;i++) cout&lt;&lt;d[i];} int sech(int u){ int v; d[u]&#x3D;++k; for(int j&#x3D;0;j&lt;g[u].size();j++) { v&#x3D;g[u][j]; if(d[v]&#x3D;&#x3D;0) sech(v); }}","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"Dijkstra 最短路","slug":"Dijkstra 最短路","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.432Z","comments":true,"path":"2022/04/30/Dijkstra 最短路/","permalink":"https://starcried.github.io/2022/04/30/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"Dijkstra 算法 我之前一直记的迪杰斯特拉的翻译导致我把 dijkstra 写成了 dijstra 或者 dijskra…… 我以后叫她迪杰克斯歘！ dijkstra 是用来在有向图或者无向图中寻找任意两个点的最小距离的算法。但是无法处理带负环的图和求最长路。 dijkstra 的核心思想是由已找到的最短路的点集每次扩展一个点的最短路。 dis 数组代表由起点到其他点的最短路，初始化其为 $INF$ (不要过大导致溢出；把到起点的 dis[s] 设为 0)，每次找到点集外与点集内的点直接相连的点中距离最短的一个点加入点集。重复此过程直到无点可以扩展。dis 记录着从起点到能到的所有点的距离。 如果 dis[i] 仍为 $INF$，可能不可至。 注意到“每次找到点集外与点集内的点直接相连的点中距离最短的一个点加入点集”的过程可以用堆完成。 时间复杂度为 $O(m\\log m)$ 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;const int maxn=1e5+10,maxm=2e5+10,INF=0x3f3f3f3f;int n,m,s;int ecnt,head[maxn],to[maxm],nxt[maxm],v[maxm];inline void addedge(int a,int b,int c)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;v[ecnt]=c;&#125;int dis[maxn];bool vis[maxn];inline void dijkstra()&#123; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; q; q.push(make_pair(0,s)); for(int i=1;i&lt;=n;i++) dis[i]=INF; dis[s]=0; while(!q.empty())&#123; int x=q.top().second;q.pop(); if(vis[x])continue; vis[x]=true; for(int u,i=head[x];i;i=nxt[i]) if(dis[u=to[i]]&gt;dis[x]+v[i]) dis[u]=dis[x]+v[i],q.push(make_pair(dis[u],u)); &#125;&#125;int main()&#123; n=read(),m=read(),s=read(); for(int a,b,i=1;i&lt;=m;i++)a=read(),b=read(),addedge(a,b,read()); dijkstra(); for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,dis[i]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"Dirichlet卷积和莫比乌斯反演[非公开][草稿]","slug":"Dirichlet卷积和莫比乌斯反演[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.433Z","comments":true,"path":"2022/04/30/Dirichlet卷积和莫比乌斯反演[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/Dirichlet%E5%8D%B7%E7%A7%AF%E5%92%8C%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"非全面讲解，仅供记录笔记#Dirichlet卷积$$(f\\ast g)(n)&#x3D;\\sum_{d\\mid n}f(d)g(\\frac{n}{d})$$$$\\varepsilon &#x3D;\\mu \\ast 1 \\iff \\varepsilon(n) &#x3D; \\sum_{d\\mid n} \\mu(d)$$其中$\\varepsilon$卷任何函数等于其函数本身。#莫比乌斯函数$\\mu$##定义$$\\mu(n)&#x3D;\\begin{cases}1&amp;n&#x3D;0\\(-1)^k&amp;k为n的本质不同质因子个数\\0&amp;otherwise\\ \\end{cases}$$ ##性质 $$\\sum_{d\\mid n}\\mu(d)&#x3D;\\begin{cases}1&amp;n&#x3D;1\\0&amp;n\\neq 1\\ \\end{cases}$$ 积性函数，所以可以线性筛求得：1234567891011121314inline void getMu()&#123; mu[1]=1; for(int i=2;i&lt;=maxn;i++)&#123; if(!mark[i])prime[++tot]=i,mu[i]=-1; for(int j=1;j&lt;=tot and i*prime[j]&lt;=maxn;j++)&#123; mark[i*prime[j]]=1; if(i%prime[j]==0)&#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125; #莫比乌斯反演若有$$f(n) &#x3D; \\sum_{d\\mid n}g(d)$$ 则有 $$g(n)&#x3D;\\sum_{d\\mid n}\\mu(\\frac{d}{n})f(d)$$ 正确性证明（卷积）： 原问题即已知$f&#x3D;g1$求证$g&#x3D;f\\mu$ 证明：$f\\mu&#x3D;g1\\mu \\implies f\\mu &#x3D; g\\varepsilon \\implies f\\mu&#x3D;g$ 得证。 ##反演结论$$[\\gcd(i,j)&#x3D;1]\\iff\\sum_{d\\mid\\gcd(i,j)}\\mu(d)$$ #例题P2522 Problem b容斥原理，分别求四个从1开始的区间的个数合并即可。那么我们的问题就是处理单个区间的个数。求$$\\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{m}[\\gcd(i,j)&#x3D;k]$$即$$\\sum_{i&#x3D;1}^{\\frac{n}{k}}\\sum_{j&#x3D;1}^{\\frac{m}{k}}[\\gcd(i,j)&#x3D;1]$$即$$\\sum_{i&#x3D;1}^{\\frac{n}{k}}\\sum_{j&#x3D;1}^{\\frac{m}{k}}\\sum_{d\\mid \\gcd(i,j)}\\mu(d)$$即$$\\sum_{d&#x3D;1}^{min(\\frac{n}{k},\\frac{m}{k})}\\mu(d)\\lfloor\\frac{n}{kd}\\rfloor\\lfloor\\frac{m}{kd}\\rfloor$$然后数论分块求即可。注意这里的$\\mu$因为是求和可以在线性筛","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"Guass消元总结","slug":"Guass消元总结","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.434Z","comments":true,"path":"2022/04/30/Guass消元总结/","permalink":"https://starcried.github.io/2022/04/30/Guass%E6%B6%88%E5%85%83%E6%80%BB%E7%BB%93/","excerpt":"","text":"Guass消元约旦·高斯消元法 求线性方程组我们用一个$n*(n+1)$的矩阵存储线性方程组各项系数和零次项系数。 每一次找到一个未知数系数最大的方程，交换当前行方程和该方程，并将其他行该未知数的系数化为零。 重复n次即可。 最后第$a[i][i]$个数就是第i个未知数的系数，$a[i][n+1]$是等式右侧的数，用后者除以前者即可。 当化第i个方程时，若找到所有方程的最大值为零，即都为零，则无解。 当一个未知数在多于0个少于n个方程中有系数，该未知数为自由元，线性方程组有无数组解。 洛谷P3389 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=105; double a[maxn][maxn]; int n; inline void work()&#123; n=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n+1;j++)a[i][j]=(double)read(); for(int i=1;i&lt;=n;i++)&#123; int mx=i; for(int j=i+1;j&lt;=n;j++) if(fabs(a[j][i])&gt;fabs(a[mx][i]))mx=j; swap(a[i],a[mx]); if(!a[i][i])return (void)puts(&quot;No Solution&quot;); for(int j=1;j&lt;=n;j++)&#123; if(j==i)continue; double tmp=a[j][i]/a[i][i]; for(int k=i+1;k&lt;=n+1;k++) a[j][k]-=a[i][k]*tmp; &#125; &#125; for(int i=1;i&lt;=n;i++)printf(&quot;%.2lf\\n&quot;,a[i][n+1]/a[i][i]); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 让我们再做一道不那么板子的题目： P4035 球形空间产生器 简述题意，我们需要求一个n维向量$(x_1,x_2,\\dots,x_n)$使得对于每个i都满足$\\sum_{j&#x3D;1}^{n}(a_{i,j}-x_j)^2&#x3D;dis$, 其中$dis$为未知常数。 所以我们考虑消去这个$dis$: 我们将相邻的i的方程做差得到：$$\\sum_{j&#x3D;1}^{n}a_{i+1,j}^2-a_{i,j}^{2}-2x_j(a_{i+1,j}-a_{i,j})&#x3D;0$$然后将常数项与未知数剥离：$$\\sum_{j&#x3D;1}^{n}2x_j(a_{a+1,j}-a_{i,j})&#x3D;\\sum_{j&#x3D;1}^na_{i+1,j}^2-a_{i,j}^2$$解线性方程组即可。 题目给定有解。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;using namespace std;const int maxn=12;double b[maxn][maxn],a[maxn][maxn];int n;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=n;j++)scanf(&quot;%lf&quot;,&amp;b[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=(b[i][j]-b[i+1][j])*2; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++) a[i][n+1]+=b[i][j]*b[i][j]-b[i+1][j]*b[i+1][j]; &#125; for(int i=1;i&lt;=n;i++)&#123; int mx=i; for(int j=i+1;j&lt;=n;j++)if(fabs(a[j][i])&gt;fabs(a[mx][i]))mx=j; swap(a[mx],a[i]); for(int j=1;j&lt;=n;j++)&#123; if(j==i)continue; double tmp=a[j][i]/a[i][i]; for(int k=i+1;k&lt;=n+1;k++) a[j][k]-=a[i][k]*tmp; &#125; &#125; for(int i=1;i&lt;=n;i++)printf(&quot;%.3lf &quot;,a[i][n+1]/a[i][i]); return 0;&#125; 求行列式的值依据行列式的性质，我们用高斯消元将行列式转变为下三角矩阵，行列式的值就为对角线上各数的积。 当行列式其中两行成比例时行列式值为零。所以我们在高斯消元的时候发现只要有一列找不到有值的数就是这种情况，直接返回0即可。 一般来说，求行列式有可能加模数或者行列式值很大，我们在除的时候用逆元搞就行了。 1234567891011121314151617181920inline int Guass(int *a)&#123; int ans=1; for(int i=1;i&lt;=n;i++)&#123; int pos=0; for(int j=i;j&lt;=n;j++)if(a[j][i])&#123;pos=j;break;&#125; if(!pos)return 0; if(pos!=i)swap(a[pos],a[i]); int inv=fpow(a[i][i],mod-2,mod);//快速幂 for(int j=i+1;j&lt;=n;j++)&#123; if(a[j][i])&#123; ans=ans*inv%mod; for(int k=i+1;k&lt;=n;k++) a[j][k]=((a[j][k]*a[i][i]%mod-a[i][k]*a[j][i]%mod)%mod+mod)%mod; a[j][i]=0; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)ans=ans*a[i][i]%mod; return ans;&#125; 求逆矩阵根据rsk大佬的课，我们可以知道矩阵求逆有一个方法是： 给原矩阵右边接一个等大的单位矩阵。 高斯消元，将原矩阵转为单位矩阵。 右侧矩阵即为所求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define int long longusing namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=405,mod=1e9+7; int n,a[maxn][maxn&lt;&lt;1]; inline int fpow(int a,int b)&#123; int ans=1; for(;b;b&gt;&gt;=1,a=a*a%mod)if(b&amp;1)ans=ans*a%mod; return ans; &#125; inline void work()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)a[i][j]=read(); a[i][n+i]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; int mx=i; for(int j=i+1;j&lt;=n;j++) if(a[mx][i]&lt;a[j][i])mx=j; swap(a[mx],a[i]); if(!a[i][i])return (void)puts(&quot;No Solution&quot;); int inv=fpow(a[i][i],mod-2); for(int j=1;j&lt;=n;j++)&#123; if(j==i)continue; for(int tmp=a[j][i]*inv%mod,k=1;k&lt;=n*2;k++)//k可以从i+1开始，不会更新下三角 a[j][k]=(a[j][k]-a[i][k]*tmp%mod+mod)%mod; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int tmp=fpow(a[i][i],mod-2),j=1;j&lt;=n;j++) printf(&quot;%lld &quot;,a[i][j+n]*tmp%mod); puts(&quot;&quot;); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"GCD SUM","slug":"GCD SUM","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.433Z","comments":true,"path":"2022/04/30/GCD SUM/","permalink":"https://starcried.github.io/2022/04/30/GCD%20SUM/","excerpt":"","text":"GCD SUM求$$\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^n\\gcd(i,j)$$将原式变换得到$$\\sum_{d&#x3D;1}^nd\\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}[\\gcd(i,j)&#x3D;1]$$别着急莫比乌斯反演，我们知道$$\\varphi(n)&#x3D;\\sum_{i&#x3D;1}^n[\\gcd(i,n)&#x3D;1]$$所以原式可化为$$\\sum_{d&#x3D;1}^nd\\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}（2*\\varphi(i)-1）$$这里减一是因为会算重。对于上式，数论分块一下即可根号求。但实际上$\\varphi$还是要线性求。所以线性的也行。 然而，若是数据太大的话只能根号那就杜教筛加数论分块吧。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.435Z","comments":true,"path":"2022/04/30/KMP算法/","permalink":"https://starcried.github.io/2022/04/30/KMP%E7%AE%97%E6%B3%95/","excerpt":"","text":"KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。 问题：求a字符串与b字符串中子串相同的串首位置。 暴力就不说了，设a长m，b长n，每次枚举比对每个字符，复杂度O(nm)。 KMP主要思想：如果一个字符串的子串与前缀相等，那么在查找时就可以直接将前缀跳至该子串的位置。复杂度O(n)。 nxt[x]记录x位置字符在查询串中的跳转位置。 eg:对于串abaabacac: &nbsp;a b a a b a c a c -1 0 0 1 1 2 3 0 1 inline void getnxt() { int j=0,k=-1; nxt[0]=-1; while(j&lt;s.length()-1) { if(k==-1||s[j]==s[k])nxt[++j]=++k; else k=nxt[k]; } } 查询时跳转即可。 模拟一下就知道啦~ 全代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; string s,t; int nxt[1000]; inline void getnxt() { int j=0,k=-1; nxt[0]=-1; while(j&lt;s.length()-1) { if(k==-1||s[j]==s[k])nxt[++j]=++k; else k=nxt[k]; } } inline int indexkmp() { int i=0,j=0; while(i&lt;s.length() and j&lt;t.length())//如果比完了就退出来了 if(i==-1 or s[i]==t[j])i++,j++; else i=nxt[i]; if(i&gt;=s.length())return j-s.length(); return -1; } int main() { std::ios::sync_with_stdio(false); cin&gt;&gt;s&gt;&gt;t; getnxt(); cout&lt;&lt;indexkmp()+1; return 0; } &nbsp;例题 洛谷P3375 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e6+5; int nxt[maxn]; char a[maxn],b[maxn]; int lena,lenb; inline void getnxt() { int k=-1,j=0; nxt[0]=-1; while(j&lt;lena) if(k==-1 or a[k]==a[j]) nxt[++j]=++k; else k=nxt[k]; } inline void indexkmp() { int j=0,i=0; while(j&lt;lena and i&lt;lenb) if(j==-1 or a[j]==b[i]){ i++,j++; if(j==lena){ printf(\"%d\\n\",i-lena+1); j=nxt[j]; } } else j=nxt[j]; } int main() { scanf(\"%s\\n%s\",&amp;b,&amp;a); lena=strlen(a); lenb=strlen(b); getnxt(); indexkmp(); for(int i=1;i&lt;=lena;i++) printf(\"%d \",nxt[i]); return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"LCT(Link-Cut-Tree)","slug":"LCT(Link-Cut-Tree)","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.436Z","comments":true,"path":"2022/04/30/LCT(Link-Cut-Tree)/","permalink":"https://starcried.github.io/2022/04/30/LCT(Link-Cut-Tree)/","excerpt":"","text":"LCT(Link-Cut-Tree)LCT维护一个森林，即把每个节点用splay维护，可以进行许多操作： 查询、修改链上的信息 随意指定原树的根（即换根） 动态连边、删边 合并两棵树、分离一棵树 动态维护连通性 等 主要性质 每一个Splay维护的是一条从上到下按在原树中深度严格递增的路径，且中序遍历Splay得到的每个点的深度序列严格递增。 每个节点仅包含于一个splay中。 边分为实边和虚边，实边记录 son 和 fa，包含在一个 splay 中。为了维护 splay 树形，虚边仅记录 fa。不过虚边是由 splay(根） 指向父亲的，不一定是原节点。 操作accessaccess 操作是指将一个点到树根的路径打通，即把根节点和该节点搞到一个 splay 上。 我们从 x 向上爬。 每次将所在节点 splay（转到 splay 的根节点） 将该 splay 所指向的节点的儿子换为 splay 的根节点。 更新信息。 将操作点切换到父节点，重复操作直到节点的父亲是0。 12345void access(int x)&#123; for(int y=0;x;y=x,x=fa[x])&#123; splay(x);son[x][1]=y;pushup(x); &#125;&#125; makertmakert 操作可以将一个节点变成整棵树的根。 将该节点 access 。 将该节点 splay 。 将该节点打上子树翻转标记。 正确性为，access 操作后将该节点到原来的根的路径打通并成为一个 splay 后，整条路径的 dfs 序都会反转，而其他节点的 dfs 序都不会变。 12inline void rev(const int &amp;x)&#123;tag[x]^=1,swap(son[x][0],son[x][1]);&#125;void makert(int x)&#123;access(x),splay(x),rev(x);&#125; findrtfindrt 操作可以找到一个节点在其树内的根。 将该节点 access。 将该节点 splay。 一直跳左儿子，则找到 dfs 序最小的节点，也就是根。 1int findrt(int x)&#123;access(x),splay(x);while(son[x][0])x=son[x][0];splay(x);return x;&#125; 注意，上面的代码中如果不在找到根后 splay 复杂度是假的。 linklink 操作将两个连通块进行连边。 若要在连边之前判断两者是否已经联通，可以将一个节点变成根，查找另一个节点的根进行判断。 一般连边是将一个节点变成另一个节点的虚儿子，也就是连虚边。这种方式适用于虚儿子贡献较为简单计算的情况。设这两个节点为 x 和 y，我们将 y makert ，将 x splay，然后将 y 的 fa 改成 x 即可。（如果要统计子树信息的话，将两个节点都改为根，然后连边时顺便统计字数贡献） 当然也可以直接连成实边。 1234void link(int x,int y)&#123; makert(x); if(findrt(y)!=x) fa[x]=y;&#125; 12345inline void link(int x,int y)&#123; splay(x);fa[x]=y; access(y),splay(y); son[y][1]=x;pushup(y);&#125; cutcut 操作将两个点间进行删边。 若要判断两个点原先是否有边相连，先将一个节点设成根然后判断连通性，再判断两点间的 dfs 序是否连续。 然后直接将上面节点的儿子和下面节点的父亲设为 0 即可。别忘了更新信息。 1234inline void cut(int x,int y)&#123; makert(x); if(findrt(y)==x and fa[y]==x and !son[y][0]) rs=fa[y]=0,pushup(x);&#125; 模板维护链上最大值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct LCT&#123; #define ls son[x][0] #define rs son[x][1] int tag[maxm],fa[maxm],st[maxm],mx[maxm],id[maxm],son[maxm][2]; inline bool notrt(int x)&#123;return son[fa[x]][0]==x or son[fa[x]][1]==x;&#125; inline int getw(int x)&#123;return son[fa[x]][1]==x;&#125; inline void rev(int x)&#123;if(x)swap(ls,rs),tag[x]^=1;&#125; inline void pushup(int x)&#123; if(mx[ls]&gt;mx[rs])mx[x]=mx[ls],id[x]=id[ls]; else mx[x]=mx[rs],id[x]=id[rs]; if(val[x]&gt;mx[x])mx[x]=val[x],id[x]=x; &#125; inline void pushdown(int x)&#123;if(tag[x])tag[x]=0,rev(ls),rev(rs);&#125; inline void rotate(int x)&#123; int y=fa[x],z=fa[y],w=getw(x),s=son[x][!w]; if(notrt(y))son[z][getw(y)]=x; son[x][!w]=y;son[y][w]=s; if(s)fa[s]=y;fa[x]=z,fa[y]=x; pushup(y);pushup(x); &#125; inline void splay(int x)&#123; int y,top=1; for(y=x;notrt(st[++top]=y);y=fa[y]); while(top)pushdown(st[top--]); while(notrt(x))&#123; y=fa[x]; if(notrt(y)) rotate((getw(x)^getw(y))?x:y); rotate(x); &#125; pushup(x); &#125; inline void access(int x)&#123; for(int y=0;x;y=x,x=fa[x]) splay(x),rs=y,pushup(x); &#125; inline int findroot(int x)&#123; access(x),splay(x); while(ls)x=ls; splay(x); return x; &#125; inline void makeroot(int x)&#123;access(x),splay(x),rev(x);&#125; inline void split(int x,int y)&#123;makeroot(x);access(y),splay(y);&#125; inline void link(int x,int y)&#123;makeroot(x);if(findroot(y)!=x)fa[x]=y;&#125; inline void cut(int x,int y)&#123; makeroot(x); if(findroot(y)==x and fa[y]==x and !son[y][0]) fa[y]=rs=0,pushup(x); &#125; #undef ls #undef rs&#125;L; 进阶维护子树信息LCT 可以维护子树信息，但是只能做到查询而做不到修改。简单来说，维护的方式就是每次给一个 splay 添加一个虚儿子的时候，需要多开一个数据结构记录虚儿子的贡献。然后在上传的时候考虑虚儿子即可。 P4219 [BJOI2014]大融合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int n,m; struct LCT&#123; #define ls son[x][0] #define rs son[x][1] int tag[maxn],son[maxn][2],fa[maxn],siz[maxn],siz2[maxn],st[maxn]; inline bool getw(int x)&#123;return son[fa[x]][1]==x;&#125; inline void rev(int x)&#123;if(x)tag[x]^=1,swap(ls,rs);&#125; inline void pushup(int x)&#123;siz[x]=siz[ls]+siz[rs]+siz2[x]+1;&#125; inline void pushdown(int x)&#123;if(tag[x])tag[x]=0,rev(ls),rev(rs);&#125; inline bool notrt(int x)&#123;return son[fa[x]][0]==x or son[fa[x]][1]==x;&#125; inline void rotate(int x)&#123; int y=fa[x],z=fa[y],w=getw(x),s=son[x][!w]; if(notrt(y))son[z][getw(y)]=x;son[y][w]=s;son[x][!w]=y; if(s)fa[s]=y;fa[y]=x,fa[x]=z; pushup(y); &#125; inline void splay(int x)&#123; int y;int top=0; for(y=x;notrt(st[top++]=y);y=fa[y]); while(top--)pushdown(st[top]); while(notrt(x))&#123; y=fa[x]; if(notrt(y)) rotate(getw(x)^getw(y)?x:y); rotate(x); &#125; pushup(x); &#125; inline void access(int x)&#123;for(int y=0;x;y=x,x=fa[x])splay(x),siz2[x]+=siz[rs]-siz[y],rs=y,pushup(x);&#125; inline void makert(int x)&#123;access(x),splay(x),rev(x);&#125; inline int findrt(int x)&#123;access(x),splay(x);while(ls)x=ls;splay(x);return x;&#125; inline void split(int x,int y)&#123;makert(x);access(y),splay(y);&#125; inline void link(int x,int y)&#123;makert(x);if(findrt(y)!=x)fa[x]=y,siz2[y]+=siz[x],splay(y);&#125; inline void cut(int x,int y)&#123; makert(x); if(findrt(y)==x and fa[y]==x and !son[y][0]) rs=fa[y]=0,pushup(x); &#125; #undef ls #undef rs &#125;L; inline void work()&#123; n=read(),m=read(); int x,y; while(m--)&#123; char c=getchar(); while(!isalpha(c))c=getchar(); if(c==&#x27;A&#x27;)L.link(read(),read()); else L.split(x=read(),y=read()),printf(&quot;%lld\\n&quot;,1ll*(L.siz2[x]+1)*(L.siz2[y]+1)); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 动态求LCALCT 本来就是动态的，如何求两个点的 LCA 呢？ 将其中一个点 access ，然后将另外一个点 access ，并记录最后一次 splay 前找到的节点（即最后的代码中的y） 利用LCT的结构LCT 是一种优秀的暴力，它的结构有时候可以帮我们做一些很强的题目（虽然一般都想不到这个模型） P3703 [SDOI2017]树点涂色 思路：观察操作，有“将一个点到根节点的路径染成同一种新的颜色”，发现同一颜色的连通块都是一条链，那么我们很快想到 LCT 的模型。维护的答案是该节点到根的 splay 个数。那么我们在改变 access 的时候，即改变儿子虚实的时候，需要将虚儿子子树内所有节点的答案都增加，将实儿子子树内所有节点都减少，这个可以用线段树进行维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int n,m; int dfn[maxn],dep[maxn],id[maxn],fa[maxn],son[maxn],siz[maxn],top[maxn]; int ecnt,head[maxn],nxt[maxn&lt;&lt;1],to[maxn&lt;&lt;1]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt; &#125; void dfs1(int x,int f)&#123; fa[x]=f,dep[x]=dep[f]+1,siz[x]=1; for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=f)&#123; dfs1(u,x); siz[x]+=siz[u]; if(siz[u]&gt;siz[son[x]]) son[x]=u; &#125; &#125; void dfs2(int x,int topf)&#123; top[x]=topf;dfn[x]=++dfn[0],id[dfn[0]]=x; if(!son[x])return; dfs2(son[x],topf); for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=fa[x] and u!=son[x]) dfs2(u,u); &#125; inline int LCA(int x,int y)&#123; while(top[x]!=top[y]) if(dep[top[x]]&gt;dep[top[y]]) x=fa[top[x]]; else y=fa[top[y]]; return dep[x]&lt;dep[y]?x:y; &#125; struct SegmentTree&#123; #define ls (ro&lt;&lt;1) #define rs (ro&lt;&lt;1|1) #define mid ((l+r)&gt;&gt;1) int mx[maxn&lt;&lt;2],tag[maxn&lt;&lt;2]; inline void pushup(const int &amp;ro)&#123;mx[ro]=max(mx[ls],mx[rs]);&#125; inline void pushdown(const int &amp;ro)&#123;tag[ls]+=tag[ro],tag[rs]+=tag[ro];mx[ls]+=tag[ro],mx[rs]+=tag[ro];tag[ro]=0;&#125; void build(const int &amp;ro=1,const int &amp;l=1,const int &amp;r=n)&#123; if(l==r)return mx[ro]=dep[id[l]],tag[ro]=0,void(); build(ls,l,mid),build(rs,mid+1,r); pushup(ro); &#125; void update(const int &amp;x,const int &amp;y,const int &amp;k,const int &amp;ro=1,const int &amp;l=1,const int &amp;r=n)&#123; if(x==l and y==r) return tag[ro]+=k,mx[ro]+=k,void(); if(tag[ro])pushdown(ro); if(y&lt;=mid) update(x,y,k,ls,l,mid); else if(x&gt;mid) update(x,y,k,rs,mid+1,r); else update(x,mid,k,ls,l,mid),update(mid+1,y,k,rs,mid+1,r); pushup(ro); &#125; int query(const int &amp;x,const int &amp;y,const int &amp;ro=1,const int &amp;l=1,const int &amp;r=n)&#123; if(x==l and y==r)return mx[ro]; if(tag[ro])pushdown(ro); if(y&lt;=mid) return query(x,y,ls,l,mid); if(x&gt;mid) return query(x,y,rs,mid+1,r); return max(query(x,mid,ls,l,mid),query(mid+1,y,rs,mid+1,r)); &#125; #undef ls #undef rs #undef mid &#125;T; struct LCT&#123; #define ls son[x][0] #define rs son[x][1] int son[maxn][2],fa[maxn]; inline bool notrt(int x)&#123;return son[fa[x]][0]==x or son[fa[x]][1]==x;&#125; inline int getw(int x)&#123;return son[fa[x]][1]==x;&#125; inline void rotate(int x)&#123; int y=fa[x],z=fa[y],w=getw(x),s=son[x][!w]; if(notrt(y)) son[z][getw(y)]=x;son[y][w]=s,son[x][!w]=y; if(s) fa[s]=y;fa[y]=x,fa[x]=z; &#125; inline void splay(int x)&#123; while(notrt(x))&#123; int y=fa[x]; if(notrt(y))rotate(getw(x)^getw(y)?x:y); rotate(x); &#125; &#125; inline int findrt(int x)&#123;while(ls)x=ls;return x;&#125; inline void access(int x)&#123; for(int u,y=0;x;y=x,x=fa[x])&#123; splay(x); if(rs) u=findrt(rs),T.update(dfn[u],dfn[u]+siz[u]-1,1); if(rs=y) u=findrt(rs),T.update(dfn[u],dfn[u]+siz[u]-1,-1); &#125; &#125; #undef ls #undef rs &#125;S; inline void work()&#123; n=read(),m=read(); for(int i=1;i&lt;n;i++) addedge(read(),read()); dfs1(1,0);dfs2(1,1); for(int i=1;i&lt;=n;i++) S.fa[i]=fa[i]; T.build(); while(m--) switch(read())&#123; case 1:S.access(read());break; case 2:&#123; int x=read(),y=read(),lca=LCA(x,y); printf(&quot;%d\\n&quot;,T.query(dfn[x],dfn[x])+T.query(dfn[y],dfn[y])-2*T.query(dfn[lca],dfn[lca])+1); break; &#125; case 3:&#123; int x=read(); printf(&quot;%d\\n&quot;,T.query(dfn[x],dfn[x]+siz[x]-1)); &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; P6292 区间本质不同子串个数也用到了这个 trick。 更多trick待耕。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P1040 加分二叉树","slug":"P1040 加分二叉树","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.439Z","comments":true,"path":"2022/04/30/P1040 加分二叉树/","permalink":"https://starcried.github.io/2022/04/30/P1040%20%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"https://www.luogu.com.cn/problem/P1040 n很小，可以树形dp或者区间dp。 设fij为从i到j的最大加分值，则有f[i][j]=max(f[i][k-1]*f[k+1][j]+f[k][k])。 有一个小技巧，将f[i][i-1]全部设置为1，这样的话搜索到叶子就也可以按照通式dp了。 对于输出前序遍历（根，左树，右树）我们再树形dp一下就行了。 树形dp比较清晰明了（但是耗内存）。不想写树形dp的话递推式如上。 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;algorithm&gt; 4 #include&lt;cstring&gt; 5 using namespace std; 6 inline int read() 7 { 8 int x=0,w=1;char c=getchar(); 9 while(!isdigit(c)){ 10 if(c=='-')w=-1; 11 c=getchar(); 12 } 13 while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); 14 return x*w; 15 } 16 const int maxn=35; 17 int n; 18 int f[maxn][maxn],a[maxn],ro[maxn][maxn]; 19 int search(int l,int r) 20 { 21 if(l&gt;r)return 1; 22 if(l==r){ro[l][r]=l;return f[l][r];} 23 if(f[l][r])return f[l][r]; 24 for(int w,i=l;i&lt;=r;i++) 25 { 26 w=search(l,i-1)*search(i+1,r)+f[i][i]; 27 if(w&gt;f[l][r])f[l][r]=w,ro[l][r]=i; 28 } 29 return f[l][r]; 30 } 31 void print(int l,int r) 32 { 33 if(l&gt;r)return ; 34 printf(\"%d \",ro[l][r]); 35 print(l,ro[l][r]-1); 36 print(ro[l][r]+1,r); 37 } 38 int main() 39 { 40 n=read(); 41 for(int i=1;i&lt;=n;i++)f[i][i]=read(); 42 search(1,n); 43 printf(\"%d\\n\",f[1][n]); 44 print(1,n);//发扬先辈遗德，恢弘志士之气 45 return 0; 46 } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P1447能量采集","slug":"P1447能量采集","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.440Z","comments":true,"path":"2022/04/30/P1447能量采集/","permalink":"https://starcried.github.io/2022/04/30/P1447%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/","excerpt":"","text":"P1447能量采集 定义:(i,j)表示处于(i,j)的植物的贡献 我们发现，点(i,j)与(0,0)的连线所过整点的数目为$\\gcd(i,j)$ 发现要是想记录每个点的答案并不好算。那么怎么好算呢？ 我们来找一找同一直线上的所有点答案的和的关系。先不考虑答案只考虑个数。发现，寻找一个点及其倍数的个数的和更加好算。而且，因为有n和m的限制，那么向下取整的答案一定就是其本身。考虑容斥，我们只需要从大往小更新答案并将答案乘2减1加起来即可。 那么对于一个点及其倍数的答案怎么计算呢？ 假设n小于m，那么对于一个小于n的数i，显然它的倍数的个数就是$(n&#x2F;i)(m&#x2F;i)$，这样一来我们只需要考虑小于n的所有数的个数就能够统计nm的所有数的答案了。至于为什么$(m-n) * m$这一块不用考虑，是因为这里不会再有数容斥它们了，直接统计就行。 所以，答案即为 $$\\displaystyle \\sum_{i&#x3D;1}^{n}num_i*(i*2-1)$$ 其中$\\displaystyle num_i&#x3D;(n&#x2F;i)*(m&#x2F;i)-\\sum_{i&#x3D;2}^{n&#x2F;i}num_i$ 在代码中一个倒序循环即可，时间复杂度线性。 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#define int long long using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;const int maxn=1e5+10;int ans[maxn];signed main()&#123; int n=read(),m=read(),Ans=0; if(n&gt;m)swap(n,m); for(int i=n;i;i--)&#123; ans[i]=(n/i)*(m/i); for(int j=2;j&lt;=n/i;j++)ans[i]-=ans[i*j]; Ans+=(ans[i]*(i*2-1)); &#125; printf(&quot;%lld&quot;,Ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P2015","slug":"P2015","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.441Z","comments":true,"path":"2022/04/30/P2015/","permalink":"https://starcried.github.io/2022/04/30/P2015/","excerpt":"","text":"二叉苹果树 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;algorithm&gt; 4 #include&lt;cstring&gt; 5 using namespace std; 6 const int maxn=200; 7 struct edge{ 8 int to,nxt,dis; 9 }e[maxn]; 10 int n,m; 11 inline int read() 12 { 13 int x;char c=getchar(); 14 while(c&lt;'0' or c&gt;'9')c=getchar(); 15 x=c-'0',c=getchar(); 16 while(c&gt;='0' and c&lt;='9')x=x*10+c-'0',c=getchar(); 17 return x; 18 } 19 int head[maxn],ecnt,f[maxn][maxn]; 20 inline void addedge(int from,int to,int dis) 21 { 22 e[++ecnt]=(edge){to,head[from],dis},head[from]=ecnt; 23 } 24 int siz[maxn]; 25 void dfs(int x,int fa) 26 { 27 for(int i=head[x];i;i=e[i].nxt) 28 { 29 int u=e[i].to; 30 if(u==fa)continue; 31 dfs(u,x); 32 siz[x]+=siz[u]+1; 33 for(int j=min(siz[x],m);j;j--) 34 for(int k=min(siz[u],j-1);k&gt;=0;k--) 35 f[x][j]=max(f[x][j],f[x][j-k-1]+f[u][k]+e[i].dis); 36 //j表示保留j时，k全部遍历所有情况 37 } 38 } 39 40 int main() 41 { 42 n=read(),m=read(); 43 for(int a,b,c,i=1;i&lt;n;i++) 44 { 45 a=read(),b=read(),c=read(); 46 addedge(a,b,c);addedge(b,a,c); 47 } 48 dfs(1,0); 49 printf(\"%d\",f[1][m]); 50 return 0; 51 } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P2014选课","slug":"P2014选课","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.440Z","comments":true,"path":"2022/04/30/P2014选课/","permalink":"https://starcried.github.io/2022/04/30/P2014%E9%80%89%E8%AF%BE/","excerpt":"","text":"洛谷P2014选课 一道树形DP题。 f[i][j]表示i个点选j门课程的最大学分。 递推方程： for(int a=n;a&gt;0;a--)//总共选择多少 for(int b=0;b&lt;a;b++)//分别选择多少(b,a-b) f[x][a]=max(f[x][a],f[x][a-b]+f[u][b]); //都不遍历0的原因是f[i][0]无论怎样都是0 我们可以证明在j&lt;=m时值都是正确的，剩下的不用管啦么的时间！ 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;ctype.h&gt; 4 #include&lt;vector&gt; 5 #include&lt;algorithm&gt; 6 #include&lt;cstring&gt; 7 using namespace std; 8 const int maxn=305; 9 inline int read() 10 { 11 int x,w=1;char c=getchar(); 12 while(!isdigit(c))c=getchar(); 13 if(c=='-')w=-1,c=getchar(); 14 x=c-'0';c=getchar(); 15 while(isdigit(c))x=x*10+c-'0',c=getchar(); 16 return x*w; 17 } 18 int n,m; 19 int f[maxn][maxn]; 20 vector &lt;int&gt;son[maxn]; 21 void dfs(int x) 22 { 23 f[x][0]=0; 24 for(int i=0;i&lt;son[x].size();i++) 25 { 26 int u=son[x][i]; 27 dfs(u); 28 for(int a=n;a&gt;0;a--) 29 for(int b=0;b&lt;a;b++) 30 f[x][a]=max(f[x][a],f[x][a-b]+f[u][b]); 31 } 32 } 33 int main() 34 { 35 n=read(),m=read()+1; 36 for(int i=1;i&lt;=n;i++){ 37 son[read()].push_back(i); f[i][1]=read(); 38 } 39 f[0][0]=f[0][1]=0; 40 n++; 41 dfs(0); 42 printf(\"%d\\n\",f[0][m]); 43 return 0; 44 } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P1414 又是毕业季II","slug":"P1414 又是毕业季II","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.440Z","comments":true,"path":"2022/04/30/P1414 又是毕业季II/","permalink":"https://starcried.github.io/2022/04/30/P1414%20%E5%8F%88%E6%98%AF%E6%AF%95%E4%B8%9A%E5%AD%A3II/","excerpt":"","text":"P1414 又是毕业季II 数论题，主要在于推演。 洛谷的《又是毕业季I》更好玩 发现对于所有的同学的能力值，只要我们选出每个数的所有因子并记录所有同学所有因子出现的次数，就可以得到一个c数组为所有因子出现的次数。 因为让输出1-n所有的值，而且因子数c[k-1]&gt;=c[k]，我们就一定可以从因子数最高的c向下遍历到c[i]更高的位置，即最大公约数i向下递减，当第一次发现c[i]&gt;=i，那么就肯定存在&gt;=i个数的因子是i，符合题意。 数论真有意思。 #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int c[1000005],n; int main() { int t=0; std::ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { int x; cin&gt;&gt;x; t=max(t,x); int m=sqrt(x); for(int j=1;j&lt;=m;j++) if(!(x%j)) { c[j]++; if(x!=j*j)c[x/j]++; } } for(int i=1;i&lt;=n;i++) { while(c[t]&lt;i)t--; cout&lt;&lt;t&lt;&lt;endl; } return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P2476-记忆化搜索","slug":"P2476-记忆化搜索","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.442Z","comments":true,"path":"2022/04/30/P2476-记忆化搜索/","permalink":"https://starcried.github.io/2022/04/30/P2476-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","excerpt":"","text":"链接##DP？我们看看，这个状态似乎有亿点点多。我们看看数据范围，数量不超过5，颜色数不超过15.15维DP显然不靠谱。那么我们就思考一下……个数？记忆化搜索可ac： 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;const ll maxn=16,mod=1e9+7;ll f[maxn][maxn][maxn][maxn][maxn][6],b[6];ll dfs(ll a,ll b,ll c,ll d,ll e,ll last)&#123; if(f[a][b][c][d][e][last]!=-1)return f[a][b][c][d][e][last]; if(a+b+c+d+e==0)return 1; ll ans=0; if(a)ans+=(a-(last==2))*dfs(a-1,b,c,d,e,1); if(b)ans+=(b-(last==3))*dfs(a+1,b-1,c,d,e,2); if(c)ans+=(c-(last==4))*dfs(a,b+1,c-1,d,e,3); if(d)ans+=(d-(last==5))*dfs(a,b,c+1,d-1,e,4); if(e)ans+=e*dfs(a,b,c,d+1,e-1,5); ans%=mod; f[a][b][c][d][e][last]=ans; return ans;&#125;int main()&#123; memset(f,-1,sizeof f); int k; scanf(&quot;%d&quot;,&amp;k); for(int a,i=1;i&lt;=k;i++)scanf(&quot;%d&quot;,&amp;a),b[a]++; printf(&quot;%lld&quot;,dfs(b[1],b[2],b[3],b[4],b[5],0)); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P2490 [SDOI2011]黑白棋","slug":"P2490 [SDOI2011]黑白棋","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.442Z","comments":true,"path":"2022/04/30/P2490 [SDOI2011]黑白棋/","permalink":"https://starcried.github.io/2022/04/30/P2490%20[SDOI2011]%E9%BB%91%E7%99%BD%E6%A3%8B/","excerpt":"","text":"P2490 [SDOI2011]黑白棋题意一个 $1*n$ 的棋盘上，A 可以移动白色棋子，B 可以移动黑色的棋子，其中白色不能往左，黑色不能往右。他们每次操作可以移动 1 到 $d$ 个棋子。 每当移动某一个棋子时，这个棋子不能跨越两边的棋子，当然也不可以出界。当谁不可以操作时，谁就失败了。 思路显然可以将题意转化为一种 K-Nim 游戏，即在 $\\frac k2$ 堆石子中，每次可将 $d$ 堆石子取任意个，令对手无路可走时获胜。 用总方案数减去先手必败的方案数即为答案，因为先手必败方案更加好算。 K-Nim 游戏结论设 $r_i$ 为二进制第 $i$ 位所有数该位为 1 的个数 $\\pmod {d+1}$ 的值，那么只用一步即可在 “$r$ 全为 0” 和 “$r$ 不全为 0” 两种状态间转移。 感性证明考虑一个大小不超过 $d$ 的集合，为我们一次操作需要拿走的石子堆的集合，选 0 或 1 都是合法的。 假设我们现在已经有这样一个大小为 $d$ 的集合，其中有 $x$ 个 1，$y$ 个 0，即 $x+y&#x3D;d$。我们要让 $r$ 等于零，分以下情况： $x\\ge r$ 则选择 $r$ 个 1 变为 0 即可。 $x&lt;r$ 则 $y+r\\ge d+1$ ，则选择 $d-r+1$ 个 0 变为 1 即可。 所以一定有一种方法使这一位的 $r$ 变成 0. 现在我们并没有一个可以随便转换的集合，但是当一个数的高位从 1 变为 0 之后低位就可以随便选 0 和 1.所以我们从高位向低位考虑，如果一直符合第二个情况就向下考虑，否则就是第一个情况，并且在这种情况下把 1 变成 0 是合法的，那么我们扩大集合即可。 得证。 在上述博弈中，所有 $r$ 为 0 的状态是必败态。我们只需要算所有这种情况的方案就可以了。 考虑 Dp。设 $f_{ij}$ 为前 $i$ 位的 $r$ 均为 0，总共 $j$ 个石子的方案数。 新选一位，枚举在 $d+1$ 堆石子中放入若干次石子。即$$f_{i+1,j+2^ix(d+1)}+&#x3D;f_{i,j}\\binom{\\frac k2}{x*(d+1)}$$最后统计答案需要枚举每一堆的起点位置，即在原题中的白棋的位置，答案为所有位的$$f_{i,j}\\binom{n-j-\\frac k2}{\\frac k2}$$的和。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=10005,mod=1e9+7; int n,k,d,C[maxn][205],f[18][100005]; inline void work()&#123; n=read(),k=read(),d=read(); C[0][0]=1; for(int i=1;i&lt;=n;i++)&#123; C[i][0]=1; for(int j=1;j&lt;=200;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod; &#125; f[0][0]=1; for(int i=0;i&lt;=16;i++) for(int j=0;j&lt;=n-k;j++) for(int x=0;(1ll&lt;&lt;i)*x*(d+1)&lt;=n-k and x*(d+1)&lt;=k/2;x++) f[i+1][j+(1ll&lt;&lt;i)*x*(d+1)]=(f[i+1][j+(1ll&lt;&lt;i)*x*(d+1)]+1ll*f[i][j]*C[k/2][x*(d+1)])%mod; int ans=0; for(int i=0;i&lt;=n-k;i++) ans=(ans+1ll*f[17][i]*C[n-i-k/2][k/2])%mod; printf(&quot;%d\\n&quot;,(C[n][k]-ans+mod)%mod); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P2375 [NOI2014]动物园","slug":"P2375 [NOI2014]动物园","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.441Z","comments":true,"path":"2022/04/30/P2375 [NOI2014]动物园/","permalink":"https://starcried.github.io/2022/04/30/P2375%20[NOI2014]%E5%8A%A8%E7%89%A9%E5%9B%AD/","excerpt":"","text":"P2375 [NOI2014]动物园 为什么复制题目连字体大小一块复制过来了（雾） 我竟然会做NOI的题目辣~\\(≧▽≦)/~（看的题解 总而言之，这是一道简单的KMP问题。题面简直是给没学过KMP的人看的（比如我）。 我们发现，这个所谓的num数组和nxt有异曲同工之妙。但是我们对于不能重合这一块有一点问号。那我们先不管重不重合，先给他记录成重合的。 于是在标记nxt时同时也可以把num标记。原理是，nxt记录的是该字符串相同的前缀字符个数，num[i]记录的是当前字符作为从0到i的子串内后缀与前缀相同的子串的子串的数目。我们发现，其实他就是num[j]+1，j就是nxt[i]！可以举几个例子模拟一下。 这样一来查询的时候也很方便了。 问题来了，怎么去重呢？如果j已经到i&lt;&lt;1的时候，我们将j挪到nxt[j]就好了，直到j&lt;i/2。因为上面我们记录的num数组的特性，如果有重叠此时的值就相当于在nxt[j]的时候的没有重叠的串的num数。模拟一下也很好理解的。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define mod 1000000007 using namespace std; typedef long long ll; const int maxn=1e6+5; char a[maxn]; int nxt[maxn],len,num[maxn]; inline void getnxt() { int k=-1,j=0; nxt[0]=-1; while(j&lt;len) { if(k==-1 or a[j]==a[k])nxt[++j]=++k,num[j]=num[k]+1; else k=nxt[k]; } } inline void kmp() { int j=0,i=1; ll ans=1; while(i&lt;len) { if(j==-1 or a[j]==a[i]){ j++,i++; while((j&lt;&lt;1)&gt;=(i+1))j=nxt[j]; ans=(ans*(ll)(num[j]+1))%mod; } else j=nxt[j]; } printf(\"%lld\\n\",ans); } int main() { int t; scanf(\"%d\",&amp;t); while(t--) { scanf(\"%s\",&amp;a); len=strlen(a); memset(nxt,0,sizeof nxt); num[0]=0,num[1]=1; getnxt(); kmp(); } return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P3203 弹飞绵羊-分块","slug":"P3203 弹飞绵羊-分块","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.443Z","comments":true,"path":"2022/04/30/P3203 弹飞绵羊-分块/","permalink":"https://starcried.github.io/2022/04/30/P3203%20%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-%E5%88%86%E5%9D%97/","excerpt":"","text":"P3203 弹飞绵羊-分块观察数据范围，发现可以分块。只需要处理每个点跳出所在块后的位置和次数即可。目的是为了加速查询并降低修改复杂度。 对于修改，重构整个块内信息即可。 时间复杂度正确的一批 具体实现也挺简单。注意重构时从后往前贡献即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=2e5+10; int n,N,out[maxn],cos[maxn],a[maxn],belong[maxn],l[maxn],r[maxn]; void sudo(int l,int r)&#123;for(int i=r;i&gt;=l;i--)if(i+a[i]&gt;n or belong[i+a[i]]!=belong[i])out[i]=i+a[i],cos[i]=1;else out[i]=out[i+a[i]],cos[i]=1+cos[i+a[i]];&#125; inline void work()&#123; n=read(); N=sqrt(n); for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/N+1; for(int i=1;i&lt;=n;i++)&#123; if(!l[belong[i]])l[belong[i]]=i; r[belong[i]]=i; &#125; for(int i=1;i&lt;=n;i++)a[i]=read(); sudo(1,n); int q=read(); while(q--)&#123; if(read()==1)&#123; int sum=0,pos=read()+1; while(pos&lt;=n)sum+=cos[pos],pos=out[pos]; printf(&quot;%d\\n&quot;,sum); &#125;else&#123; int pos=read()+1; a[pos]=read(); sudo(l[belong[pos]],r[belong[pos]]); &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 那我要是想知道最后弹飞前的点在哪呢？ 我们只需要在重构的时候记录一下从哪来的就好了。 双倍经验：CF13E 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=2e5+10; int n,N,out[maxn],last[maxn],cos[maxn],a[maxn],belong[maxn],l[maxn],r[maxn]; void sudo(int l,int r)&#123;for(int i=r;i&gt;=l;i--)if(i+a[i]&gt;min(n,r))out[i]=i+a[i],last[i]=i,cos[i]=1;else out[i]=out[i+a[i]],last[i]=last[i+a[i]],cos[i]=1+cos[i+a[i]];&#125; inline void work()&#123; n=read(); int q=read(); N=sqrt(n); for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/N+1; for(int i=1;i&lt;=n;i++)&#123; if(!l[belong[i]])l[belong[i]]=i; r[belong[i]]=i; &#125; for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=belong[n];i++)sudo(l[i],r[i]); while(q--)&#123; if(read()==1)&#123; int sum,pos,lpos; sum=0,pos=lpos=read(); while(pos&lt;=n)sum+=cos[pos],lpos=last[pos],pos=out[pos]; printf(&quot;%d %d\\n&quot;,lpos,sum); &#125;else&#123; int pos=read(); a[pos]=read(); sudo(l[belong[pos]],r[belong[pos]]); &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P3209-平面图判定","slug":"P3209-平面图判定","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.444Z","comments":true,"path":"2022/04/30/P3209-平面图判定/","permalink":"https://starcried.github.io/2022/04/30/P3209-%E5%B9%B3%E9%9D%A2%E5%9B%BE%E5%88%A4%E5%AE%9A/","excerpt":"","text":"##平面图平面图就是所有点的连边不相交的图。（当然是在你尽量想让它不相交的情况下）。这一点可以大概理解成拓扑图的性质，即每连一条边就会将某个区域进行分割——很明显，如果两个点分别处在两个不可达的区域，它们要连边显然是要穿过其他边的。###平面图定理边数大于点数的三倍减六的图一定不是平面图。即设n为点数，m为边数，有$$m&lt;&#x3D;n*3-6$$关于平面图的其他定理和上定理的证明我不会不过我有大佬博客就不乱搬了。##关于此题题解首先，它给出了n和m，我们先通过平面图定理判断一下，这样可以偷很多的懒。 然后，我们发现这个题是给了哈密顿回路的。那么我们就可以把这个图伸展成一个环便于理解。然后，我们发现了这个图的性质——哈密顿回路相当于分割整个平面成了两个区域。也就是说，两个非哈密顿回路上的边的边顶多能共存两组。（因为不能交叉）两个区域？共存两组？2-SAT浮现出水面。对，我们可以给非哈密顿回路边的边连边，然后求它们的最大匹配。（如果没有哈密顿回路这玩意还是个DPC问题）2-SAT的模板我就不注释了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=3e4+5,maxv=205,maxm=2e6+5; int cnt,Cir[maxv],rec[maxn],x1[maxn],y1[maxn],x2[maxn],y2[maxn]; //Cir用来按编号从小到大记录环,rec反向记录Cir; //x1,y1,x2,y2分别记录全部边和去除环上边的剩余边 int tot,dfn[maxn],low[maxn],_n; //tarjan用 int ecnt,head[maxm],nxt[maxm],to[maxm],belong[maxn]; //前向星用 bool cir[maxv][maxv]; //cir记录Cir inline void addedge(int from,int too) &#123; to[++ecnt]=too,nxt[ecnt]=head[from],head[from]=ecnt; &#125; int st[maxn],top; bool vis[maxn]; void tarjan(int x) &#123; dfn[x]=low[x]=++tot; st[++top]=x;vis[x]=1; for(int i=head[x];i;i=nxt[i]) &#123; int u=to[i]; if(!dfn[u])&#123; tarjan(u); low[x]=min(low[x],low[u]); &#125;else if(vis[x])&#123; low[x]=min(low[x],dfn[u]); &#125; &#125; if (dfn[x] == low[x]) &#123; int v; belong[x] = ++_n;vis[x]=0; while (v = st[top--], v != x) belong[v] = _n,vis[v]=0; &#125; &#125; inline bool check() &#123; for(int i=1;i&lt;=(cnt&lt;&lt;1);i++) if(!dfn[i])tarjan(i); for(int i=1;i&lt;=cnt;i++) if(belong[i]==belong[i+cnt])return false; return true; &#125; inline void work() &#123; int T,n,m; n=read(),m=read(); memset(head,0,sizeof head); memset(x1,0,sizeof x1); memset(y1,0,sizeof y1); memset(x2,0,sizeof x2); memset(y2,0,sizeof y2); memset(belong,0,sizeof belong); memset(rec,0,sizeof rec); memset(cir,0,sizeof cir); memset(dfn,0,sizeof dfn); memset(low,0,sizeof low); memset(to,0,sizeof to); memset(nxt,0,sizeof nxt); memset(vis,0,sizeof vis); memset(st,0,sizeof st); ecnt=tot=cnt=_n=top=0; for(int i=1;i&lt;=m;i++) &#123; x1[i]=read(),y1[i]=read(); if(x1[i]&gt;y1[i]) swap(x1[i],y1[i]); &#125;//记录下来等会处理 rec[Cir[1]=read()]=1; for(int i=2;i&lt;=n;i++)&#123; rec[Cir[i]=read()]=i; (Cir[i]&gt;Cir[i-1]?cir[Cir[i-1]][Cir[i]]:cir[Cir[i]][Cir[i-1]])=1; &#125; (Cir[1]&gt;Cir[n]?cir[Cir[n]][Cir[1]]:cir[Cir[1]][Cir[n]])=1; //获取cir和rec if(m&gt;3*n-6)&#123; printf(&quot;NO\\n&quot;);return; &#125; for(int i=1;i&lt;=m;i++) &#123; if(cir[x1[i]][y1[i]])continue; x2[++cnt]=x1[i],y2[cnt]=y1[i]; &#125; for(int i=1;i&lt;cnt;i++) for(int j=i+1;j&lt;=cnt;j++) &#123; int a=rec[x2[i]] , b=rec[y2[i]] , x=rec[x2[j]] , y=rec[y2[j]]; if(a&gt;b)swap(a,b);if(x&gt;y)swap(x,y); if((a&lt;x and b&gt;x and y&gt;b) or (x&lt;a and y&gt;a and b&gt;y)) addedge(i,j+cnt),addedge(j,i+cnt),addedge(i+cnt,j),addedge(j+cnt,i); &#125; if(check())printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125;&#125;int main()&#123; int T=read(); while(T--) star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P3312 数表","slug":"P3312 数表","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.444Z","comments":true,"path":"2022/04/30/P3312 数表/","permalink":"https://starcried.github.io/2022/04/30/P3312%20%E6%95%B0%E8%A1%A8/","excerpt":"","text":"P3312 数表题意求出$$\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^m\\sigma(\\gcd(i,j))[\\sigma(\\gcd(i,j))\\le a]$$其中 $\\sigma$ 表示约数和。 思路&#x2F;推导考虑没有 $a$ 的限制的情况。$$\\begin{aligned}ans&amp;&#x3D;\\sum_{d&#x3D;1}^{\\min(n,m)}\\sigma(d)\\sum_{i&#x3D;1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j&#x3D;1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}[\\gcd(i,j)&#x3D;1]\\&amp;&#x3D;\\sum_{d&#x3D;1}^{\\min(n,m)}\\sigma(d)\\sum_{i&#x3D;1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j&#x3D;1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}\\sum_{p\\mid i\\land p\\mid j}\\mu(p)\\&amp;&#x3D;\\sum_{d&#x3D;1}^{\\min(n,m)}\\sigma(d)\\sum_{p&#x3D;1}^{\\left\\lfloor\\frac{\\min(n,m)}{d}\\right\\rfloor}\\mu(p)\\left\\lfloor\\frac{n}{dp}\\right\\rfloor\\left\\lfloor\\frac{m}{dp}\\right\\rfloor\\&amp;&#x3D;\\sum_{T&#x3D;1}^{\\min(n,m)}\\sum_{d&#x3D;1}^T\\sigma(d)\\mu(\\frac Td)\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\end{aligned}$$ 考虑加入 $a$ 的限制。将询问按照 $a$ 大小离线，然后用一个树状数组维护 $\\sum_d\\sigma(d)\\mu(\\frac Td)$ 的前缀和即可。 具体是将线性筛出的所有数的约数和从小到大进行排序，在从小到大查询的时候进行更新。 不会筛 $\\sigma$ 的可以看我的另一篇博客 时间复杂度瓶颈在于查询，需要用到数论分块，为 $O(q\\sqrt n\\log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;utility&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10,maxm=2e4+10,N=1e5; int n,p[maxn/10],mu[maxn],tot,c[maxn],ans[maxm],g[maxn]; pair&lt;int,int&gt; f[maxn]; bool mark[maxn]; inline void insert(int x,int k)&#123;for(;x&lt;=N;x+=x&amp;-x) c[x]+=k;&#125; inline int query(int x)&#123;int ans=0;for(;x;x-=x&amp;-x) ans+=c[x];return ans;&#125; struct Query&#123; int n,m,a,id; inline bool operator &lt; (const Query&amp; zp) const &#123;return a&lt;zp.a;&#125; inline int solve()&#123; if(n&gt;m) swap(n,m); int ans=0; for(int l=1,r;l&lt;=n;l=r+1) r=min(n/(n/l),m/(m/l)),ans+=((query(r)-query(l-1))*(n/l)*(m/l)); return ans; &#125; &#125;q[maxm]; inline void work()&#123; mu[1]=1; f[1]=make_pair(1,1); for(int i=2;i&lt;=N;i++)&#123; if(!mark[i]) p[++tot]=i,mu[i]=-1,g[i]=i+1,f[i]=make_pair(i+1,i); for(int j=1,tmp;j&lt;=tot and (tmp=i*p[j])&lt;=N;j++)&#123; mark[tmp]=true; if(i%p[j]==0)&#123; mu[tmp]=0; g[tmp]=g[i]*p[j]+1; f[tmp]=make_pair(f[i].first/g[i]*g[tmp],tmp); break; &#125; mu[tmp]=-mu[i]; g[tmp]=p[j]+1; f[tmp]=make_pair(f[i].first*f[p[j]].first,tmp); &#125; &#125; sort(f+1,f+1+N); n=read(); for(int i=1;i&lt;=n;i++) q[i].n=read(),q[i].m=read(),q[i].a=read(),q[i].id=i; sort(q+1,q+1+n); for(int i=1,j=1;i&lt;=n;i++)&#123; while(f[j].first&lt;=q[i].a and j&lt;=N)&#123; for(int k=f[j].second;k&lt;=N;k+=f[j].second) insert(k,f[j].first*mu[k/f[j].second]); j++; &#125; ans[q[i].id]=q[i].solve(); &#125; for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,ans[i]&amp;(~(1&lt;&lt;31))); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P2491 消防 P1099 树网的核","slug":"P2491 消防 P1099 树网的核","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.443Z","comments":true,"path":"2022/04/30/P2491 消防 P1099 树网的核/","permalink":"https://starcried.github.io/2022/04/30/P2491%20%E6%B6%88%E9%98%B2%20P1099%20%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/","excerpt":"","text":"P2491 消防&#x2F;P1099 树网的核双倍经验，双倍快乐。 题意在一个树上选择一段总长度不超过$s$的链使所有点到该链距离的最大值最小。 输出这个最小的值。 做法Define:以下$s$指链或链长。 证明一下$s$一定处于直径上。假设它不在直径上，一定存在直径的其中一个端点到$s$的距离大于现在所处支链的最大距离。所以$s$不在直径上一定不优。 于是我们找到直径并记录下直径上的所有点。 然后，我们枚举直径上的每一个长度小于$s$的最长区间（最长原因显然，因为长度越短答案肯定不会更优），并计算此时的答案，对于每一个区间的答案取min即可。 考虑计算每个区间的答案。我们把直径拉出来，用两个指针$l$和$r$从左向右遍历这个直径，$s$即为$l$到$r$。考虑此时这个区间的答案即为$l$到$r$中每个点$i$的子树中最深的点的距离（我们设为$h_i$）（注意这里的子树是不包括直径的，即子树中所有的点都属于支链）和$l$到直径左端点的距离（设为$ls$）和$r$到直径右端点的距离（设为$rt$）的最大值。原因显然。 那么我们可以预处理出$h_i$，并在遍历直径的时候用单调队列维护$h$的最大值，然后用这个值与$ls$和$rt$的最大值更新答案（取最小值）即可。 一些疑问 当存在多条直径时，区间似乎一定包括重心并尽量使重心居中。然而这并没有什么卵用，并且一样可以用上面的方法做，不会造成影响。 $s$的左右两端一定在端点上。既是，$s$是可以为一个点的。 具体实现和代码 求直径时两次DFS即可。然后发现记录的d数组刚好可以用来当做前缀和（只是使代码略显凌乱罢了） 单调队列似乎要特殊记录一下链首的位置而不能用head代替，否则无法记录区间长（或者只是我没有想到更好的处理方法） 求深度DFS或BFS. 时间复杂度O(n). （学会了一个新单词diameter，意思是直径，重音在|a|上） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=3e5+10; int n,l; int ecnt,head[maxn],nxt[maxn&lt;&lt;1],to[maxn&lt;&lt;1],dis[maxn&lt;&lt;1]; inline void addedge(int a,int b,int c)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;dis[ecnt]=c; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt;dis[ecnt]=c; &#125; int d[maxn],mx,fa[maxn],diam[maxn],tot,sum; void dfs1(int x,int f,int &amp;dia)&#123; fa[x]=f; if(mx&lt;d[x]) mx=d[x],dia=x; for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==f)continue; d[u]=d[x]+dis[i]; dfs1(u,x,dia); &#125; &#125; inline void diameter()&#123; int dia,dia2; dfs1(1,0,dia); mx=0;d[dia]=0; dfs1(dia,0,dia2); while(dia2!=dia)&#123; diam[++tot]=dia2; dia2=fa[dia2]; &#125; diam[++tot]=dia; &#125; int h[maxn],dep[maxn],q[maxn],ans=0x3f3f3f3f; void dfs2(int x,int f)&#123; for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==f)continue; dfs2(u,x); dep[x]=max(dep[x],dep[u]+dis[i]); &#125; &#125; inline void solve()&#123; for(int i=2;i&lt;tot;i++)&#123; int x=diam[i]; h[i]=0;dep[x]=0; for(int j=head[x];j;j=nxt[j])&#123; int u=to[j]; if(u==diam[i-1] or u==diam[i+1])continue; dfs2(u,x); h[i]=max(h[i],dep[u]+dis[j]); &#125; &#125; int s=1,t=0,ls=0,rt=mx,from=1; for(int i=1;i&lt;=tot;i++)&#123; while(s&lt;=t and d[diam[from]]-d[diam[i]]&gt;l)from++,s+=(from&gt;q[s]),ls=(mx-d[diam[from]]); while(s&lt;=t and h[i]&gt;h[q[t]])t--; q[++t]=i;rt=d[diam[i]]; ans=min(ans,max(h[q[s]],max(ls,rt))); &#125; printf(&quot;%d&quot;,ans); &#125; inline void work()&#123; n=read(),l=read(); for(int a,b,c,i=1;i&lt;n;i++)a=read(),b=read(),c=read(),addedge(a,b,c); diameter(); solve(); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P3643 [APIO2016]划艇","slug":"P3643 [APIO2016]划艇","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.445Z","comments":true,"path":"2022/04/30/P3643 [APIO2016]划艇/","permalink":"https://starcried.github.io/2022/04/30/P3643%20[APIO2016]%E5%88%92%E8%89%87/","excerpt":"","text":"P3643 [APIO2016]划艇题意一个合法序列可表示为一个长度为 $n$ 的序列，其中第 $i$ 个数可以为 0 或 $[l_i,r_i]$ 中一个整数，且满足所有不为零的数组成的子序列严格上升。求合法序列方案数。 思路朴素动态规划做法为，设 $f_{ij}$ 表示第 $i$ 个数不为零且数量为 $j$ 的方案数，则$$ans&#x3D;\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;l_i}^{r_i}f_{ij}\\f_{ij}&#x3D;\\sum_{k&#x3D;1}^{j-1}\\sum_{q&#x3D;0}^{i-1}f_{qk},j\\in[l_i,r_i]$$但是第二维枚举太多。考虑优化。 首先，我们考虑一段区间，按照上面的方式递推需要依次枚举数量再枚举 $i-1$ 个数的方案进行转移，不能够简化的主要原因是因为每个数都有一个限定的区间。若不加限定，发现这段转移可以简化为一个简单问题：每个数可以选取值范围内任意的值或 0，求所有不为零的数组成的子序列严格上升方案数。设取值区间大小为 $len$，数的数量为 $n$，则答案为 $\\binom{len+n}n$。可以理解为额外增加 $n$ 个 0 表示选 0。 所以我们进行离散化，将取值范围分为若干段，每个数的范围由若干这样的段组成。对于每一段我们都可以按照上面的方法转移。即对于这一段区间 $j$，对于所有包含它的数字，可以从 $0$ 到 $i-1$ 中任意一种状态 $k$ 转移得到，并且需要乘上在 $k$ 到 $i$ 中选任意个区间包含 $j$ 的数字不为 0 的方案数，即 $\\binom{len+m-1}m$ 其中 $m$ 为上述数的个数，$len$ 为第 $j$ 段的长度，减 1 是因为第 $i$ 个必选。即$$ans&#x3D;\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;l_i}^{r_i}f_{ij}\\f_{ij}&#x3D;\\sum_{q&#x3D;0}^{i-1}\\binom{len+m_{jq}-1}{m_{jq}}\\sum_{k&#x3D;1}^{j-1}f_{qk},j\\in[l_i,r_i],m_{jq}&#x3D;\\sum_{o&#x3D;q+1}^i[j\\in[l_o,r_o]],len为区间j的长度$$发现后面的求和维护一个前缀和即可。总时间复杂度 $O(n^3)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=505,mod=1e9+7; int n,m,l[maxn],r[maxn],b[maxn&lt;&lt;1],C[maxn],inv[maxn],f[maxn],ans; inline void work()&#123; n=read(); inv[1]=1;for(int i=2;i&lt;=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; for(int i=1;i&lt;=n;i++) l[i]=b[(i&lt;&lt;1)-1]=read(),r[i]=b[i&lt;&lt;1]=read(),b[i&lt;&lt;1]++; sort(b+1,b+1+(n&lt;&lt;1)); m=unique(b+1,b+1+(n&lt;&lt;1))-b-1; for(int i=1;i&lt;=n;i++) l[i]=lower_bound(b+1,b+1+m,l[i])-b,r[i]=lower_bound(b+1,b+1+m,r[i]+1)-b; C[0]=f[0]=1; for(int j=1;j&lt;m;j++)&#123; int len=b[j+1]-b[j]; for(int i=1;i&lt;=n;i++) C[i]=1ll*C[i-1]*(len+i-1)%mod*inv[i]%mod; for(int i=n;i;i--) if(l[i]&lt;=j and r[i]&gt;=j+1)&#123; int cnt=1; for(int k=i-1;~k;k--) f[i]=(f[i]+1ll*C[cnt]*f[k])%mod,cnt+=l[k]&lt;=j and r[k]&gt;=j+1; &#125; &#125; for(int i=1;i&lt;=n;i++) ans=(ans+f[i])%mod; printf(&quot;%d\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P3214 [HNOI2011]卡农","slug":"P3214 [HNOI2011]卡农","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.444Z","comments":true,"path":"2022/04/30/P3214 [HNOI2011]卡农/","permalink":"https://starcried.github.io/2022/04/30/P3214%20[HNOI2011]%E5%8D%A1%E5%86%9C/","excerpt":"","text":"P3214 [HNOI2011]卡农题意在集合 ${1,2,\\cdots,n}$ 中选出 $m$ 个非空子集满足： 不存在完全相同的两个集合； 每个元素在所有集合中出现次数之和为偶数。 思路考虑转移，利用容斥方法进行 Dp。设 $f_i$ 表示选了 $i$ 个集合满足条件的方案数： 首先，如果确定了前 $i-1$ 个集合，那么为了满足上面第二个限制这个位置选的集合一定是固定的。前 $i-1$ 个集合的选择方案数是 $A_{2^n-1}^{i-1}$。 上面的方案中有选择了空集的方案。选择空集当且仅当前 $i-1$ 个集合已经是合法方案了，即有 $f_{i-1}$ 个是多计算的，减去即可。 还有选择集合相同的方案数。考虑若有相同的集合那么去掉这两个集合剩下的也是合法的，即 $f_{i-2}$。有 $i-1$ 个位置和 $2^n-1-(i-2)$ 种取法（减去空集和不同的 $i-2$ 个集合），所以总共有 $f_{i-2}(i-1)(2^n-1-(i-2))$ 种，减去即可。 转移式为：$$f_i&#x3D;A_{2^n-1}^{i-1}-f_{i-1}-f_{i-2}(i-1)(2^n-1-(i-2))$$边界条件为 $f_0&#x3D;1$,$f_1&#x3D;0$。 实现123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e6+10,mod=1e8+7; int n,m,pow=1,A[maxn],f[maxn]; inline int fpow(int a,int b)&#123;int ans=1;for(;b;b&gt;&gt;=1,a=1ll*a*a%mod) if(b&amp;1) ans=1ll*ans*a%mod;return ans;&#125; inline void work()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) pow=(pow&lt;&lt;1)%mod; pow=(pow-1+mod)%mod; A[0]=1;for(int i=1;i&lt;=m;i++) A[i]=1ll*A[i-1]*((pow-i+1+mod)%mod)%mod; f[0]=1,f[1]=0; for(int i=2;i&lt;=m;i++) f[i]=(A[i-1]-f[i-1]+mod-1ll*f[i-2]*(i-1)%mod*(pow-i+2+mod)%mod+mod)%mod; int res=1; for(int i=1;i&lt;=m;i++) res=1ll*res*i%mod; printf(&quot;%lld\\n&quot;,1ll*f[m]*fpow(res,mod-2)%mod); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 闲话我搜了下，音阶的意思是从主音到主音的连续音符段，所以一个音阶是若干音符的集合（大概） 所以小余大概是把一个音符分成了一个音阶（","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4168-蒲公英-分块","slug":"P4168-蒲公英-分块","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.446Z","comments":true,"path":"2022/04/30/P4168-蒲公英-分块/","permalink":"https://starcried.github.io/2022/04/30/P4168-%E8%92%B2%E5%85%AC%E8%8B%B1-%E5%88%86%E5%9D%97/","excerpt":"","text":"蒲公英暴力分块思想。分块的思想与莫队相同。它能将时间和空间复杂度均摊XDbelong表示所属区块，num维护区间颜色出现次数，maxx维护区间max值。查询时只需要比较两端的区块即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;utility&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;typedef pair&lt;int,int&gt; pii;namespace star&#123; const int maxn=40010,block=1500,maxm=50; int n,m,a[maxn],cnt,cn=1; int belong[maxn],beg[maxm],end[maxm],num[maxm][maxm][maxn],maxx[maxm][maxm]; int ed[maxn],time=0; int color[maxn],id[maxn]; int con[maxn]; pii p[maxn]; inline void solve()&#123; int l=0,r=0,ans=0; while(m--)&#123; time++; l=(read()+ans-1)%n+1,r=(read()+ans-1)%n+1; if(l&gt;r)swap(l,r); ans=0; int mx=0,mxid=0; if(belong[l]==belong[r])&#123; for(int i=l;i&lt;=r;i++) &#123; if(ed[id[i]]!=time)con[id[i]]=0,ed[id[i]]=time; con[id[i]]++; if(con[id[i]]&gt;mx or (con[id[i]]==mx and id[i]&lt;mxid))mxid=id[i],mx=con[mxid]; &#125; ans=color[mxid]; printf(&quot;%d\\n&quot;,ans); &#125;else&#123; int L=belong[l]+1,R=belong[r]-1; mxid=maxx[L][R];mx=num[L][R][mxid]; for(int i=l;i&lt;beg[L];i++) &#123; if(ed[id[i]]!=time)con[id[i]]=0,ed[id[i]]=time; con[id[i]]++; if(con[id[i]]+num[L][R][id[i]]&gt;mx or (con[id[i]]+num[L][R][id[i]]==mx and id[i]&lt;mxid))mxid=id[i],mx=con[mxid]+num[L][R][id[i]]; &#125; for(int i=end[R]+1;i&lt;=r;i++) &#123; if(ed[id[i]]!=time)con[id[i]]=0,ed[id[i]]=time; con[id[i]]++; if(con[id[i]]+num[L][R][id[i]]&gt;mx or (con[id[i]]+num[L][R][id[i]]==mx and id[i]&lt;mxid))mxid=id[i],mx=con[mxid]+num[L][R][id[i]]; &#125; ans=color[mxid]; printf(&quot;%d\\n&quot;,ans); &#125; &#125; &#125; inline void makeblock()&#123; beg[1]=1; cn=1; for(int i=1;i&lt;=n;i++)&#123; if(!(i%block))&#123; end[cn]=i-1; cn++; beg[cn]=i; &#125; belong[i]=cn; &#125; if(n%block)cn++; end[cn]=n; for (int i = 1; i &lt;= cn; i++) for (int j = i; j &lt;= cn; j++) &#123; int makk = 0; for (int k = beg[i]; k &lt;= end[j]; k++) num[i][j][id[k]]++; for (int k = 1; k &lt;= cnt; k++)&#123; if(makk&lt;num[i][j][k]) &#123; makk=num[i][j][k]; maxx[i][j]=k; &#125; &#125; &#125; &#125; inline void cried() &#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) p[i]=make_pair(read(),i); sort(p+1,p+n+1); for(int i=1;i&lt;=n;i++)&#123; if(p[i].first!=p[i-1].first or i==1)cnt++; color[cnt]=p[i].first; id[p[i].second]=cnt; &#125; makeblock(); solve(); &#125;&#125;int main()&#123; star::cried(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4169-CDQ分治 K-D tree（三维偏序）-天使玩偶","slug":"P4169-CDQ分治 K-D tree（三维偏序）-天使玩偶","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.446Z","comments":true,"path":"2022/04/30/P4169-CDQ分治 K-D tree（三维偏序）-天使玩偶/","permalink":"https://starcried.github.io/2022/04/30/P4169-CDQ%E5%88%86%E6%B2%BB%20K-D%20tree%EF%BC%88%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F%EF%BC%89-%E5%A4%A9%E4%BD%BF%E7%8E%A9%E5%81%B6/","excerpt":"","text":"P4169-CDQ分治&#x2F;K-D tree（三维偏序）-天使玩偶这是一篇两种做法都有的题解 题外话我写吐了…… 本着不看题解的原则，没写（不会）K-D tree，就写了个cdq分治的做法。下面是我的写题步骤： 想着树状数组维护不了区间最值，于是写了线段树，因为一个**的错误调了几个小时； cdq只写了两个方向。显然是错的，因为没考虑修改。所以挂了； 加上另外两个方向，正确性终于ok，兴高采烈地交上去然后TLE； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;char buf[1&lt;&lt;23],*p1=buf,*p2=buf,obuf[1&lt;&lt;23],*O=obuf;#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;void print(long long x) &#123; if(x&gt;9) print(x/10); *O++=x%10+&#x27;0&#x27;;&#125;namespace star&#123; const int maxn=6e5+10,INF=0x3f3f3f3f; int n,m,ans[maxn],LN=0,RN=1000006; struct query&#123; int x,y,id,op; &#125;q[maxn&lt;&lt;1]; inline bool cmp1(query a,query b)&#123;return a.x&lt;b.x;&#125; inline bool cmp2(query a,query b)&#123;return a.x&gt;b.x;&#125; struct SegmentTree&#123; #define ls (ro&lt;&lt;1) #define rs (ro&lt;&lt;1|1) struct tree&#123; int l,r,mx; &#125;e[16000005]; void build(int ro,int l,int r)&#123; e[ro].l=l,e[ro].r=r; if(l==r)&#123; e[ro].mx=-INF;return; &#125; int mid=l+r&gt;&gt;1; build(ls,l,mid); build(rs,mid+1,r); e[ro].mx=max(e[ls].mx,e[rs].mx); &#125; void update(int ro,int k,int v)&#123; int l=e[ro].l,r=e[ro].r; if(l==r)&#123; e[ro].mx=max(e[ro].mx,v);return; &#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)update(ls,k,v); else update(rs,k,v); e[ro].mx=max(e[ls].mx,e[rs].mx); &#125; void update2(int ro,int k,int v)&#123; int l=e[ro].l,r=e[ro].r; if(l==r)&#123; e[ro].mx=v;return; &#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)update2(ls,k,v); else update2(rs,k,v); e[ro].mx=max(e[ls].mx,e[rs].mx); &#125; int query(int ro,int x,int y)&#123; int l=e[ro].l,r=e[ro].r; if(l==x and r==y)return e[ro].mx; int mid=l+r&gt;&gt;1; if(y&lt;=mid)return query(ls,x,y); else if(x&gt;mid)return query(rs,x,y); else return max(query(ls,x,mid),query(rs,mid+1,y)); &#125; #undef ls #undef rs &#125;T; void cdq(int l,int r)&#123; if(l==r)return; int mid=l+r&gt;&gt;1; cdq(l,mid),cdq(mid+1,r); int i,j; sort(q+l,q+mid+1,cmp1),sort(q+mid+1,q+r+1,cmp1); for(i=mid+1,j=l;i&lt;=r;i++)&#123; while(q[j].x&lt;=q[i].x and j&lt;=mid)&#123; if(!q[j].op) T.update(1,q[j].y,q[j].x+q[j].y);j++; &#125; if(q[i].op)ans[q[i].id]=min(ans[q[i].id],q[i].x+q[i].y-T.query(1,LN,q[i].y)); &#125; for(i=l;i&lt;j;i++) T.update2(1,q[i].y,-INF); for(i=mid+1,j=l;i&lt;=r;i++)&#123; while(q[j].x&lt;=q[i].x and j&lt;=mid)&#123; if(!q[j].op) T.update(1,q[j].y,q[j].x-q[j].y);j++; &#125; if(q[i].op)ans[q[i].id]=min(ans[q[i].id],q[i].x-q[i].y-T.query(1,q[i].y,RN)); &#125; for(i=l;i&lt;j;i++) T.update2(1,q[i].y,-INF); sort(q+l,q+mid+1,cmp2),sort(q+mid+1,q+r+1,cmp2); for(i=mid+1,j=l;i&lt;=r;i++)&#123; while(q[j].x&gt;=q[i].x and j&lt;=mid)&#123; if(!q[j].op) T.update(1,q[j].y,q[j].y-q[j].x);j++; &#125; if(q[i].op)ans[q[i].id]=min(ans[q[i].id],q[i].y-q[i].x-T.query(1,LN,q[i].y)); &#125; for(i=l;i&lt;j;i++) T.update2(1,q[i].y,-INF); for(i=mid+1,j=l;i&lt;=r;i++)&#123; while(q[j].x&gt;=q[i].x and j&lt;=mid)&#123; if(!q[j].op) T.update(1,q[j].y,-q[j].y-q[j].x);j++; &#125; if(q[i].op)ans[q[i].id]=min(ans[q[i].id],-q[i].y-q[i].x-T.query(1,q[i].y,RN)); &#125; for(i=l;i&lt;j;i++) T.update2(1,q[i].y,-INF); &#125; inline void work()&#123; n=read(),m=read(); memset(ans,INF,sizeof ans); for(int i=1;i&lt;=n;i++) q[i].x=read(),q[i].y=read(),LN=min(LN,q[i].y),RN=max(RN,q[i].y),q[i].op=0; for(int i=n+1;i&lt;=n+m;i++)&#123; q[i].op=(read()-1); q[i].id=q[i-1].id+q[i].op; q[i].x=read(),q[i].y=read(); &#125; int mx=q[n+m].id; T.build(1,LN,RN); cdq(1,n+m); for(int i=1;i&lt;=mx;i++)print(ans[i]),*O++=&#x27;\\n&#x27;; fwrite(obuf,O-obuf,1,stdout); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 原以为是线段树常数过大，学习了树状数组解法然后WA了； 改回了线段树，把sort换成了merge，又WA； 只有最后一个办法了：改成树状数组+merge，要是再挂我就当场去学KD-tree. 写挂了，我滚去学K-D tree了。 K-D treeK-D tree是一种维护多维空间点的数据结构，在这道题上是两维所以也叫作2-D tree。具体实现方式是将每个节点所在的区域切割递归建成二叉树，每一个树上的节点代表一个实际的结点，但又存储着选择这个结点时的区域大小。 建树KDT在建树时，为了让它保持平衡，我们需要尽量选择所在空间维度的中位数，所以在保证时间复杂度正确的情况下我们可以使用nth_element函数，其作用是在线性时间内将一个数摆到它排序后应该在的位置，而将比它小的放在左边，比他大的放在右边（不重载运算符情况下是从小到大），但不是有序排列。 1234567891011121314151617int build(int l,int r)&#123; if(l&gt;r)return 0; int mid=l+r&gt;&gt;1; double av[2],va[2]; av[0]=av[1]=va[0]=va[1]=0; for(int i=l;i&lt;=r;i++)av[0]+=e[g[i]].x,av[1]+=e[g[i]].y; av[0]/=(r-l+1),av[1]/=(r-l+1); for(int i=l;i&lt;=r;i++) va[0]+=(av[0]-e[g[i]].x)*(av[0]-e[g[i]].x), va[1]+=(av[1]-e[g[i]].y)*(av[1]-e[g[i]].y);//寻找应该切割的维度 if(va[0]&gt;va[1])nth_element(g+l,g+mid,g+r+1,cmpx),e[g[mid]].d=1;//d是维度 else nth_element(g+l,g+mid,g+r+1,cmpy),e[g[mid]].d=2; e[g[mid]].ls=build(l,mid-1); e[g[mid]].rs=build(mid+1,r); maintain(g[mid]);//pushup函数，更新节点信息。 return g[mid];&#125; 插入从root递归下去查找，按照当前节点所在维度向下插入，到达空节点时新建节点存储信息。 注意：当插入节点过多时KDT有可能失衡，此时我们需要将它拍扁重建（pia~）（因为KDT的结构，好像没有别的方法了？）$^ ①$ 1234567891011121314void insert(int &amp;x,int k)&#123; if(!x)&#123; x=k,maintain(k);return; &#125; if(e[x].d==1)&#123; if(e[k].x&lt;=e[x].x)insert(e[x].ls,k); else insert(e[x].rs,k); &#125;else&#123; if(e[k].y&lt;=e[x].y)insert(e[x].ls,k); else insert(e[x].rs,k); &#125; maintain(x); if(bad(x)) rebuild(x);//pia&#125; 12inline bool bad(int x)&#123;return 0.9*e[x].siz&lt;=(double)max(e[e[x].ls].siz,e[e[x].rs].siz);&#125;//0.9为拍扁的阈值，越大拍扁越不频繁，但有可能失衡，按照实际情况调整。注意，实测其为0.8时会爆栈。 1234567891011void getson(int x)&#123; if(!x)return; getson(e[x].ls); g[++t]=x; getson(e[x].rs);&#125;inline void rebuild(int &amp;x)&#123; t=0; getson(x);//找到所有被拍扁的节点（其实没必要，新建节点也行） x=build(1,t);&#125; 查询此题要求查询距离关键点最近的点的距离。 注意：我们在查询下传的时候需要比较的是区块位置距离关键点的距离，而统计答案是按照当前节点的坐标统计。 1234567891011121314int ans=INF;//请不要学鄙人用全局变量传参，我被人嘴了void query(int x)&#123; cmin(ans,dist(x)); int dl=INF,dr=INF; if(e[x].ls)dl=getdis(e[x].ls); if(e[x].rs)dr=getdis(e[x].rs); if(dl&lt;dr)&#123; if(dl&lt;ans)query(e[x].ls); if(dr&lt;ans)query(e[x].rs); &#125;else&#123; if(dr&lt;ans)query(e[x].rs); if(dl&lt;ans)query(e[x].ls); &#125;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define cmin(i,j) (i)=min((i),(j))#define cmax(i,j) (i)=max((i),(j))using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=6e5+10,INF=0x3f3f3f3f; int n,m,rt,tot,qx,qy,g[maxn],t; struct node&#123; int x,y,ls,rs,l[2],r[2],siz,d; &#125;e[maxn]; inline bool cmpx(int a,int b)&#123;return e[a].x&lt;e[b].x;&#125; inline bool cmpy(int a,int b)&#123;return e[a].y&lt;e[b].y;&#125; inline void maintain(int x)&#123; e[x].siz=e[e[x].ls].siz+e[e[x].rs].siz+1; e[x].l[0]=e[x].r[0]=e[x].x; e[x].l[1]=e[x].r[1]=e[x].y; if(e[x].ls) cmin(e[x].l[0],e[e[x].ls].l[0]),cmax(e[x].r[0],e[e[x].ls].r[0]), cmin(e[x].l[1],e[e[x].ls].l[1]),cmax(e[x].r[1],e[e[x].ls].r[1]); if(e[x].rs) cmin(e[x].l[0],e[e[x].rs].l[0]),cmax(e[x].r[0],e[e[x].rs].r[0]), cmin(e[x].l[1],e[e[x].rs].l[1]),cmax(e[x].r[1],e[e[x].rs].r[1]); &#125; int build(int l,int r)&#123; if(l&gt;r)return 0; int mid=l+r&gt;&gt;1; double av[2],va[2]; av[0]=av[1]=va[0]=va[1]=0; for(int i=l;i&lt;=r;i++)av[0]+=e[g[i]].x,av[1]+=e[g[i]].y; av[0]/=(r-l+1),av[1]/=(r-l+1); for(int i=l;i&lt;=r;i++) va[0]+=(av[0]-e[g[i]].x)*(av[0]-e[g[i]].x), va[1]+=(av[1]-e[g[i]].y)*(av[1]-e[g[i]].y); if(va[0]&gt;va[1])nth_element(g+l,g+mid,g+r+1,cmpx),e[g[mid]].d=1; else nth_element(g+l,g+mid,g+r+1,cmpy),e[g[mid]].d=2; e[g[mid]].ls=build(l,mid-1); e[g[mid]].rs=build(mid+1,r); maintain(g[mid]); return g[mid]; &#125; void getson(int x)&#123; if(!x)return; getson(e[x].ls); g[++t]=x; getson(e[x].rs); &#125; inline void rebuild(int &amp;x)&#123; t=0; getson(x); x=build(1,t); &#125; inline bool bad(int x)&#123;return 0.9*e[x].siz&lt;=(double)max(e[e[x].ls].siz,e[e[x].rs].siz);&#125; void insert(int &amp;x,int k)&#123; if(!x)&#123; x=k,maintain(k);return; &#125; if(e[x].d==1)&#123; if(e[k].x&lt;=e[x].x)insert(e[x].ls,k); else insert(e[x].rs,k); &#125;else&#123; if(e[k].y&lt;=e[x].y)insert(e[x].ls,k); else insert(e[x].rs,k); &#125; maintain(x); if(bad(x)) rebuild(x); &#125; inline int getdis(int x)&#123;return max(0,qx-e[x].r[0])+max(0,e[x].l[0]-qx)+max(0,qy-e[x].r[1])+max(0,e[x].l[1]-qy);&#125; inline int dist(int x)&#123;return abs(qx-e[x].x)+abs(qy-e[x].y);&#125; int ans; void query(int x)&#123; cmin(ans,dist(x)); int dl=INF,dr=INF; if(e[x].ls)dl=getdis(e[x].ls); if(e[x].rs)dr=getdis(e[x].rs); if(dl&lt;dr)&#123; if(dl&lt;ans)query(e[x].ls); if(dr&lt;ans)query(e[x].rs); &#125;else&#123; if(dr&lt;ans)query(e[x].rs); if(dl&lt;ans)query(e[x].ls); &#125; &#125; inline void work()&#123; n=read(),m=read(); while(n--)&#123; e[++tot].x=read(),e[tot].y=read(); g[tot]=tot; &#125; rt=build(1,tot); while(m--)&#123; if(read()==1)&#123; e[++tot].x=read(),e[tot].y=read(); insert(rt,tot); &#125;else&#123; qx=read(),qy=read();ans=INF;query(rt); printf(&quot;%d\\n&quot;,ans); &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 注释①K-D tree的重建方式含争议。事实上，作者是从OIwiki上学习的K-D tree写法，而在当页下方评论区中有人提出KDT不应该像替罪羊一样按照阈值重构，因为这样的话会在极端情况下多次重构导致时间复杂度退化。他提出，应该每插入$\\sqrt n$个点后将全树进行重构，这样保证时间复杂度最劣情况下全部插入为$O(n\\sqrt n)$，查询最劣情况下单次为$O(\\sqrt n)$。但是大家不用担心，愚以为大多数情况下本人这种写法的均摊时间复杂度是比另一种优的，实在不行可以适当调整阈值。欢迎大家激烈对线。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4074 [WC2013]糖果公园","slug":"P4074 [WC2013]糖果公园","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.445Z","comments":true,"path":"2022/04/30/P4074 [WC2013]糖果公园/","permalink":"https://starcried.github.io/2022/04/30/P4074%20[WC2013]%E7%B3%96%E6%9E%9C%E5%85%AC%E5%9B%AD/","excerpt":"","text":"P4074 [WC2013]糖果公园Tag：树上带修莫队 题意：树上每个点有一种糖果，求$\\sum_c\\sum_{i&#x3D;1}^{cnt_c}v_c*w_i$ 其中c为糖果种类，$cnt_c$其为出现次数。 思路离线树上带修莫队。 先进行树上分块。分块内的询问按照出发点、终止点、询问id优先级依次递减排序。 对于树上莫队，其实就是在欧拉序上莫队。因为欧拉序的性质，即每个节点子树内的节点一定会经过两次，我们就可以用一个括号序列的方式在莫队时消除子树内无用节点的影响。 具体来说，序列长度为2*n，每一个节点出入队时我们异或它是否在队中即可。也就是记录每个点出队和入队的时间戳，然后在序列上修改。 注意，对于LCA其实在欧拉序时是没有包括的，所以我们需要单独求一下LCA的影响。但是如果一个端点本身就是LCA就不用啦。 但是！用指针实现也太low了，我们直接利用它的树形结构莫队就行（实际上就是我看错了题解） 代码分块和排序1234567891011121314151617181920 int dfs(int x,int f)&#123;//毒瘤的树分块而非序列分块 int siz=0; fa[x][0]=f;dep[x]=dep[f]+1; dfn[x]=++tim; for(int i=0;i&lt;=20;i++)fa[x][i+1]=fa[fa[x][i]][i]; for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==f)continue; siz+=dfs(u,x); if(siz&gt;=_nsiz)&#123; _n++; while(siz)belong[st[top--]]=_n,siz--; &#125; &#125; st[++top]=x; return siz+1; &#125;//---------------- ++_n; while(top)belong[st[top--]]=_n; 1inline bool operator &lt; (const query&amp;zp)const &#123;return belong[u]&lt;belong[zp.u] or (belong[u]==belong[zp.u] and (belong[v]&lt;belong[zp.v] or (belong[v]==belong[zp.v] and id&lt;zp.id)));&#125;//运算符版 莫队1234567891011inline void reverse(const int&amp; x,ll &amp;ans)&#123;//将进队的出队，出队的进队。 if(vis[x])ans-=1ll*w[num[color[x]]]*v[color[x]],num[color[x]]--; else num[color[x]]++,ans+=1ll*w[num[color[x]]]*v[color[x]]; vis[x]^=1;&#125;inline void solve(int x,int y,ll &amp;ans)&#123;//直接利用树形结构跳father，更新答案，反正括号序列也就是翻转。 while(x!=y)&#123; if(dep[x]&gt;dep[y])reverse(x,ans),x=fa[x][0]; else reverse(y,ans),y=fa[y][0]; &#125;&#125; 1234567891011121314151617181920for(int i=1;i&lt;=cntq;i++)&#123; while(now&lt;cntm and mo[now+1].id&lt;=q[i].id)&#123;//处理时间问题，只能暴力消除影响。 now++; if(vis[mo[now].pos])ans-=w[num[color[mo[now].pos]]]*v[color[mo[now].pos]],num[color[mo[now].pos]]--; color[mo[now].pos]=mo[now].aft; if(vis[mo[now].pos])num[color[mo[now].pos]]++,ans+=1LL*w[num[color[mo[now].pos]]]*v[color[mo[now].pos]]; &#125; while(now&gt;=1 and mo[now].id&gt;=q[i].id)&#123; if(vis[mo[now].pos])ans-=w[num[color[mo[now].pos]]]*v[color[mo[now].pos]],num[color[mo[now].pos]]--; color[mo[now].pos]=mo[now].bef;//注意变成了什么（我就是傻 if(vis[mo[now].pos])num[color[mo[now].pos]]++,ans+=1LL*w[num[color[mo[now].pos]]]*v[color[mo[now].pos]]; now--; &#125; if(i==1)solve(q[i].u,q[i].v,ans); else solve(q[i].u,q[i-1].u,ans),solve(q[i].v,q[i-1].v,ans);//保证继承答案连续 int lca=LCA(q[i].u,q[i].v); reverse(lca,ans); q[i].ans=ans; reverse(lca,ans);//单独计算，最后要消除影响。不要被继承。&#125; 事实证明，这种写法是真毒瘤，开了O2才勉强能过。 全代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; typedef long long ll; int n,m,Q,_n,fa[maxn][23],_nsiz,dfn[maxn],dep[maxn],c[maxn],color[maxn]; ll v[maxn],w[maxn]; int ecnt,tim,st[maxn&lt;&lt;1],belong[maxn],top,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1]; struct query&#123; int u,v,id; ll ans; inline bool operator &lt; (const query&amp;zp)const &#123;return belong[u]&lt;belong[zp.u] or (belong[u]==belong[zp.u] and (belong[v]&lt;belong[zp.v] or (belong[v]==belong[zp.v] and id&lt;zp.id)));&#125; &#125;q[maxn]; inline bool cmp(query a,query b)&#123;return a.id&lt;b.id;&#125; struct modify&#123; int pos,bef,aft,id; &#125;mo[maxn&lt;&lt;1]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt; &#125; int dfs(int x,int f)&#123; int siz=0; fa[x][0]=f;dep[x]=dep[f]+1; dfn[x]=++tim; for(int i=0;i&lt;=20;i++)fa[x][i+1]=fa[fa[x][i]][i]; for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==f)continue; siz+=dfs(u,x); if(siz&gt;=_nsiz)&#123; _n++; while(siz)belong[st[top--]]=_n,siz--; &#125; &#125; st[++top]=x; return siz+1; &#125; inline int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); for(int i=20;i+1;i--)if(dep[fa[x][i]]&gt;=dep[y])x=fa[x][i]; if(x==y)return x; for(int i=20;i+1;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125; bool vis[maxn]; int num[maxn]; inline void reverse(const int&amp; x,ll &amp;ans)&#123; if(vis[x])ans-=1ll*w[num[color[x]]]*v[color[x]],num[color[x]]--; else num[color[x]]++,ans+=1ll*w[num[color[x]]]*v[color[x]]; vis[x]^=1; &#125; inline void solve(int x,int y,ll &amp;ans)&#123; while(x!=y)&#123; if(dep[x]&gt;dep[y])reverse(x,ans),x=fa[x][0]; else reverse(y,ans),y=fa[y][0]; &#125; &#125; inline void work()&#123; n=read(),m=read(),Q=read(); _nsiz=pow(n,0.666666666); for(int i=1;i&lt;=m;i++)v[i]=read(); for(int i=1;i&lt;=n;i++)w[i]=read(); for(int i=1;i&lt;n;i++)addedge(read(),read()); for(int i=1;i&lt;=n;i++)c[i]=color[i]=read(); int cntq=0,cntm=0,x; for(int i=1;i&lt;=Q;i++)&#123; if(read())q[++cntq].id=i,q[cntq].u=read(),q[cntq].v=read(); else mo[++cntm].id=i,mo[cntm].bef=c[(x=read())],mo[cntm].pos=x,mo[cntm].aft=c[x]=read(); &#125; dfs(1,0); for(int i=1;i&lt;=cntq;i++)if(dfn[q[i].v]&lt;dfn[q[i].u])swap(q[i].u,q[i].v);//对于这种写法这句其实可有也可无了。这种写法的一个好处就是不交换不影响正确性。 ++_n; while(top)belong[st[top--]]=_n; sort(q+1,q+1+cntq); int now=0; long long ans=0; for(int i=1;i&lt;=cntq;i++)&#123; while(now&lt;cntm and mo[now+1].id&lt;=q[i].id)&#123; now++; if(vis[mo[now].pos])ans-=w[num[color[mo[now].pos]]]*v[color[mo[now].pos]],num[color[mo[now].pos]]--; color[mo[now].pos]=mo[now].aft; if(vis[mo[now].pos])num[color[mo[now].pos]]++,ans+=1LL*w[num[color[mo[now].pos]]]*v[color[mo[now].pos]]; &#125; while(now&gt;=1 and mo[now].id&gt;=q[i].id)&#123; if(vis[mo[now].pos])ans-=w[num[color[mo[now].pos]]]*v[color[mo[now].pos]],num[color[mo[now].pos]]--; color[mo[now].pos]=mo[now].bef; if(vis[mo[now].pos])num[color[mo[now].pos]]++,ans+=1LL*w[num[color[mo[now].pos]]]*v[color[mo[now].pos]]; now--; &#125; if(i==1)solve(q[i].u,q[i].v,ans); else solve(q[i].u,q[i-1].u,ans),solve(q[i].v,q[i-1].v,ans); int lca=LCA(q[i].u,q[i].v); reverse(lca,ans); q[i].ans=ans; reverse(lca,ans); &#125; sort(q+1,q+1+cntq,cmp); for(int i=1;i&lt;=cntq;i++)printf(&quot;%lld\\n&quot;,q[i].ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 总结写了个假的（gxy称之为非主流）树上莫队。再写一道免得脑子了装着奇怪的东西。 因为写法毒瘤所以#define int long long会T飞。 大家千万不要学非主流","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4293 [WC2010]能量场","slug":"P4293 [WC2010]能量场","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.447Z","comments":true,"path":"2022/04/30/P4293 [WC2010]能量场/","permalink":"https://starcried.github.io/2022/04/30/P4293%20[WC2010]%E8%83%BD%E9%87%8F%E5%9C%BA/","excerpt":"","text":"P4293 [WC2010]能量场题意给你 $n$ 个粒子，每个粒子有两个权值 $m_i,c_i$ 每个相邻有序对 $(a,b)$ 会产生 $m_am_b(c_a-c_b)$ 的贡献。现让你处理两个问题： 找出一个有序对使贡献最大。 找出一个序列成环后贡献和最大。 思路我们将贡献转化一下：$$m_am_b(c_a-c_b)&#x3D;m_ac_am_b-m_bc_bm_a$$那么这就形成了一个叉积的形式。即将每个点 $i$ 转化为 $x&#x3D;m_ic_i,y&#x3D;m_i$ 的向量。 那么第一问就等价于求叉积最大的两个向量。具体怎么求后面再说。 那么第二问就是将若干个向量依次首尾相接地叉积和。因为所有点都在第一象限，所以这等价于求一个多边形的面积的两倍。（不会的可以自己根据叉积意义推下） 那么我们让贡献和最大，相当于求一个构成多边形面积最大的序列——凸包。于是我们求一下凸包就行了。 至于第一问，我们要快速得到两个点叉积的最大值，发现叉积最大的两个点一定在凸包上。并且发现，顺次遍历所有点并用一个指针记录另一个点的位置，发现叉积的绝对值是单调的。那么我们用类似半平面交的方法扫两遍凸包就行了，即正反各扫一遍（因为边界条件可能错误，但扫两遍一定会统计完全）。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;namespace star&#123; const int maxn=5e4+10; int n,m=1,ans,Ans[2],q[maxn]; struct vec&#123; double x,y; int id; vec(double x=0,double y=0,int id=0):x(x),y(y),id(id)&#123;&#125; vec operator + (const vec &amp;a) const &#123;return vec(x+a.x,y+a.y);&#125; vec operator - (const vec &amp;a) const &#123;return vec(x-a.x,y-a.y);&#125; double operator * (const vec &amp;a) const &#123;return x*a.y-y*a.x;&#125; bool operator &lt; (const vec &amp;a) const &#123;return x&lt;a.x or (x==a.x and y&lt;a.y);&#125; &#125;a[maxn]; inline void work()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; double a,b; scanf(&quot;%lf%lf&quot;,&amp;a,&amp;b); star::a[i]=vec(a*b,a,i); &#125; sort(a+1,a+1+n); q[1]=1; for(int i=2;i&lt;=n;i++)&#123; while(m&gt;1 and (a[q[m]]-a[q[m-1]])*(a[i]-a[q[m]])&lt;=0) m--; q[++m]=i; &#125; int tmp=m; for(int i=n-1;i;i--)&#123; while(m&gt;tmp and (a[q[m]]-a[q[m-1]])*(a[i]-a[q[m]])&lt;=0) m--; q[++m]=i; &#125; for(int i=1,j=2;i&lt;=m;i++)&#123; while(fabs(a[q[i]]*a[q[j]])&lt;fabs(a[q[i]]*a[q[j+1]])) j=j%(m-1)+1; double res=a[q[i]]*a[q[j]]; if(ans&lt;fabs(res))&#123; ans=fabs(res); if(res&gt;0)Ans[0]=i,Ans[1]=j; else Ans[0]=j,Ans[1]=i; &#125; &#125; for(int i=m,j=m-1;i;i--)&#123; while(fabs(a[q[i]]*a[q[j]])&lt;fabs(a[q[i]]*a[q[j==1?m-1:j-1]])) j=j==1?m-1:j-1; double res=a[q[i]]*a[q[j]]; if(ans&lt;fabs(res))&#123; ans=fabs(res); if(res&gt;0)Ans[0]=i,Ans[1]=j; else Ans[0]=j,Ans[1]=i; &#125; &#125; printf(&quot;%d %d\\n%d\\n&quot;,a[q[Ans[0]]].id,a[q[Ans[1]]].id,m-1); for(int i=1;i&lt;m;i++) printf(&quot;%d &quot;,a[q[i]].id); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 补充洛谷的另外一篇题解在代码在数据较小时进行了特判以水过第一个测试点，实际上如果不加特判其根本无法通过此题，原因很可能就是没有进行反方向统计答案。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4334 [COI2007] Policija","slug":"P4334 [COI2007] Policija","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.447Z","comments":true,"path":"2022/04/30/P4334 [COI2007] Policija/","permalink":"https://starcried.github.io/2022/04/30/P4334%20[COI2007]%20Policija/","excerpt":"","text":"P4334 [COI2007] Policija题意一个无重边的无向图，每次询问删掉一条边或删掉一个点后两个点是否联通。 思路连通性问题，我们可以考虑使用广义圆方树解决。 对于删掉一个点的情况： 我们先跑 tarjan 建出圆方树。如何判断两点在删去一个点后在树上的连通性？当且仅当被删去的点在两点间的路径上。根据圆方树的性质，如果被删点在一个点双连通分量中，它是符合上面的判断条件的。 所以，我们只需要建出圆方树，判断这个点是否在询问的两点间的路径上就行了。 对于删掉一条边的情况： 考虑我们建出来的广义圆方树是一种怎样的形态。它一定是圆方点交错的形式。换句话说，一条边若不在点双连通分量内，它就会变成一个方点，并连接其原来的两个点。 换句话说，我们把一条边转化成了一个点。于是我们就可以像上面处理点一样处理了。 实现判断一个点是否在两点路径上，我们可以用树剖实现。具体来讲，在跳LCA的过程中判断被删点是否在起终点之间，我们用链首和深度判断即可。 由于题目查询边的给出方式约束，我们可以用 map 实现查询边是否在点双内。代码中，minmax 函数为 C++11 语法，其返回值为一个排好序后的 pair 。 整体时间复杂度为 $O(n+q(\\log n+\\log m))$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;map&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=2e5+10,maxm=5e5+10; typedef pair&lt;int,int&gt; pii; int n,m; struct gragh&#123; int ecnt,head[maxn],to[maxm&lt;&lt;1],nxt[maxm&lt;&lt;1]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt; &#125; &#125;G1,G2; int tot,cnt,st[maxn],dfn[maxn],low[maxn]; map&lt;pii,int&gt; mp; void tarjan(int x,int f)&#123; dfn[x]=low[x]=++tot; st[++st[0]]=x; for(int i=G1.head[x];i;i=G1.nxt[i])&#123; int u=G1.to[i]; if(u==f)continue; if(!dfn[u])&#123; tarjan(u,x); low[x]=min(low[x],low[u]); if(low[u]&gt;=dfn[x])&#123; cnt++; if(low[u]&gt;dfn[x]) mp.insert(make_pair(minmax(u,x),cnt)); G2.addedge(cnt,x); int now=-1; while(now^u) now=st[st[0]--],G2.addedge(now,cnt); &#125; &#125;else low[x]=min(low[x],dfn[u]); &#125; &#125; int fa[maxn],dep[maxn],top[maxn],son[maxn],siz[maxn]; void dfs1(int x,int f)&#123; fa[x]=f,dep[x]=dep[f]+1;siz[x]=1; for(int i=G2.head[x];i;i=G2.nxt[i])&#123; int u=G2.to[i]; if(u==f)continue; dfs1(u,x); siz[x]+=siz[u]; if(siz[u]&gt;siz[son[x]])son[x]=u; &#125; &#125; void dfs2(int x,int topf)&#123; top[x]=topf; if(!son[x]) return; dfs2(son[x],topf); for(int i=G2.head[x];i;i=G2.nxt[i])&#123; int u=G2.to[i]; if(u==fa[x] or u==son[x]) continue; dfs2(u,u); &#125; &#125; inline bool LCA(int x,int y,int z)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); if(top[x]==top[z] and dep[z]&lt;=dep[x]) return 1; x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])swap(x,y); if(top[x]==top[z] and dep[z]&gt;=dep[y] and dep[z]&lt;=dep[x]) return 1; return 0; &#125; inline void work()&#123; n=cnt=read(),m=read(); for(int i=1;i&lt;=m;i++) G1.addedge(read(),read()); tarjan(1,0); dfs1(1,0); dfs2(1,1); int Q=read(); while(Q--) if(read()==1)&#123; int x=read(),y=read(); map&lt;pii,int&gt;::iterator it=mp.find(minmax(read(),read())); if(it==mp.end()) puts(&quot;yes&quot;); else puts(LCA(x,y,(*it).second)?&quot;no&quot;:&quot;yes&quot;); &#125;else&#123; int x=read(),y=read(),z=read(); puts(LCA(x,y,z)?&quot;no&quot;:&quot;yes&quot;); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4774-屠龙勇士-扩展中国剩余定理","slug":"P4774-屠龙勇士-扩展中国剩余定理","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.448Z","comments":true,"path":"2022/04/30/P4774-屠龙勇士-扩展中国剩余定理/","permalink":"https://starcried.github.io/2022/04/30/P4774-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","excerpt":"","text":"#屠龙勇士 很久很久以前，巨龙突然出现，带来了灾难带走公主又消失不见。王国十分危险，世间谁最勇敢，一位英雄出现…… 学习于该大佬博客 那么你就是这位英雄，不过不同的是，你面对的是一群巨龙，虽然巨龙都不会攻击；你每次使用的剑一打就爆，虽然每打死一条巨龙的奖励是一把新的剑；巨龙不会因为生命值降为负数而死亡，虽然巨龙会憨憨地回血然后把自己奶死；最重要的是你完成游戏不会获得公主的爱，只会获得参加ION8012的报名机会。你一听到最后一条彻底就失去了兴致，于是写了一个机器人帮你完成任务XD 简单来说，就是求解同余方程组：$$k_ix\\equiv a_i(mod p_i)$$其中i为巨龙个数1-n。然鹅，你会惊讶地发现，如果用扩展中国剩余定理的话，我们只能求解出左项x的系数为1的式子。这对于身经百战的你当然不是问题，一下子就想到了将$k_i$化掉的好方法：原式可化为：$$k_ix + p_iy\\equiv a_i$$用设$g&#x3D;gcd(k_i,p_i)$，那么用扩展欧几里得求出$x’$（一组解），原式可化为$$x\\equiv \\frac{a_i}{g}x′(mod\\frac {p_i}{g}​)$$然后我们就化成了系数为1的情况。我们就可以解辣♪(^∇^*) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;set&gt;#define int long long using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+100; multiset&lt;int &gt;sword; multiset&lt;int &gt;::iterator it; int a[maxn],p[maxn],sw[maxn],n,m; inline void init()&#123; memset(a,0,sizeof a); memset(p,0,sizeof p); memset(sw,0,sizeof sw); sword.clear(); n=read(),m=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=n;i++)p[i]=read(); for(int i=1;i&lt;=n;i++)sw[i]=read(); while(m--)sword.insert(read()); &#125; void exgcd(int a,int b,int&amp; d,int &amp;x,int &amp;y)&#123; if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=(a/b)*x; &#125; inline int mul(int b,int k,int m)&#123; int a=0; for(;k;k&gt;&gt;=1,b=(b&lt;&lt;1)%m) if(k&amp;1)a=(a+b)%m; return a; &#125;//龟速乘，防止溢出 inline int getsword(int i)&#123; it=sword.upper_bound(a[i]); if(it!=sword.begin())--it; int zp=*it; sword.erase(it);sword.insert(sw[i]); return zp; &#125; inline void excrt()&#123; int X,Y,k; int m=1,ans=0,mx=0,G; for(int i=1;i&lt;=n;i++)&#123; k=getsword(i); mx=max(mx,(a[i]-1)/k+1); k%=p[i];a[i]%=p[i]; if(!k&amp;&amp;a[i])&#123;puts(&quot;-1&quot;);return;&#125;//无解 if(!k&amp;&amp;!a[i])continue;//说明此同余方程没有作用，必须跳过 exgcd(k,p[i],G,X,Y); if(a[i]%G)&#123;puts(&quot;-1&quot;);return;&#125; p[i]/=G; a[i]=mul(a[i]/G,(X%p[i]+p[i])%p[i],p[i]); exgcd(m,p[i],G,X,Y); if((a[i]-ans)%G)&#123;puts(&quot;-1&quot;);return;&#125; m=m/G*p[i]; ans=(ans+mul(mul(m/p[i],((a[i]-ans)%m+m)%m,m),(X%m+m)%m,m))%m; &#125; printf(&quot;%lld\\n&quot;,ans&gt;=mx?ans:ans+m*((mx-ans-1)/m+1)); &#125; inline void work()&#123; init(); excrt(); &#125;&#125;signed main()&#123; int t=read(); while(t--)star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4494 [HAOI2018]反色游戏","slug":"P4494 [HAOI2018]反色游戏","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.448Z","comments":true,"path":"2022/04/30/P4494 [HAOI2018]反色游戏/","permalink":"https://starcried.github.io/2022/04/30/P4494%20[HAOI2018]%E5%8F%8D%E8%89%B2%E6%B8%B8%E6%88%8F/","excerpt":"","text":"P4494 [HAOI2018]反色游戏题意给你一个无向图，图上每个点是黑色或者白色。你可以将一条边的两个端点颜色取反。问你有多少种方法每个边至多取反一次使得图上全变成白色的点。 思路若任意一个连通块黑色点的个数为奇数那么无解。 先考虑树的情况。发现如果是树，并且黑点个数为偶数，有且仅有一种方式达到目标。然后发现，对于一个无向图，它的任意一个生成树若有解，那么其他非树边无论是否取反都有且仅有一种情况达到目标，并且充分。所以答案就是 $2^{m-n+1}$。 考虑不联通的情况，每多一个连通块相当于少了一条非树边，所以答案就是 $2^{m-n+cnt( 连通块个数 )}$。 然后考虑对于删除每个点的情况，分为以下几种： 独立点，不与任何其他点联通，判断删去后是否有解； 非割点，判断删去后是否有解。具体来讲，该点为黑点时，当且仅当全局只有一个连通块且正是所属连通块无解时删除后有解。白点时类似。 是割点，判断删去该点后出现的所有连通块是否有解，并且也要判断是否仅有一个连通块无解且正是该点导致无解时删掉后有解。 对于每种情况，按照上面的方式计算一下有解时的新图的答案即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10,mod=1e9+7; int n,m,pow[maxn],in[maxn]; int ecnt,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt,in[a]++ ; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt,in[b]++; &#125; int bel[maxn],dfn[maxn],low[maxn],cut[maxn],cnt[maxn],cntbel[maxn],cutcnt[maxn]; bool col[maxn],unsol[maxn],unsolbel[maxn]; void tarjan(int x,int fa)&#123; bel[x]=bel[0],cutcnt[x]=cnt[x]=col[x]; dfn[x]=low[x]=++dfn[0]; for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=fa) if(!dfn[u]) &#123; tarjan(u,x),low[x]=min(low[x],low[u]); cnt[x]+=cnt[u]; if(dfn[x]&lt;=low[u]) cutcnt[x]+=cnt[u],++cut[x],unsol[x]|=cnt[u]&amp;1; &#125;else low[x]=min(low[x],dfn[u]); cut[x]-=!fa; &#125; inline void work()&#123; memset(head,0,sizeof head),ecnt=bel[0]=0;memset(dfn,0,sizeof dfn),memset(cut,0,sizeof cut),memset(in,0,sizeof in),memset(unsol,0,sizeof unsol); n=read(),m=read(); for(int i=1;i&lt;=m;i++) addedge(read(),read()); for(int c,i=1;i&lt;=n;i++) scanf(&quot;%1d&quot;,&amp;c),col[i]=c; int cntunsol=0; for(int i=1;i&lt;=n;i++) if(!dfn[i]) bel[0]++,tarjan(i,0),cntunsol+=cnt[i]&amp;1,cntbel[bel[0]]=cnt[i],unsolbel[bel[0]]=cntbel[bel[0]]&amp;1; int ans=m-n+bel[0]; printf(&quot;%d &quot;,cntunsol?0:pow[ans]); for(int i=1;i&lt;=n;i++) &#123; if(!in[i]) printf(&quot;%d &quot;,cntunsol^cnt[i]?0:pow[ans]); else if(!cut[i])&#123; if((unsolbel[bel[i]] and !(cntunsol^col[i])) or (!unsolbel[bel[i]] and !cntunsol and !col[i])) printf(&quot;%d &quot;,pow[ans-in[i]+1+cut[i]]); else printf(&quot;0 &quot;); &#125;else if(!unsol[i] and !((cntbel[bel[i]]-cutcnt[i])&amp;1) and !(cntunsol-unsolbel[bel[i]])) printf(&quot;%d &quot;,pow[ans-in[i]+1+cut[i]]); else printf(&quot;0 &quot;); &#125; puts(&quot;&quot;); &#125;&#125;signed main()&#123; star::pow[0]=1; for(int i=1;i&lt;=100000;i++) star::pow[i]=(star::pow[i-1]&lt;&lt;1)%star::mod; int T=read(); while(T--)star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4180 [BJWC2010]严格次小生成树","slug":"P4180 [BJWC2010]严格次小生成树","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.447Z","comments":true,"path":"2022/04/30/P4180 [BJWC2010]严格次小生成树/","permalink":"https://starcried.github.io/2022/04/30/P4180%20[BJWC2010]%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"P4180 [BJWC2010]严格次小生成树P4180 题意求出一个无向联通图的严格次小生成树。严格次小生成树的定义为边权和大于最小生成树的边权和但不存在另一棵生成树的边权和在最小生成树和严格次小生成树之间（不相等）。 思路先求出一颗最小生成树，发现严格次小生成树一定是其断了一条边并加了一条边且边权和的增加量最小。 那么我们继续在最小生成树上做。对于每一条不是最小生成树上的边，求出其两端两点间在最小生成树上路径上的边的最大值。然鹅，如果用倍增LCA找，发现如果求出来的最大值与该边权值相等，那么得出的答案就是不合法的。所以我们还必须维护一个倍增范围内严格次小边权。 然后找到最小的值输出就行啦！ 对于维护严格次小的值，我认为可以先求出最大值，然后比较找出与最大值不等的最大值就是次大值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10,maxm=3e5+10,INF=0x3f3f3f3f3f3f3f3f; int n,m; struct Edge&#123; int u,v,dis; bool is; inline bool operator &lt;(const Edge &amp;zp)const &#123;return dis&lt;zp.dis;&#125; &#125;e[maxm]; int ecnt,head[maxn],to[maxn&lt;&lt;1],Fa[maxn],nxt[maxn&lt;&lt;1],v[maxn&lt;&lt;1],ans=INF,sum,fa[maxn][25],mx[maxn][25],pmx[maxn][25],dep[maxn]; inline int find(int x)&#123;return Fa[x]==x?x:Fa[x]=find(Fa[x]);&#125; inline void addedge(int a,int b,int c)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt,v[ecnt]=c; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt,v[ecnt]=c; &#125; inline void kruskal()&#123; for(int i=1;i&lt;=n;i++)Fa[i]=i; sort(e+1,e+1+m); int cnt=0; for(int i=1;i&lt;=m;i++)&#123; int fx=find(e[i].u),fy=find(e[i].v); if(fx!=fy)&#123; Fa[fx]=fy; addedge(e[i].u,e[i].v,e[i].dis); e[i].is=1; sum+=e[i].dis; if(++cnt==n-1)break; &#125; &#125; &#125; void dfs(int x,int f)&#123; fa[x][0]=f; dep[x]=dep[f]+1; for(int i=0;i&lt;=20;i++)&#123; fa[x][i+1]=fa[fa[x][i]][i]; mx[x][i+1]=max(mx[x][i],mx[fa[x][i]][i]); if(mx[x][i+1]!=mx[x][i])pmx[x][i+1]=max(pmx[x][i+1],mx[x][i]); if(mx[x][i+1]!=mx[fa[x][i]][i])pmx[x][i+1]=max(pmx[x][i+1],mx[fa[x][i]][i]); if(mx[x][i+1]!=pmx[x][i])pmx[x][i+1]=max(pmx[x][i+1],pmx[x][i]); if(mx[x][i+1]!=pmx[fa[x][i]][i])pmx[x][i+1]=max(pmx[x][i+1],pmx[fa[x][i]][i]); &#125; for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==f)continue; mx[u][0]=v[i]; dfs(u,x); &#125; &#125; inline void LCA(int x,int y,int &amp;mxx,const int &amp;MX)&#123; if(dep[x]&lt;dep[y])swap(x,y); for(int i=20;i+1;i--)if(dep[fa[x][i]]&gt;=dep[y])&#123; if(mx[x][i]!=MX)mxx=max(mxx,mx[x][i]); else mxx=max(mxx,pmx[x][i]); x=fa[x][i]; &#125; if(x==y)return; for(int i=20;i+1;i--)if(fa[x][i]!=fa[y][i])&#123; if(mx[x][i]!=MX)mxx=max(mxx,mx[x][i]); else mxx=max(mxx,pmx[x][i]); x=fa[x][i]; if(mx[y][i]!=MX)mxx=max(mxx,mx[y][i]); else mxx=max(mxx,pmx[y][i]); y=fa[y][i]; &#125; if(mx[x][0]!=MX)mxx=max(mxx,mx[x][0]); else mxx=max(mxx,pmx[x][0]); if(mx[y][0]!=MX)mxx=max(mxx,mx[y][0]); else mxx=max(mxx,pmx[y][0]); &#125; inline void work()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++)e[i].u=read(),e[i].v=read(),e[i].dis=read(); kruskal(); dfs(1,0); for(int i=1;i&lt;=m;i++)if(!e[i].is)&#123; int x=e[i].u,y=e[i].v,MX=-INF; LCA(x,y,MX,e[i].dis); ans=min(ans,sum-MX+e[i].dis); &#125; printf(&quot;%lld&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5042 丢失的题面","slug":"P5042 丢失的题面","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.449Z","comments":true,"path":"2022/04/30/P5042 丢失的题面/","permalink":"https://starcried.github.io/2022/04/30/P5042%20%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A2%98%E9%9D%A2/","excerpt":"","text":"P5042 丢失的题面顺序：10 - 1 - 7 - 8 - 9 - 4 - 5 - 6 - 2 - 3 Point 10读入，特判，输出。 读入的英文意思是让选手输出自己的程序本身，这个题的确存在，但是这题并没有 SPJ ，所以特判一下输出输出文件就好了。 C++ 的atoi函数可以让读入的字符串变成数字以完成其他点的任务。 Point 1我和其他聚铑做这个点的过程就十分有趣了。 开始，我们使用了大眼观察法观察了一下这个输出，不知道怎么我就看出了将序列每四个字符划分，然后变成若干以0110开头的长度为 4 的 01 串组。发现这些组的大小都在 3 以内，于是我们在 OEIS 上搜了一下这个序列，居然真的找到了：A007413 它的递推方式是三个元素，每次操作 a-&gt;abc b-&gt;ac c-&gt;b 。这道题中这三个字母分别代表 0110 01101001 和 011010011001 。做了一下，发现是对的。 然后观察文件大小发现输出的字符串长度是 $2^{22}$ 。没细想，写完就过了。 但是为什么是 $2^{22}$ 呢？ 我回头看了一眼，发现输出好像是初始一个 0 字符，每次操作将当前串取反拼接到后面，做 22 次的结果……（鬼知道我当初为啥直接就想每 4 个分组） 然后又看了下 OEIS，发现这个输出本身就是一个数列：A010060。这个序列还有个名字叫做 Thue-Morse Sequence 在wikihow中，叙述了这个序列的几种构造方法，除了上述的两种构造方式之外，还可以直接每次操作 0-&gt;01 1-&gt;10 来构造。 真有趣 但是代码还是用的第一次写的，懒得改了。（by a___) 12345678910111213141516171819202122232425namespace subtask1&#123; int n=22; vector&lt;vector&lt;int&gt;&gt;vec,tmp; string s[4],ans; vector&lt;int&gt;to[4]; inline void main()&#123; int n=20; to[1]=vector&lt;int&gt;(&#123;1,2,3&#125;); to[2]=vector&lt;int&gt;(&#123;1,3&#125;); to[3]=vector&lt;int&gt;(&#123;2&#125;); vec.push_back(std::vector&lt;int&gt;(&#123;1&#125;)); while(n--) &#123; for(auto p:vec) for(auto q:p)tmp.push_back(to[q]); swap(vec,tmp);tmp.clear(); &#125; s[1]=&quot;0110&quot;; s[2]=&quot;01101001&quot;; s[3]=&quot;011010011001&quot;; for(auto p:vec)ans+=s[p.size()]; ans.resize(1&lt;&lt;22); std::cout&lt;&lt;ans&lt;&lt;std::endl; &#125;&#125; Point 7因为 2~6 个点都没有什么思路，直接来看第 7 个点。 观察了一下输入，发现是一个图，而且边没有边权。观察了一下输出，发现输出只有 0 和 INF 两种数字。于是几乎可以确定是判断图上两点间连通性了。 1234567891011121314namespace subtask7&#123; int fa[100005]; int find(int x)&#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125; inline void onion(int x,int y)&#123; x=find(x),y=find(y); if(x!=y) fa[x]=y; &#125; inline void main(int n,int m)&#123; int q=read(); while(n) fa[n]=n,n--; while(m--) onion(read(),read()); while(q--) puts(find(read())==find(read())?&quot;0&quot;:&quot;2139062143&quot;); &#125;&#125; Point 8切完了上面的点，一看这个点也是个图，而且边有边权。大概扫了一下发现这是个随机生成的树，边权也是随的。询问格式是两个点。 再观察输出，发现输出的答案大多都大于 90000。说明是一个答案期望较大的询问。两点间路径和或者乘积不可能，试验了一下异或发现答案溢出 100000，那么或也顺便排除。 傻了吧唧地想了半天，突然有一位聚铑想到，为啥不是最大值呢？ 试了一下果然没错。 12345678910111213141516171819202122232425262728293031323334namespace subtask8&#123; const int maxn=1e5+10; int fa[maxn][21],mx[maxn][21],Q,n=100000; int ecnt,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],v[maxn&lt;&lt;1],dep[maxn]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt;v[ecnt]=v[ecnt-1]=read(); &#125; void dfs(int x,int f)&#123; fa[x][0]=f;dep[x]=dep[f]+1; for(int i=0;i&lt;18;i++) fa[x][i+1]=fa[fa[x][i]][i],mx[x][i+1]=max(mx[x][i],mx[fa[x][i]][i]); for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==f)continue; mx[u][0]=v[i]; dfs(u,x); &#125; &#125; inline int solve(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); int ans=0; for(int i=18;~i;i--) if(dep[fa[x][i]]&gt;=dep[y]) ans=max(ans,mx[x][i]),x=fa[x][i]; if(x==y)return ans; for(int i=18;~i;i--) if(fa[x][i]!=fa[y][i]) ans=max(ans,max(mx[x][i],mx[y][i])),x=fa[x][i],y=fa[y][i]; ans=max(ans,max(mx[x][0],mx[y][0])); return ans; &#125; inline void main()&#123; Q=read(); for(int i=1;i&lt;n;i++) addedge(read(),read()); dfs(1,0); while(Q--) printf(&quot;%d\\n&quot;,solve(read(),read())); &#125;&#125; Point 9观察了一下输入，发现是个图。 观察了一下输出，发现有 INF 的存在，那么询问可能是让答案尽量小，所以盲猜最小瓶颈路。试了一下，果然是。 kruskal 的并查集和路径最大值都可以用前面的板子。（出题人真良心） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051namespace subtask9&#123; const int maxn=100005,INF=2139062143; int Fa[100005],fa[maxn][21],mx[maxn][21]; int find(int x)&#123;return Fa[x]==x?x:Fa[x]=find(Fa[x]);&#125; struct edge&#123; int u,v,val; inline bool operator &lt; (const edge&amp; zp) const &#123;return val&lt;zp.val;&#125; &#125;e[maxn&lt;&lt;1]; int ecnt,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],v[maxn&lt;&lt;1],dep[maxn]; inline void addedge(int a,int b,int c)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;v[ecnt]=c; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt;v[ecnt]=c; &#125; void dfs(int x,int f)&#123; fa[x][0]=f;dep[x]=dep[f]+1; for(int i=0;i&lt;18;i++) fa[x][i+1]=fa[fa[x][i]][i],mx[x][i+1]=max(mx[x][i],mx[fa[x][i]][i]); for(int i=head[x];i;i=nxt[i])&#123; int u=to[i]; if(u==f)continue; mx[u][0]=v[i]; dfs(u,x); &#125; &#125; inline int solve(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); int ans=0; for(int i=18;~i;i--) if(dep[fa[x][i]]&gt;=dep[y]) ans=max(ans,mx[x][i]),x=fa[x][i]; if(x==y)return ans; for(int i=18;~i;i--) if(fa[x][i]!=fa[y][i]) ans=max(ans,max(mx[x][i],mx[y][i])),x=fa[x][i],y=fa[y][i]; ans=max(ans,max(mx[x][0],mx[y][0])); return ans; &#125; inline void main()&#123; read();int Q=read(); for(int i=1;i&lt;=100000;i++) Fa[i]=i,e[i].u=read(),e[i].v=read(),e[i].val=read(); sort(e+1,e+100001); for(int i=1;i&lt;=100000;i++)&#123; int u=find(e[i].u),v=find(e[i].v); if(u!=v)&#123; Fa[u]=v; addedge(e[i].u,e[i].v,e[i].val); &#125; &#125; for(int i=1;i&lt;=50000;i++) if(!dep[i]) dfs(i,0); while(Q--)&#123; int x=read(),y=read(); if(find(x)!=find(y))printf(&quot;%d\\n&quot;,INF); else printf(&quot;%d\\n&quot;,solve(x,y)); &#125; &#125;&#125; Point 4后面的全做完了，回头看一眼 01 串和 012 串，没啥思路，直接看第四个。 观察了一下输入输出，发现输入输出都是回文 什么玩意是回文的？ 第一个字符大概是 n，发现第一项是 1，第二项是 n。于是有个聚铑很自然地想到是组合数，然后发现输出也是对应的 n 的一行组合数，于是就切了。 拆了一下数，发现模数是 104857601，一个 NTT 模数。 12345678910111213141516namespace subtask4&#123; const int maxn=3e5; int mul[maxn],inv[maxn],n; inline int C(int n,int m)&#123;return 1ll*mul[n]*inv[m]%mod*inv[n-m]%mod;&#125; inline void pre()&#123; mul[0]=inv[0]=1; for(int i=1;i&lt;=n;i++) mul[i]=1ll*mul[i-1]*i%mod; inv[n]=fpow(mul[n],mod-2);for(int i=n-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod; &#125; inline void main()&#123; n=262144; pre(); printf(&quot;%d\\n&quot;,n); for(int i=0;i&lt;=n;i++) printf(&quot;%d\\n&quot;,C(n,i)); &#125;&#125; PS后来思考了一下为什么输入把 131072 的一行组合数也全给了，根据二项式定理，输入给出的是 $(x+1)^n$，然后输出的 n 恰好是输入的两倍。所以实际上是让我们算 $(x+1)^{2n}$。也就是做一遍多项式乘法。 会有人写这玩意吗，还是为了给没看出来是组合数的选手分？ Point 5刚才切了第四个点的聚铑趁热打铁，瞬间就看出来了是每一项乘上了一个 $(-1)^i$ 。于是又切了。 当然，如果您想写多项式开根也可以。 因为和前面一个点比较像，就放在一起了。 12345678910111213141516namespace subtask4&#123; const int maxn=3e5; int mul[maxn],inv[maxn],n; inline int C(int n,int m)&#123;return 1ll*mul[n]*inv[m]%mod*inv[n-m]%mod;&#125; inline void pre()&#123; mul[0]=inv[0]=1; for(int i=1;i&lt;=n;i++) mul[i]=1ll*mul[i-1]*i%mod; inv[n]=fpow(mul[n],mod-2);for(int i=n-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod; &#125; inline void main2()&#123; n=131072; pre(); printf(&quot;%d\\n&quot;,n); for(int i=0;i&lt;=n;i++) printf(&quot;%d\\n&quot;,i&amp;1?mod-C(n,i):C(n,i)); &#125;&#125; Point 6刚才那位聚铑乘胜追击，观察了一下输入输出的项数，发现输出刚好是输入的 $\\frac{1}{3}$ 。 什么东西能减少项数，而且刚好减到 $\\frac{1}{3}$？ 只有聚铑知道答案。他一眼就看出来这似乎是一个多项式三次剩余，然后确实是对的。 然而珂爱似乎有更好的方法，因为这个 $5e5$ 的数据范围，还是用的多项式快速幂真的太勉强了，加了快读快输开优化才能过。用珂爱的方法或者多项式三次方根或许能更好（更短）地通过此题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687namespace subtask6&#123; const int maxn=533000&lt;&lt;2,mod=104857601,g=3,gi=104857602/3,n=177147,p=63776689; struct NTT&#123; int r[maxn],lim; inline void getr(int li)&#123; lim=li; for(int i=0;i&lt;lim;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(lim&gt;&gt;1)); &#125; inline void operator () (int *a,int type) const &#123; for(int i=0;i&lt;lim;i++) if(i&lt;r[i]) swap(a[i],a[r[i]]); for(int mid=1;mid&lt;lim;mid&lt;&lt;=1)&#123; int rt=fpow(type==1?g:gi,(mod-1)/(mid&lt;&lt;1)); for(int r=mid&lt;&lt;1,j=0;j&lt;lim;j+=r)&#123; int p=1; for(int k=0;k&lt;mid;k++,p=1ll*p*rt%mod)&#123; int x=a[j+k],y=1ll*p*a[j+k+mid]%mod; a[j+k]=(x+y)%mod,a[j+k+mid]=(x-y+mod)%mod; &#125; &#125; &#125; if(type==-1) for(int p=fpow(lim,mod-2),i=0;i&lt;lim;i++) a[i]=1ll*a[i]*p%mod; &#125; &#125;ntt; void inv(const int *a,int *ans,int n)&#123; if(n==1) return ans[0]=fpow(a[0],mod-2),ans[1]=0,void(); static int res[maxn]; inv(a,ans,n&gt;&gt;1); int lim=n&lt;&lt;1; ntt.getr(lim); for(int i=0;i&lt;n;i++) res[i]=a[i]; for(int i=n;i&lt;lim;i++) res[i]=ans[i]=0; ntt(res,1),ntt(ans,1); for(int i=0;i&lt;lim;i++) ans[i]=ans[i]*(2-1ll*ans[i]*res[i]%mod+mod)%mod; ntt(ans,-1); for(int i=n;i&lt;lim;i++) ans[i]=0; &#125; inline void deri(const int *a,int *ans,int n)&#123;for(int i=1;i&lt;n;i++) ans[i-1]=1ll*a[i]*i%mod;ans[n-1]=0;&#125; inline void inte(const int *a,int *ans,int n)&#123;for(int i=1;i&lt;n;i++) ans[i]=1ll*a[i-1]*fpow(i,mod-2)%mod;ans[0]=0;&#125; inline void ln(const int *a,int *ans,int n)&#123; static int res[maxn]; deri(a,res,n); inv(a,ans,n); int lim=n&lt;&lt;1; ntt.getr(lim); ntt(res,1),ntt(ans,1); for(int i=0;i&lt;lim;i++) res[i]=1ll*res[i]*ans[i]%mod,ans[i]=0; ntt(res,-1); inte(res,ans,n); for(int i=0;i&lt;lim;i++) res[i]=0; &#125; void exp(const int *a,int *ans,int n)&#123; if(n==1) return ans[0]=1,ans[1]=0,void(); static int res[maxn]; exp(a,ans,n&gt;&gt;1); ln(ans,res,n); int lim=n&lt;&lt;1; ntt.getr(lim); res[0]=(1+a[0]-res[0]+mod)%mod; for(int i=1;i&lt;n;i++) res[i]=(a[i]-res[i]+mod)%mod; ntt(ans,1),ntt(res,1); for(int i=0;i&lt;lim;i++) ans[i]=1ll*ans[i]*res[i]%mod,res[i]=0; ntt(ans,-1); for(int i=n;i&lt;lim;i++) ans[i]=0; &#125; inline void fpow(int const *a,int *ans,int k,int n)&#123; static int f[maxn],g[maxn]; for(int i=0;i&lt;n;i++)g[i]=f[i]=ans[i]=0; int d=0; while(!a[d]&amp;&amp;d&lt;n) ++d; int u=::fpow(a[d],mod-2),v=22131490; for(int i=0;i&lt;n-d;i++)g[i]=1ll*a[i+d]*u%mod; for(int i=n-d;i&lt;n;i++)g[i]=0; ln(g,f,n); for(int i=0;i&lt;n;i++)f[i]=1ll*f[i]*k%mod; exp(f,ans,n); d*=k; for(int i=n-1;i&gt;=d;i--)ans[i]=1ll*ans[i-d]*v%mod; for(int i=0;i&lt;d;i++)ans[i]=0; &#125; int a[maxn],ans[maxn]; inline void main()&#123; for(int i=0;i&lt;=n;i++) a[i]=read(); fpow(a,ans,::fpow(3,mod-2),1&lt;&lt;18); out(n); for(int i=0;i&lt;=n;i++) out(ans[i]); &#125;&#125; Point 2终于要直面 01 串了。（由第一个点就可以知道我 01 串相关有多菜） 首先，一位聚铑通过观察文件大小发现字符个数恰好是斐波那契数列的第 33 项。 发现除了前三项，后面几项都符合斐波那契串。而一个斐波那契串内确实有这样的规律。 写了一下，发现是对的。 顺便模一下这位聚铑写得真可爱。 1234567namespace subtask2&#123; string s[2]=&#123;&quot;0&quot;,&quot;1&quot;&#125;; inline void main()&#123; for(int i=2;i&lt;33;i++) s[i&amp;1]=s[i&amp;1]+s[i&amp;1^1]; puts(s[0].c_str()); &#125;&#125; Point 3这个点是最艰难的点了。 使劲找规律，先发现字符个数是 $3^{12}+11$ ，然后思考有什么规律。 除去第一个 0，每 12 个数分开，看起来好像是三进制数每次 +1 再 +2 。 往后看了看，什么玩意 经过艰苦的奋斗，最终还是没找出来，于是去膜拜的珂爱的题解。感觉就是个找规律。因为是抄别人的，所以写出来也没啥意思。贴一下别人的代码。 1234567891011121314151617181920212223namespace subtask3&#123; using namespace std; void main() &#123; unordered_set&lt;string&gt;st; string s=&quot;000000000001&quot;,output=&quot;&quot;; while(1）&#123; output+=s[0]; st.insert(s); s+=s[0]; s.erase(0,1); while(st.count(s)&amp;&amp;s!=&quot;000000000000&quot;)&#123; ++s[11]; for(int i=11;~i&amp;&amp;s[i]==&#x27;3&#x27;;--i)&#123; s[i]=&#x27;0&#x27;; if(i)++s[i-1]; &#125; &#125; if(s==&quot;000000000000&quot;)break; &#125; cout&lt;&lt;0&lt;&lt;output&lt;&lt;&quot;00000000000\\n&quot;; &#125;&#125; 代码都在上面了。贴一下我的主函数（包括第十个点的特判）和用到的全局函数和变量。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;unordered_set&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;const int mod=104857601;char O_[999999],*OU=O_,*OV=OU+999991,OS[21],*OT=OS;#define F fwrite(O_,1,OU-O_,stdout)#define O(x) (*(OU=(OU==OV?(F,O_):OU))++=(x))void out(int x)&#123;for(;*OT++=x%10+48,x/=10;);for(;OT!=OS;O(*--OT));O(10);&#125;inline int fpow(int a,int b)&#123;int ans=1;for(;b;b&gt;&gt;=1,a=1ll*a*a%mod) if(b&amp;1) ans=1ll*ans*a%mod;return ans;&#125;int n;//------------------------------------------------------------signed main()&#123; char s[10]; scanf(&quot;%s&quot;,s); if(strcmp(s,&quot;Maybe&quot;)==0) return puts(&quot;Your program should output itself here.\\nSounds very difficult, yeah?\\nAnyway, good luck!&quot;),0; n=atoi(s); if(n==22)subtask1::main(); if(n==33)subtask2::main(); if(n==12)subtask3::main(); if(n==531441)subtask6::main(); if(n==131072)subtask4::main(); if(n==262144)subtask4::main2(); if(n==100000)&#123; int m=read(); if(m==100000) subtask7::main(n,m); else subtask8::main(); &#125;else if(n==50000) subtask9::main(); return F,0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5110 块速递推-光速幂、斐波那契数列通项","slug":"P5110 块速递推-光速幂、斐波那契数列通项","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.450Z","comments":true,"path":"2022/04/30/P5110 块速递推-光速幂、斐波那契数列通项/","permalink":"https://starcried.github.io/2022/04/30/P5110%20%E5%9D%97%E9%80%9F%E9%80%92%E6%8E%A8-%E5%85%89%E9%80%9F%E5%B9%82%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%9A%E9%A1%B9/","excerpt":"","text":"P5110 块速递推题意多次询问，求数列$$a_i&#x3D;\\begin{cases}233a_{i-1}+666a_{i-2} &amp; i&gt;1\\0 &amp; i&#x3D;0\\1 &amp; i&#x3D;1\\\\end{cases}$$的第 $n$ 项在 $\\mod 1e9+7$ 意义下的值的异或和。 思路首先这个数列是一个广义斐波那契数列。对于广义斐波那契数列，我们一般是用矩阵快速幂求的。 但是，这个题的询问次数是 $5e7$ 。 所以我们就必须用 $O(1)$ 的方法处理询问。于是，一个自诩光速幂的东西登场了。 实际上，光速幂就是在 $\\sqrt n$ 的时间复杂度内预处理，然后 $O(1)$ 查询。具体来讲，我们可以预处理出转移矩阵的 $1、2、\\cdots、\\sqrt n$ 和 $1\\sqrt n、2\\sqrt n、\\cdots、\\sqrt n \\sqrt n$ 显然就可以 $O(1)$ 求这个东西了。 但是！询问的数字大小肯定不是在模域范围内的，所以我们需要找循环节。 有一个问题就是，矩阵的循环节并不固定。 但是有一个结论，对角线元素互不相同的下三角矩阵的循环节为 $\\large\\mathbf{\\varphi_{mod}}$ 。但是笔者并不会证。 所以这题的正解并不是矩阵光速幂QAQ 我们可以用生成函数或者特征方程或者待定系数法来推出通项公式。具体推导过程与斐波那契数列的推导类似，然后用二次剩余将在根号下的项化成模域下的数，然后我们就得出了数列的通项公式：$$a_n&#x3D;233230706(94153035^n−905847205^n)\\pmod{10^9}$$然而我用矩阵光速幂水过去了。 之后学了上面的东西之后可能会试着推一下。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define int unsignedusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int mod=1e9+7,ring=1e9+6,siz=31623; struct mat&#123; int a[2][2]; mat()&#123;memset(a,0,sizeof a);&#125; inline void set()&#123;a[0][0]=a[1][1]=1;&#125; inline int* operator [] (const int x)&#123;return a[x];&#125; inline const int* operator [] (const int x) const &#123;return a[x];&#125; inline mat operator * (const mat &amp;b)const&#123; mat ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) (ans[i][j]+=1ll*a[i][k]*b[k][j]%mod)&gt;=mod&amp;&amp;(ans[i][j]-=mod); return ans; &#125; &#125;now,pow[siz+1],Pow[siz+1]; unsigned long long SA,SB,SC; void init()&#123;scanf(&quot;%llu%llu%llu&quot;,&amp;SA,&amp;SB,&amp;SC);&#125; unsigned long long rand() &#123; SA^=SA&lt;&lt;32,SA^=SA&gt;&gt;13,SA^=SA&lt;&lt;1; unsigned long long t=SA; SA=SB,SB=SC,SC^=t^SA;return SC; &#125; inline void work()&#123; now[0][1]=0,now[0][0]=1,pow[1][0][0]=233,pow[1][1][0]=666,pow[1][0][1]=1; pow[0].set(); Pow[0].set(); for(int i=2;i&lt;=siz;i++) pow[i]=pow[i-1]*pow[1]; Pow[1]=pow[siz]; for(int i=2;i&lt;=siz;i++) Pow[i]=Pow[i-1]*Pow[1]; int T=read(); init(); unsigned ans=0; while(T--)&#123; int zp=rand()%ring; int x=zp/siz,y=zp%siz; int res; ans^=(res=(1ll*Pow[x][0][0]*pow[y][0][1]%mod+1ll*Pow[x][0][1]*pow[y][1][1]%mod))&gt;=mod?res-=mod:res; &#125; printf(&quot;%u\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5147-数学-随机数生成器","slug":"P5147-数学-随机数生成器","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.450Z","comments":true,"path":"2022/04/30/P5147-数学-随机数生成器/","permalink":"https://starcried.github.io/2022/04/30/P5147-%E6%95%B0%E5%AD%A6-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"","text":"P5147-数学-随机数生成器（洛谷第一篇题解说这是高一数学题，新高二感觉到被吊打） 我们设work(x)的期望值为$f_x$ 注意$f_1$是边界。不过对下列式子没有影响。原因参照必修的数列 那么$\\displaystyle f_n&#x3D;1+\\frac{1}{n}\\sum_{i&#x3D;1}^{n}f_i$ 移项得到$\\displaystyle f_n&#x3D;\\frac{n}{n-1}+\\frac{1}{n-1}\\sum_{i&#x3D;1}^{n-1}f_i$ 记$S_x$为$\\sum_{i&#x3D;1}^{x}$ 原式即为 $\\displaystyle f_n&#x3D;\\frac{n}{n-1}+\\frac{1}{n-1}S_{n-1}$ 通过高一的数学知识化简一下 $\\displaystyle f_n&#x3D;1+\\sum_{i&#x3D;1}^{n-1}\\frac{1}{i}$ 发现这玩意就是个（伪）调和级数加1. 推出了通项公式！可以$O(1)$求解了……吗？ 看看n的范围然后会发现直接求后面这堆东西会死人的。 但是，调和级数我们还是懂的。当n趋近于正无穷时，后面这堆东西近似于调和级数。那么我们把它就当做是好了。 欧拉常数$\\gamma&#x3D;0.57721 56649 01532 86060 65120 90082 40243 10421 59335$ 我们知道了欧拉常数，然后就解决了。 12345678910111213#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; double ans=0; scanf(&quot;%d&quot;,&amp;n); if(n&lt;100000)for(int i=1;i&lt;n;i++)ans+=1.0/i;//范围较小时会有较大误差，暴力即可 else ans=log(n)+0.577215664901532; printf(&quot;%.5f&quot;,n==1?0:ans+1); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5311 [Ynoi2011] 成都七中","slug":"P5311 [Ynoi2011] 成都七中","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.451Z","comments":true,"path":"2022/04/30/P5311 [Ynoi2011] 成都七中/","permalink":"https://starcried.github.io/2022/04/30/P5311%20[Ynoi2011]%20%E6%88%90%E9%83%BD%E4%B8%83%E4%B8%AD/","excerpt":"","text":"P5311 [Ynoi2011] 成都七中题意给你一棵 $n$ 个节点的树，每个节点有一种颜色，有 $m$ 次查询操作。 查询操作给定参数 $l\\ r\\ x$，需输出： 将树中编号在 $[l,r]$ 内的所有节点保留，$x$ 所在连通块中颜色种类数。 每次查询操作独立。 思路考虑点分树的思想。假设我们已经建出点分树，对于每一个分治中心，我们应该维护什么东西？ 我们从分治中心开始遍历，记录遍历到每个点路径上编号的最小值和最大值。很显然，如果遍历到一个询问的 $x$ 的时候路径上最值范围在询问区间以内，那么对于这个询问 $x$ 点与分治中心是联通的。 考虑这个分治中心是怎么给询问更新答案的。我们在遍历的时候记录一下到达每个点时的路径最值和该点的颜色，最后统计答案的时候枚举每个满足上述条件的询问的右端点，用”HH的项链”一题的方法用树状数组记录每种颜色的最小编号的最大值的颜色个数，查询区间答案即可。显然，这个时候树状数组里的每一个答案都与分治中心联通，而分治中心又与询问点联通，故能将范围内的答案统计完全。 那么问题来了，每个询问答案被统计几次、在哪里被统计能统计完全呢？ 考虑点分树的结构。对于一个询问的编号区间，假设 $u$ 为询问点 $x$ 的点分树祖先，$v$ 为 $u$ 点分树祖先，且两者都与 $x$ 联通，那么 $v$ 包含的范围一定比 $u$ 大而且完全包含 $u$ 的范围。我们刚才说在分治中心的统计能将整个范围内的答案都统计完全，所以 $x$ 在 $v$ 处被统计一定包含在 $u$ 处统计的所有答案。 我们再考虑一个事情，若 $u\\ v$ 定义同上，但$u$ 与 $x$ 联通而 $v$ 不与 $x$ 联通，那么与 $u$ 相对的 $v$ 的彼处的所有点都一定不与 $x$ 联通，因为这些点一定会经过 $v$ 点。 综上，对于每个点，我们只需要选择一个深度最小的联通的祖先统计答案即可。这时统计的答案是完全的。 然后我们发现我们甚至不需要建出点分树。直接点分治，在每个分治中心搜索出范围内合法的询问，直接按照上述统计方式将询问答案求出，以后都不再更新该询问答案即可。 时间复杂度 $O(n\\log^2n)$，空间复杂度 $O(n)$。空间小、时间常数小、代码短的方法谁不喜欢呢~ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int n,m,c[maxn],C[maxn],ans[maxn],siz[maxn],rt,mx[maxn],lst[maxn]; bool vis[maxn],mark[maxn]; struct que&#123; int l,r,id; que()&#123;&#125; que(int l,int r,int id):l(l),r(r),id(id)&#123;&#125; bool operator &lt; (const que &amp;b) const &#123;return r&lt;b.r;&#125; &#125;; vector&lt;int&gt; V[maxn]; vector&lt;que&gt; qu[maxn],a,q; inline void insert(int x,int k)&#123;if(x)for(;x&lt;=n;x+=x&amp;-x) C[x]+=k;&#125; inline int query(int x)&#123;int ans=0;for(;x;x-=x&amp;-x) ans+=C[x]; return ans;&#125; void getrt(int x,int fa,int S)&#123; siz[x]=1,mx[x]=0; for(auto u:V[x]) if(!vis[u] and u!=fa) getrt(u,x,S),mx[x]=max(mx[x],siz[u]),siz[x]+=siz[u]; if((mx[x]=max(mx[x],S-siz[x]))&lt;mx[rt]) rt=x; &#125; void dfs(int x,int fa,int l,int r)&#123; siz[x]=1,a.emplace_back(l,r,c[x]); for(auto u:qu[x]) if(!mark[u.id] and u.l&lt;=l and r&lt;=u.r) mark[u.id]=true,q.push_back(u); for(auto u:V[x]) if(!vis[u] and u!=fa) dfs(u,x,min(l,u),max(r,u)),siz[x]+=siz[u]; &#125; void solve(int x)&#123; vis[x]=true; a.clear(),q.clear(),dfs(x,0,x,x); sort(a.begin(),a.end()),sort(q.begin(),q.end()); for(int i=0,j=0;i&lt;q.size();i++)&#123; while(j&lt;a.size() and a[j].r&lt;=q[i].r)&#123; if(a[j].l&gt;lst[a[j].id]) insert(lst[a[j].id],-1),insert(lst[a[j].id]=a[j].l,1); ++j; &#125; ans[q[i].id]=query(n)-query(q[i].l-1); &#125; for(auto u:a) insert(lst[u.id],-1),lst[u.id]=0; for(auto u:V[x]) if(!vis[u]) rt=0,getrt(u,x,siz[u]),solve(rt); &#125; inline void work()&#123; n=read(),m=read(),mx[0]=n+1; for(int i=1;i&lt;=n;i++) c[i]=read(); for(int u,v,i=1;i&lt;n;i++) u=read(),v=read(),V[u].push_back(v),V[v].push_back(u); for(int l,r,i=1;i&lt;=m;i++) l=read(),r=read(),qu[read()].emplace_back(l,r,i); getrt(1,0,n),solve(rt); for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P4827 [国家集训队] Crash 的文明世界","slug":"P4827 [国家集训队] Crash 的文明世界","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.449Z","comments":true,"path":"2022/04/30/P4827 [国家集训队] Crash 的文明世界/","permalink":"https://starcried.github.io/2022/04/30/P4827%20[%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F]%20Crash%20%E7%9A%84%E6%96%87%E6%98%8E%E4%B8%96%E7%95%8C/","excerpt":"","text":"P4827 [国家集训队] Crash 的文明世界题意求出对于树上每个点 $x$ 的 $\\sum_{u&#x3D;1}^ndis(x,u)^k$。所有边长为 1。 思路根据斯特林反演：$$m^n&#x3D;\\sum_{j&#x3D;0}^n\\begin{Bmatrix}n\\j\\end{Bmatrix}C_m^jj!$$可以得到：$$\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;0}^{k}\\begin{Bmatrix}k\\j\\end{Bmatrix}C_{dis(x,i)}^jj!\\&#x3D;\\sum_{j&#x3D;0}^{k}\\begin{Bmatrix}k\\j\\end{Bmatrix}j!\\sum_{i&#x3D;1}^nC_{dis(x,i)}^j\\&#x3D;\\sum_{j&#x3D;0}^{k}\\begin{Bmatrix}k\\j\\end{Bmatrix}j!\\sum_{i&#x3D;1}^n(C_{dis(x,i)-1}^{j-1}+C_{dis(x,i)-1}^j)$$我们只需要 Dp 一边维护后面的组合数部分的值就行了。最后一步是为了推出转移式，设 $f_{x,j}$ 为 $\\sum_{i&#x3D;1}^nC_{dis(x,i)}^j$，则有：$$f_{x,j}&#x3D;\\sum_{x\\rightarrow u}f_{u,j}+f_{u,j-1}$$再进行一步换根最后代回原式得出答案即可。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=5e4+10,mod=10007,maxm=210; int ecnt,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt; &#125; int n,k,f[maxn][maxm],g[maxn][maxm],S[maxm][maxm],mul[maxm]; void dfs1(int x,int fa)&#123; f[x][0]=1; for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=fa)&#123; dfs1(u,x); for(int j=1;j&lt;=k;j++) f[x][j]=(f[x][j]+f[u][j]+f[u][j-1])%mod; f[x][0]=(f[x][0]+f[u][0])%mod; &#125; &#125; void dfs2(int x,int fa)&#123; for(int i=0;i&lt;=k;i++) g[x][i]=f[x][i]; if(fa)&#123; static int res[maxm]; for(int i=1;i&lt;=k;i++) res[i]=(g[fa][i]-f[x][i]-f[x][i-1]+mod*2)%mod; res[0]=(g[fa][0]-f[x][0]+mod)%mod; for(int i=1;i&lt;=k;i++) g[x][i]=(g[x][i]+res[i]+res[i-1])%mod; g[x][0]=(g[x][0]+res[0])%mod; &#125; for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=fa) dfs2(u,x); &#125; inline void work()&#123; n=read(),k=read(); for(int i=1;i&lt;n;i++) addedge(read(),read()); S[0][0]=S[1][1]=1; for(int i=2;i&lt;=k;i++) for(int j=1;j&lt;=i;j++) S[i][j]=(S[i-1][j-1]+S[i-1][j]*j)%mod; mul[0]=1;for(int i=1;i&lt;=k;i++) mul[i]=mul[i-1]*i%mod; dfs1(1,0),dfs2(1,0); for(int i=1;i&lt;=n;i++)&#123; int ans=0; for(int j=0;j&lt;=k;j++) ans=(ans+1ll*S[k][j]*mul[j]*g[i][j])%mod; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5296 [北京省选集训2019]生成树计数","slug":"P5296 [北京省选集训2019]生成树计数","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.450Z","comments":true,"path":"2022/04/30/P5296 [北京省选集训2019]生成树计数/","permalink":"https://starcried.github.io/2022/04/30/P5296%20[%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019]%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/","excerpt":"","text":"P5296 [北京省选集训2019]生成树计数题意求一个带权无向图所有生成树边权和的 $k$ 次方的和。 思路首先有一个结论：$a^i$ 的 EGF 卷 $b^i$ 的 EGF 等于 $(a+b)^i$ 的 EGF。即：$$F(a)&#x3D;\\sum_{i&#x3D;0}\\frac{a^ix^i}{i!}\\F(a+b)&#x3D;F(a)*F(b)$$证明如下：$$(a+b)^k&#x3D;\\sum_{i&#x3D;0}^k{k\\choose i}a^ib^{k-i}&#x3D;\\sum_{i&#x3D;0}^k\\frac{k!}{i!(k-i)!} a^ib^{k-i}\\\\Rightarrow \\sum_{i&#x3D;0}^k\\frac{a^i}{i!}\\frac{b^{k-i}}{(k-i)!}k!&#x3D;(a+b)^k \\\\Rightarrow \\sum_{i&#x3D;0}^k\\frac{a^i}{i!}\\frac{b^{k-i}}{(k-i)!}&#x3D;\\frac{(a+b)^k}{k!}\\$$然后又有一个结论：度数矩阵减去邻接矩阵的余子式的行列式的值是图所有生成树边权积的和。其中，度数矩阵表示与其相连的边权的和，邻接矩阵为边权。这是矩阵树定理。 于是，我们将边权化为生成函数，然后利用矩阵树定理算出来答案的生成函数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=35,mod=998244353; int n,k,mul[maxn],inv[maxn]; inline int fpow(int a,int b)&#123;int ans=1;for(;b;b&gt;&gt;=1,a=1ll*a*a%mod) if(b&amp;1) ans=1ll*ans*a%mod;return ans;&#125; struct poly&#123; int a[maxn]; poly():a()&#123;&#125; poly(int x):a()&#123;for(int i=0,d=1;i&lt;=k;i++,d=1ll*d*x%mod) a[i]=1ll*star::inv[i]*d%mod;&#125; int&amp; operator [](const int &amp;x)&#123;return a[x];&#125; const int &amp;operator [](const int &amp;x) const &#123;return a[x];&#125; friend poly operator + (const poly&amp; a,const poly&amp; b) &#123; poly ans; for(int i=0;i&lt;=k;i++) ans[i]=(a[i]+b[i])%mod; return ans; &#125; friend poly operator - (const poly&amp; a,const poly&amp; b) &#123; poly ans; for(int i=0;i&lt;=k;i++) ans[i]=(a[i]-b[i]+mod)%mod; return ans; &#125; friend poly operator * (const poly&amp; a,const poly&amp; b) &#123; poly ans; for(int i=0;i&lt;=k;i++) for(int j=0;j&lt;=i;j++) ans[i]=(ans[i]+1ll*a[j]*b[i-j])%mod; return ans; &#125; inline poly operator - () const &#123; poly ans; for(int i=0;i&lt;=k;i++) ans[i]=(mod-a[i])%mod; return ans; &#125; inline poly inv() const &#123; poly ans,res; ans[0]=fpow(a[0],mod-2); for(int i=1;i&lt;=k;i++) res[i]=1ll*a[i]*ans[0]%mod; for(int i=1;i&lt;=k;i++) for(int j=1;j&lt;=i;j++) ans[i]=(ans[i]+1ll*(mod-res[j])*ans[i-j])%mod; return ans; &#125; &#125;a[maxn][maxn],ans; inline void work()&#123; n=read()-1,k=read(); mul[0]=inv[0]=1; for(int i=1;i&lt;=k;i++) mul[i]=1ll*mul[i-1]*i%mod; inv[k]=fpow(mul[k],mod-2);for(int i=k-1;i&gt;0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++) if(i!=j) a[i][j]=-poly(read()),a[i][i]=a[i][i]-a[i][j];else read(); ans[0]=1; for(int i=1;i&lt;=n;i++)&#123; poly x=a[i][i].inv(); ans=ans*a[i][i]; for(int j=i;j&lt;=n;j++) a[i][j]=a[i][j]*x; for(int j=1;j&lt;=n;j++) if(j!=i)&#123; poly res=a[j][i]; for(int k=i;k&lt;=n;k++) a[j][k]=a[j][k]-a[i][k]*res; &#125; &#125; printf(&quot;%lld\\n&quot;,1ll*ans[k]*mul[k]%mod); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5350 序列","slug":"P5350 序列","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.451Z","comments":true,"path":"2022/04/30/P5350 序列/","permalink":"https://starcried.github.io/2022/04/30/P5350%20%E5%BA%8F%E5%88%97/","excerpt":"","text":"P5350 序列题意维护一个序列，支持区间求和、赋值、加值、复制、交换、翻转操作，其中交换和复制操作保证两段区间长度相等且不交。答案对 $1e9+7$ 取模。 思路对于区间求和、赋值、加值、交换、翻转操作我们都可以很轻松地使用平衡树进行维护。所以现在的难点就在于复制操作：如何复制一段区间？ 如果我们暴力复制的话，每次我们不得不将被复制的子树扫一遍进行复制，这是肯定不行的。 于是我们使用可持久化平衡树。其中心思想就是每次修改一个节点的信息时，将该节点复制一遍。这样我们在进行复制操作的时候就可以复制出来一个新的树而不会对原树有影响，而且因为不是每次都遍历子树，所以时间复杂度正确。 但是因为要丢弃之前的节点所以空间复杂度略微有些大。因为我们可以进行垃圾回收定期重构使得空间被合理重复利用。 于是这道题就解决了。我使用了 FHQ treap 进行实现，因为发现对于这些操作 FHQ 会比较方便。 然后这道题不卡 ODT 但卡复杂度保证的写法。 细节和我犯过的错误 这是个定长的序列，所以我们每次重构的时候可以选择使用构建二叉搜索树的方法线性构建，否者会被卡常。 每次更改节点信息时都要进行复制，pushdown,merge,split 函数和修改操作里都要复制。 注意 pushdown 和 clone 的前后顺序。有时候我们并不需要将原节点进行下传标记以免建出无用节点增大常数。 注意传参时用的是哪个节点的参数。我曾在 split 操作中下传原节点的儿子，实际上是复制后的节点的儿子。 FHQ 在新建节点后的 rand 值占空间，我们用一段话在 merge 的时候现场随机，即： rd(0,(e[a].siz+e[b].siz)-1)&lt;e[a].siz 可以省下一点空间。 复制和交换的时候记住，给出的区间端点位置可不保证升序的。 重构之后再清空节点数，因为在遍历搜索树的时候会 pushdown 而新加节点。 代码这里的代码是加强版的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;chrono&gt;#include&lt;random&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;char buf[1 &lt;&lt; 21], a[20]; int p, p2 = -1;inline void flush() &#123; fwrite(buf, 1, p2 + 1, stdout); p2 = -1;&#125;inline void print(int x) &#123; if (p2 &gt; 1 &lt;&lt; 20) flush(); if (x &lt; 0) buf[++p2] = 45, x = -x; do a[++p] = x % 10 + 48;while (x /= 10); do buf[++p2] = a[p];while (--p);&#125; namespace star&#123; const int maxn=3e5+10,maxm=8e6+10,mod=1e9+7; mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count()); int rd(int l,int r)&#123;return std::uniform_int_distribution&lt;int&gt;(l,r)(rnd);&#125; int n,m,a[maxn]; int lastans; struct FHQ&#123; #define ls e[ro].son[0] #define rs e[ro].son[1] struct node&#123; int son[2],siz,tag,add,val,sum; bool rev; &#125;e[maxm]; int tot,rt; FHQ():e(),tot(0),rt(0)&#123;&#125; inline void clone(int &amp;x)&#123;e[++tot]=e[x],x=tot;&#125; inline int newnode(const int &amp;a)&#123;return e[++tot]=(node)&#123;&#123;0,0&#125;,1,-1,0,a,a,false&#125;,tot;&#125; inline void pushup(const int &amp;ro)&#123;e[ro].siz=e[ls].siz+e[rs].siz+1,e[ro].sum=(1ll*e[ls].sum+e[rs].sum+e[ro].val)%mod;&#125; void rev(const int &amp;ro)&#123;if(ro)e[ro].rev^=1,swap(ls,rs);&#125; void add(const int &amp;ro,const int &amp;v)&#123;if(ro)e[ro].val=(e[ro].val+v)%mod,e[ro].sum=(e[ro].sum+1ll*e[ro].siz*v)%mod,e[ro].add=(e[ro].add+v)%mod;&#125; void assign(const int &amp;ro,const int &amp;v)&#123;if(ro)e[ro].val=v,e[ro].sum=1ll*e[ro].siz*v%mod,e[ro].add=0,e[ro].tag=v;&#125; inline void pushdown(const int &amp;ro)&#123; if(!e[ro].rev and e[ro].tag==-1 and !e[ro].add) return; if(ls) clone(ls);if(rs) clone(rs); if(e[ro].rev) rev(ls),rev(rs),e[ro].rev=false; if(e[ro].tag!=-1) assign(ls,e[ro].tag),assign(rs,e[ro].tag),e[ro].tag=-1; if(e[ro].add) add(ls,e[ro].add),add(rs,e[ro].add),e[ro].add=0; &#125; int build(const int &amp;l=1,const int &amp;r=n)&#123; if(l&gt;r)return 0; int mid=(l+r)&gt;&gt;1; int ro=newnode(a[mid]); ls=build(l,mid-1),rs=build(mid+1,r); pushup(ro); return ro; &#125; int merge(int a,int b)&#123; if(!a or !b)return a|b; if(rd(0,(e[a].siz+e[b].siz)-1)&lt;e[a].siz)&#123; clone(a),pushdown(a); e[a].son[1]=merge(e[a].son[1],b); pushup(a);return a; &#125;else&#123; clone(b),pushdown(b); e[b].son[0]=merge(a,e[b].son[0]); pushup(b);return b; &#125; &#125; void split(int ro,int k,int &amp;a,int &amp;b)&#123; if(!ro) return a=b=0,void(); if(e[ls].siz&lt;k) a=ro,clone(a),pushdown(a),split(e[a].son[1],k-e[e[a].son[0]].siz-1,e[a].son[1],b),pushup(a); else b=ro,clone(b),pushdown(b),split(e[b].son[0],k,a,e[b].son[0]),pushup(b); &#125; inline void copy()&#123; int l1=read()^lastans,r1=read()^lastans,l2=read()^lastans,r2=read()^lastans,a,b,c,d,e;int bk=1; if(r1&gt;r2)swap(l1,l2),swap(r1,r2),bk=0; split(rt,r2,d,e);split(d,l2-1,c,d);split(c,r1,b,c);split(b,l1-1,a,b); if(bk) rt=merge(a,merge(b,merge(c,merge(b,e)))); else rt=merge(a,merge(d,merge(c,merge(d,e)))); &#125; inline void Swap()&#123; int l1=read()^lastans,r1=read()^lastans,l2=read()^lastans,r2=read()^lastans,a,b,c,d,e; if(r1&gt;r2)swap(l1,l2),swap(r1,r2); split(rt,r2,d,e);split(d,l2-1,c,d);split(c,r1,b,c);split(b,l1-1,a,b); rt=merge(a,merge(d,merge(c,merge(b,e)))); &#125; inline void push(int ro)&#123; if(!ro)return; pushdown(ro); push(ls),a[++n]=e[ro].val,push(rs); &#125; #undef ls #undef rs &#125;S; inline void work()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); S.rt=S.build(); while(m--)&#123; switch(read())&#123; case 1:&#123; int l=read()^lastans,r=read()^lastans,a,b,c; S.split(S.rt,r,b,c);S.split(b,l-1,a,b); printf(&quot;%d\\n&quot;,lastans=S.e[b].sum); S.rt=S.merge(a,S.merge(b,c)); break; &#125; case 2:&#123; int l=read()^lastans,r=read()^lastans,a,b,c; S.split(S.rt,r,b,c);S.split(b,l-1,a,b); S.clone(b); S.assign(b,read()^lastans); S.rt=S.merge(a,S.merge(b,c)); break; &#125; case 3:&#123; int l=read()^lastans,r=read()^lastans,a,b,c; S.split(S.rt,r,b,c);S.split(b,l-1,a,b); S.clone(b); S.add(b,read()^lastans); S.rt=S.merge(a,S.merge(b,c)); break; &#125; case 4:S.copy();break; case 5:S.Swap();break; case 6:&#123; int l=read()^lastans,r=read()^lastans,a,b,c; S.split(S.rt,r,b,c);S.split(b,l-1,a,b); S.clone(b); S.rev(b); S.rt=S.merge(a,S.merge(b,c)); break; &#125; &#125; if(S.tot&gt;6500000) n=0,S.push(S.rt),S.rt=S.tot=0,S.rt=S.build(); &#125; n=0,S.push(S.rt); for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); &#125;&#125;signed main()&#123; star::work(); flush(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5471- K-D tree优化建图-弹跳","slug":"P5471- K-D tree优化建图-弹跳","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.452Z","comments":true,"path":"2022/04/30/P5471- K-D tree优化建图-弹跳/","permalink":"https://starcried.github.io/2022/04/30/P5471-%20K-D%20tree%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE-%E5%BC%B9%E8%B7%B3/","excerpt":"","text":"P5471- K-D tree优化建图-弹跳 优化建图是一种思想。 题意有$n$个城市分布在小鸟岛上，有$m$个弹弓分布在这些城市里。因为弹弓体积大，固定麻烦，所以每个弹弓只能把小鸟弹飞到一块固定的矩形范围内的城市，同时小鸟会在空中滞留$t_i$的时间。闪电黄的家在1号城市，追求速度的它想知道，若只使用弹弓出行，它从家到其他所有城市的最短时间花费是多少。 抱歉魔改了题面，但是这个题意真的太像愤怒的小鸟了好吗 思路暴力：枚举每两个城市间是否能转移进行建图跑最短路。 太浪费了，这么大的矩形有很多点肯定连不上的呀。根据套路，我们想个数据结构优化建图。 二维线段树优化建图 树套树优化建图 K-D tree优化建图 前两个我不会 首先我们把这n个城市建成2-D tree，然后跑Dijkstra: 若当前结点位置在转移的范围内，插入队列，递归查找子节点并更新覆盖范围。 若弹跳的范围与树上结点覆盖的范围有交，查找之，否则不查找。 就这么简单。怎么说K-D tree就是优雅的暴力呢。 实现我们用一个结构体node存储树上节点信息，用一个结构体data表示一个转移（边）。 对于一个转移，每次从根开始查找，根据以上策略遍历整棵树。时间复杂度O(能过)。事实上，我还跑了目前luogu榜一（醒醒啊你只是因为评测机最近变快了） 把查找单独拉出来： 123456789101112131415161718192021222324252627inline bool cross(node a,data b)&#123;return a.l[0]&lt;=b.r[0] and a.r[0]&gt;=b.l[0] and a.l[1]&lt;=b.r[1] and a.r[1]&gt;=b.l[1];&#125;void solve(node&amp; x,data&amp; p)&#123; if(!x.del and x.in(p))&#123;//若该点坐标在覆盖范围内 if(x.id!=1)&#123; dis[x.id]=p.v; for(int i=head[x.id];i;i=nxt[i])&#123;//遍历所有能到的位置 data u=to[i]; u.v+=p.v; q.push(u); &#125; &#125; x.del=1;//根据dijkstra的贪心策略，该点不再入队 x.clear();//为了保留结点查询的作用。下面会更新范围 &#125; if(x.son[0])&#123; node &amp;now=e[x.son[0]]; if(cross(now,p)) solve(now,p);//注意这里判断的是矩形是否有交而非城市坐标 if(x.del) x.copy(now); else x.update(now);//更新范围 &#125; if(x.son[1])&#123; node &amp;now=e[x.son[1]]; if(cross(now,p)) solve(now,p); if(x.del and !x.son[0]) x.copy(now); else x.update(now);//更新范围 &#125;&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=7e4+10,maxm=15e4,INF=0x3f3f3f3f; int n,m,w,h,root,dis[maxn]; struct data&#123; int v,l[2],r[2]; inline bool operator &lt; (const data &amp;zp) const&#123;return v&gt;zp.v;&#125; &#125;; int ecnt,head[maxm],nxt[maxm]; data to[maxm]; inline void add(int a,data b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; &#125; struct node&#123; int x[2],l[2],r[2],son[2],id; static int d;//“只是声明我要用这个变量，但是它现在还不存在” bool del; inline void clear()&#123; for(int i=0;i&lt;2;i++) x[i]=0,l[i]=INF,r[i]=-INF; &#125; inline void init(int zp)&#123; for(int i=0;i&lt;2;i++) x[i]=l[i]=r[i]=read(); id=zp; &#125; inline void update(const node &amp;zp)&#123; for(int i=0;i&lt;2;i++) l[i]=min(l[i],zp.l[i]),r[i]=max(r[i],zp.r[i]); &#125; inline void copy(const node &amp;zp)&#123; for(int i=0;i&lt;2;i++) l[i]=zp.l[i],r[i]=zp.r[i]; &#125; inline bool operator &lt; (const node &amp;zp) const&#123;return x[d]&lt;zp.x[d];&#125;; inline bool in(const data &amp;zp) const &#123;return x[0]&gt;=zp.l[0] and x[0]&lt;=zp.r[0] and x[1]&gt;=zp.l[1] and x[1]&lt;=zp.r[1];&#125; &#125;e[maxn]; int node::d;//现在这个变量存在了，并且每个node都会用它 int build(int l,int r,int d)&#123; node::d=d; int mid=l+r&gt;&gt;1; nth_element(e+l,e+mid,e+r+1); if(l&lt;mid) e[mid].update(e[e[mid].son[0]=build(l,mid-1,d^1)]); if(r&gt;mid) e[mid].update(e[e[mid].son[1]=build(mid+1,r,d^1)]); return mid; &#125; priority_queue&lt;data&gt; q; inline bool cross(node a,data b)&#123;return a.l[0]&lt;=b.r[0] and a.r[0]&gt;=b.l[0] and a.l[1]&lt;=b.r[1] and a.r[1]&gt;=b.l[1];&#125; void solve(node&amp; x,data&amp; p)&#123; if(!x.del and x.in(p))&#123; if(x.id!=1)&#123; dis[x.id]=p.v; for(int i=head[x.id];i;i=nxt[i])&#123; data u=to[i]; u.v+=p.v; q.push(u); &#125; &#125; x.del=1; x.clear(); &#125; if(x.son[0])&#123; node &amp;now=e[x.son[0]]; if(cross(now,p)) solve(now,p); if(x.del) x.copy(now); else x.update(now); &#125; if(x.son[1])&#123; node &amp;now=e[x.son[1]]; if(cross(now,p)) solve(now,p); if(x.del and !x.son[0]) x.copy(now); else x.update(now); &#125; &#125; inline void work()&#123; n=read(),m=read(),w=read(),h=read(); for(int i=1;i&lt;=n;i++) e[i].init(i); root=build(1,n,0); memset(dis,INF,sizeof dis); dis[1]=0; for(int i=1;i&lt;=m;i++)&#123; data zp; int x=read(); zp.v=read(),zp.l[0]=read(),zp.r[0]=read(),zp.l[1]=read(),zp.r[1]=read(); add(x,zp); &#125; for(int i=head[1];i;i=nxt[i]) q.push(to[i]); while(!q.empty())&#123; data x=q.top();q.pop(); solve(e[root],x); &#125; for(int i=2;i&lt;=n;i++) printf(&quot;%d\\n&quot;,dis[i]); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; PS：据银牌学姐推荐，方差建树常数大，K维循环建树虽然有时候会被卡但实际可能比前者优秀。 为啥题面那么喜欢跳蚤用小鸟们不可爱吗owo 自己吃别人嚼过的馒头为啥还敢写题解？因为觉得自己的马蜂太好看了所以来分享一下","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5468 [NOI2019] 回家路线","slug":"P5468 [NOI2019] 回家路线","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.452Z","comments":true,"path":"2022/04/30/P5468 [NOI2019] 回家路线/","permalink":"https://starcried.github.io/2022/04/30/P5468%20[NOI2019]%20%E5%9B%9E%E5%AE%B6%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"P5468 [NOI2019] 回家路线斜率优化入门（指我写的东西而不是这道题） 题意$n$ 个节点，有 $m$ 趟列车，车 $i$ 从 $p_i$ 时刻至 $q_i$ 时刻从 $x_i$ 地到 $y_i$ 地。猫猫需要只坐列车从 $1$ 节点到达 $n$ 节点。 设猫猫在一个地方等待的时间为 $t$，那么代价为 $At^2+Bt+C$，其中 $A\\ B\\ C$ 为给定非负常数，总代价为所有代价总和与到达时间的和。求最小代价。 思路设 $f_i$ 为走 $i$ 趟列车前的最小代价，有转移方程：$$f_i&#x3D;\\min_{y_j&#x3D;x_i\\land q_j\\leq q_i}(f_j+A(p_i-q_j)^2+B(p_i-q_j)+C)$$最终代价即为：$$\\min f_i+q_i$$对于第一个方程，不考虑其他限制，即为找到最优的 $j$ 更新 $i$，有：$$\\begin{aligned}f_i&amp;&#x3D;f_j+A(p_i-q_j)^2+B(p_i-q_j)+C\\f_i&amp;&#x3D;f_j+Ap_i^2+Aq_j^2-2Ap_iq_j+Bp_i-Bq_j+C\\f_j+Aq_j^2-Bq_j&amp;&#x3D;2Ap_iq_j+f_i-Ap_i^2-Bp_i-C\\end{aligned}$$对于已经更新过的 $j$，$f_j+Aq_j^2-Bq_j$ 是已知的。后半部分 $f_i-Ap_i^2-Bp_i-C$ 只有 $f_i$ 是未知的，也是我们要最优化的。 那么我们可以将上式看做 $y&#x3D;kx+b$ 的形式，其中$$\\begin{aligned}&amp;y&#x3D;f_j+Aq_j^2-Bq_j\\ &amp;x&#x3D;q_j\\ &amp;k&#x3D;2Ap_i\\ &amp;b&#x3D;f_i-Ap_i^2-Bp_i-C \\end{aligned}$$（常数其实可以属于任意一个位置，上述只是举例） 那么我们可以将所有可以转移到的 $j$ 看做一个二维平面上的点，每次更新 $f_i$ 实际是对一个斜率找出经过其中一个点得到的最优的 $b$。那么显然只会选到前者构成的凸包上的点。很多题查询的斜率都是单调的，而且之后在凸包后方插入新的点，于是维护凸包的数组就变成了单调队列。否则的话，就是动态维护凸包并在凸包上二分。 对于这道题，最优指最小，那么我们维护的是下凸包。 斜率优化的部分已经完了。考虑加入 $y_j&#x3D;x_i \\and q_j\\leq p_i$ 的限制怎么做。对于第一个限制，发现不同点互不影响，那么我们对每个点开一个单调队列，对于一个列车在它的 $x$ 位置查询就好了。对于第二个限制，我们将所有列车按照 $p$ 排序然后枚举时间，那么对于上面更新完的列车先不插入队列，当枚举时间到 $p$ 的时候再将其插入即可。这样就能满足所有限制，并且保证查询的斜率单调递增。 代码好像不会炸 long long 的样子。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e6+10; int n,T,m,A,B,C,st[maxn],ed[maxn],p[maxn],q[maxn],hd[maxn],tl[maxn]; long long f[maxn],x[maxn],y[maxn],ans=0x3f3f3f3f3f3f3f3f; vector&lt;int&gt; V[maxn],G[maxn],que[maxn]; inline void work()&#123; n=read(),m=read(),A=read(),B=read(),C=read(); for(int i=1;i&lt;=m;i++) st[i]=read(),ed[i]=read(),p[i]=read(),q[i]=read(),T=max(T,q[i]),G[p[i]].push_back(i); for(int i=1;i&lt;=n;i++) hd[i]=0,tl[i]=-1; for(int t=0;t&lt;=T;t++)&#123; for(auto i:V[t])&#123; int e=ed[i]; while(hd[e]&lt;tl[e] and 1ll*(y[que[e][tl[e]]]-y[que[e][tl[e]-1]])*(x[i]-x[que[e][tl[e]]])&gt;=1ll*(y[i]-y[que[e][tl[e]]])*(x[que[e][tl[e]]]-x[que[e][tl[e]-1]])) --tl[e]; if(++tl[e]==que[e].size()) que[e].push_back(i); else que[e][tl[e]]=i; &#125; for(auto i:G[t])&#123; int e=st[i]; while(hd[e]&lt;tl[e] and (y[que[e][hd[e]+1]]-y[que[e][hd[e]]])&lt;2ll*A*p[i]*(x[que[e][hd[e]+1]]-x[que[e][hd[e]]])) ++hd[e]; if(hd[e]&gt;tl[e] and st[i]!=1) continue; int j=st[i]==1 and hd[e]&gt;tl[e]?0:que[e][hd[e]]; f[i]=f[j]+1ll*A*(p[i]-q[j])*(p[i]-q[j])+1ll*B*(p[i]-q[j])+C; x[i]=q[i],y[i]=f[i]+1ll*A*q[i]*q[i]-1ll*B*q[i]; V[q[i]].push_back(i); if(ed[i]==n) ans=min(ans,f[i]+q[i]); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5658 括号树","slug":"P5658 括号树","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.453Z","comments":true,"path":"2022/04/30/P5658 括号树/","permalink":"https://starcried.github.io/2022/04/30/P5658%20%E6%8B%AC%E5%8F%B7%E6%A0%91/","excerpt":"","text":"P5658 括号树NOIp2019我是永远不会忘记我那天在考场上傻瞪着题啥都不会的心理阴影的…… 于是今天我克服心理阴影来写这道题。 树形结构因为这是一个树，所有优秀的性质这个题都有。并且题目仅仅是问从1开始到所有点的答案，所以我们就可以依靠树的性质来做。 首先，对于一个节点，我们给它记录几个值： $lst_i$表示i的贡献（只是i的贡献，并不包括从根节点到i路径上点的贡献） 那么我们发现这个lst是如何转移的。考虑一条到i的路径，如果i是后括号，那么$lst_i$即为与之配对的前括号的父节点的$lst$+1。因为假设这个前括号的父节点同样有一个已经匹配了的后括号，那么我们势必可以把当前的匹配和之前的匹配序列合并，当前的这个后括号的贡献值，其实就等于前面那个后括号的贡献值+1 $sum_i$表示从根节点到i的贡献的和。那么转移就是$sum_i&#x3D;sum_{fa_i}+lst_i$。 最后答案即为每个sum乘i的异或和。 然后按照树dfs一遍即可……吗？ dfs对于前括号和后括号我们用一个栈维护即可。遇到前括号入栈，后括号出栈并用上述方式处理，如果空栈就跳过。这里只需要注意一点：dfs之后需要将栈内修改的值重新放回去。 其余就没什么了。 （做不出来还是我太蔡了） 记得开long long。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define int long longusing namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125; namespace star&#123; const int maxn=5e5+10; int n,fa[maxn],ans,lst[maxn]; char s[maxn]; int ecnt,head[maxn],nxt[maxn],to[maxn],sum[maxn]; inline void addedge(int a,int b)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; &#125; stack&lt;int&gt; st; void dfs(int x)&#123; int tmp=0; if(s[x]==&#x27;(&#x27;)st.push(x); else&#123; if(!st.empty())&#123; tmp=st.top(); st.pop(); lst[x]=lst[fa[tmp]]+1; &#125; &#125; sum[x]=sum[fa[x]]+lst[x]; for(int i=head[x];i;i=nxt[i])dfs(to[i]); if(tmp)st.push(tmp); else if(!st.empty())st.pop(); &#125; inline void work()&#123; n=read(); scanf(&quot;%s&quot;,s+1); for(int a,i=2;i&lt;=n;i++) a=read(),addedge(a,i),fa[i]=a; dfs(1); for(int i=1;i&lt;=n;i++) ans^=(sum[i]*i); printf(&quot;%lld&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P5591 小猪佩奇学数学","slug":"P5591 小猪佩奇学数学","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.453Z","comments":true,"path":"2022/04/30/P5591 小猪佩奇学数学/","permalink":"https://starcried.github.io/2022/04/30/P5591%20%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87%E5%AD%A6%E6%95%B0%E5%AD%A6/","excerpt":"","text":"P5591 小猪佩奇学数学知识点二项式定理$$(x+1)^n&#x3D;\\sum_{i&#x3D;0}^n\\binom nix^i$$ 单位根反演$$[n\\mid k]&#x3D;\\frac 1n\\sum_{i&#x3D;0}^{n-1}\\omega_n^{ik}$$ 证明：$$[n\\mid k]&#x3D;\\begin{cases}\\frac 1n\\sum_{i&#x3D;0}^{n-1}\\omega_n^{ik}&#x3D;\\frac 1n\\sum_{i&#x3D;0}^{n-1}1&#x3D;1 &amp;,n\\mid k\\\\frac 1n\\sum_{i&#x3D;0}^{n-1}\\omega_n^{ik}&#x3D;\\frac 1n\\frac{\\omega_n^k-\\omega_n^{nk}}{1-\\omega_n^k}&#x3D;0 &amp;,n\\not\\mid k\\end{cases}$$ 题意求$$\\sum_{i&#x3D;0}^n\\binom ni p^i\\left\\lfloor\\frac ik\\right\\rfloor \\pmod{998244353}$$$1\\le n,p\\le998244353,k\\in{2^w|0\\le w\\le 20}$ 思路一看到前面这个形式容易想到二项式定理，但是后面这个 $\\left\\lfloor\\frac ik\\right\\rfloor$ 不好处理。 观察一下数据范围发现 $k$ 较小，考虑使用单位根反演，我们将柿子往这边化：$$\\left\\lfloor\\frac ik\\right\\rfloor&#x3D;(\\sum_{j&#x3D;0}^i[k\\mid j])-1&#x3D;(\\sum_{j&#x3D;0}^i[k\\mid j])-1&#x3D;(\\sum_{j&#x3D;0}^i\\frac 1k\\sum_{i&#x3D;0}^{k-1}\\omega_k^{ij})-1$$代入得到$$\\begin{aligned}&amp;\\sum_{i&#x3D;0}^n\\binom ni p^i\\left\\lfloor\\frac ik\\right\\rfloor\\&amp;&#x3D;\\sum_{i&#x3D;0}^n\\binom ni p^i\\sum_{j&#x3D;0}^i\\frac 1k\\sum_{d&#x3D;0}^{k-1}\\omega_k^{dj}-(\\sum_{i&#x3D;0}^n\\binom ni p^i)\\&amp;&#x3D;\\frac 1k\\sum_{d&#x3D;0}^{k-1}\\sum_{i&#x3D;0}^n\\binom ni p^i\\sum_{j&#x3D;0}^i\\omega_k^{dj}-(p+1)^n\\&amp;&#x3D;\\frac 1k(P+\\sum_{d&#x3D;1}^{k-1}\\sum_{i&#x3D;0}^n\\binom ni p^i\\frac{\\omega_k^{di+d}-1}{\\omega_k^d-1})-(p+1)^n\\&amp;&#x3D;\\frac 1k(P+\\sum_{d&#x3D;1}^{k-1}\\frac{\\sum_{i&#x3D;0}^n\\binom ni p^i(\\omega_k^{di+d}-1)}NaN)-(p+1)^n\\&amp;&#x3D;\\frac 1k(P+\\sum_{d&#x3D;1}^{k-1}\\frac{\\sum_{i&#x3D;0}^n\\binom ni p^i\\omega_k^{di+d}-\\sum_{i&#x3D;0}^n\\binom ni p^i}NaN)-(p+1)^n\\&amp;&#x3D;\\frac 1k(P+\\sum_{d&#x3D;1}^{k-1}\\frac{\\omega_k^d\\sum_{i&#x3D;0}^n\\binom ni p^i\\omega_k^{di}-\\sum_{i&#x3D;0}^n\\binom ni p^i}NaN)-(p+1)^n\\&amp;&#x3D;\\frac 1k(P+\\sum_{d&#x3D;1}^{k-1}\\frac{\\omega_k^d(p\\omega_k^d+1)^n-(p+1)^n}NaN)-(p+1)^n\\end{aligned}$$上式中 $P$ 是 $d$ 等于零的情况，此时 $\\sum_{j&#x3D;0}^i\\omega_k^{dj}$ 全为 1，公比为 1，不适用等比数列求和公式，我们单独算一下。由 $\\binom nmm&#x3D;\\binom {n-1}{m-1}n$，有 $$\\begin{aligned}P&amp;&#x3D;\\sum_{i&#x3D;0}^n\\binom ni p^i(i+1)\\&amp;&#x3D;(\\sum_{i&#x3D;0}^n\\binom ni p^ii)+(p+1)^n\\&amp;&#x3D;(np\\sum_{i&#x3D;0}^n\\binom {n-1}{i-1} p^{i-1})+(p+1)^n\\&amp;&#x3D;np(p+1)^{n-1}+(p+1)^n\\end{aligned}$$ 代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=(1&lt;&lt;10)+5,mod=998244353,g=3; int n,p,k,ans,rt; inline int fpow(int a,int b)&#123;int ans=1;for(;b;b&gt;&gt;=1,a=1ll*a*a%mod) if(b&amp;1) ans=1ll*ans*a%mod; return ans;&#125; inline void work()&#123; n=read(),p=read(),k=read(),rt=fpow(g,(mod-1)/k); ans=(1ll*n*p%mod*fpow(p+1,n-1)+fpow(p+1,n))%mod; for(int mul=rt,d=1;d&lt;k;d++,mul=1ll*mul*rt%mod) ans=(ans+(1ll*mul*fpow((1ll*p*mul+1)%mod,n)%mod-fpow(p+1,n)+mod)%mod*fpow((mul-1+mod)%mod,mod-2))%mod; ans=1ll*ans*fpow(k,mod-2)%mod; printf(&quot;%d\\n&quot;,(ans-fpow(p+1,n)+mod)%mod); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P6106 [Ynoi2010] Self Adjusting Top Tree","slug":"P6106 [Ynoi2010] Self Adjusting Top Tree","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.454Z","comments":true,"path":"2022/04/30/P6106 [Ynoi2010] Self Adjusting Top Tree/","permalink":"https://starcried.github.io/2022/04/30/P6106%20[Ynoi2010]%20Self%20Adjusting%20Top%20Tree/","excerpt":"","text":"P6106 [Ynoi2010] Self Adjusting Top Tree题意给出平面直角坐标系上若干不与坐标轴平行的处于第一象限的互不相交的线段，多次询问平面中一个第一象限的矩形与这些线段相交部分的长度长度和与所有线段长度和的比值。给出的所有坐标 $\\in[1,10^6]$。 思路假设所有线段的斜率都是正的，考虑将询问差分成四个前缀矩形。我们只需要考虑统计若干斜率为正的互不相交的线段与一个前缀矩形的交就行了。 经典套路：若线段互不相交，在扫描线时其相对顺序不会变。比如在用与 $y$ 轴平行的直线做扫描线时线段与其相交的 $y$ 坐标相对大小不会变。再比如，用以原点为端点的射线做扫描线时线段与其交点到原点距离的相对大小不会变。 因此，我们用平行于 $y$ 轴的直线做扫描线，用平衡树维护区间线段长度的和。即，维护单位 $x$ 区间线段长度增量，维护区间线段长度和，支持区间加，支持插入删除。因为线段斜率为正且询问为前缀矩形，所以没有线段另一端不在矩形内的情况。这样就能统计且恰好统计所有与矩形右侧相交的线段的长度和。 统计所有与矩形上侧相交的长度和只需要将扫描线变为与 $x$ 平行的再做一遍就可以了。为了使与顶点交的线段只统计一次，可以将翻转前后其中一次的所有查询减去 eps 使其不合法。 对于所有完全被包含的线段，发现只要线段右上端在矩形内就全部在矩形内。做一遍二维数点即可。 对于所有斜率为负的线段，将它们和询问矩形上下反转，然后再做一遍上述过程即可。 至此，所有的贡献被统计完毕。实现时请注意细节。 代码我觉得我写的还行，就放出来，看懂了的应该挺容易实现的，没看懂的可以参考代码。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=4e5+10,maxm=1e6+10,N=1e6+1; double eps=1e-6; int n,m,cnt[2],c[2][maxn]; double ans[maxn]; struct vec&#123; int x,y; vec(int x=0,int y=0):x(x),y(y)&#123;&#125; inline void updown()&#123;y=N-y;&#125; &#125;; int X; struct seg&#123; vec a,b; seg()&#123;&#125; seg(vec a,vec b):a(a),b(b)&#123;&#125; inline double length()&#123;return sqrt(1.*(b.y-a.y)*(b.y-a.y)+1.*(b.x-a.x)*(b.x-a.x));&#125; inline void updown()&#123;a.updown(),b.updown();&#125; inline double y() &#123;return a.y+1.0*(X-a.x)*(b.y-a.y)/(b.x-a.x);&#125; &#125;a[maxn],b[2][maxn]; struct que&#123; int x; double y; int tp,id; que()&#123;&#125; que(int x,double y,int tp,int id):x(x),y(y),tp(tp),id(id)&#123;&#125; bool operator &lt; (const que &amp;b) const &#123;return x&lt;b.x;&#125; &#125;q[maxn&lt;&lt;2]; #define ls son[x][0] #define rs son[x][1] double s1[maxn],s2[maxn],s[maxn],tag[maxn],sum[maxn]; int tot,rt,e[maxn],son[maxn][2],rnd[maxn]; inline int newnode(int i)&#123;e[++tot]=i,s1[tot]=s[tot]=a[i].length()/(a[i].b.x-a[i].a.x),s2[tot]=tag[tot]=son[tot][0]=son[tot][1]=sum[tot]=0,rnd[tot]=rand();return tot;&#125; inline void add(int x,int a)&#123;s2[x]+=a*s1[x],sum[x]+=a,tag[x]+=a;&#125; inline void pushdown(int x)&#123;if(tag[x]) add(ls,tag[x]),add(rs,tag[x]),tag[x]=0;&#125; inline void pushup(int x)&#123;s2[x]=s2[ls]+s2[rs]+sum[x]*s[x],s1[x]=s1[ls]+s1[rs]+s[x];&#125; void split(int x,double k,int &amp;a,int &amp;b)&#123; if(!x) return a=b=0,void(); pushdown(x); if(k&gt;=star::a[e[x]].y()) a=x,split(rs,k,rs,b); else b=x,split(ls,k,a,ls); pushup(x); &#125; int merge(int a,int b)&#123; if(!a or !b) return a|b; if(rnd[a]&lt;rnd[b])&#123; pushdown(a),son[a][1]=merge(son[a][1],b),pushup(a); return a; &#125;else&#123; pushdown(b),son[b][0]=merge(a,son[b][0]),pushup(b); return b; &#125; &#125; inline void insert(int i)&#123; int x,y; split(rt,a[i].y(),x,y); rt=merge(merge(x,newnode(i)),y); &#125; inline void update(int i)&#123; int a,b; split(rt,star::a[i].y(),a,b); static int st[maxn]; int top=0,x,y; for(y=0,x=a;rs;y=x,x=rs) pushdown(x),st[++top]=x; if(e[x]!=i) return rt=merge(merge(a,newnode(i)),b),void(); if(!y) a=son[a][0]; else son[y][1]=merge(ls,rs); while(top) pushup(st[top--]); rt=merge(a,b); &#125; inline double query(double k)&#123; int x,y; split(rt,k,x,y); double ans=s2[x]; rt=merge(x,y); return ans; &#125; #undef ls #undef rs double C[maxm]; inline void Insert(int x,double k)&#123;for(;x&lt;=N;x+=x&amp;-x) C[x]+=k;&#125; inline double Query(int x)&#123;double ans=0;for(;x;x-=x&amp;-x) ans+=C[x];return ans;&#125; inline void solve(int *c,int n,seg *b)&#123; int tot=0; for(int i=1;i&lt;=m;i++) q[++tot]=que(b[i].b.x,b[i].b.y-eps,1,i),q[++tot]=que(b[i].a.x,b[i].b.y-eps,-1,i),q[++tot]=que(b[i].b.x,b[i].a.y-eps,-1,i),q[++tot]=que(b[i].a.x,b[i].a.y-eps,1,i); sort(q+1,q+1+tot); if(eps!=0)&#123; sort(c+1,c+1+n,[](int x,int y)&#123;return a[x].b.x&lt;a[y].b.x;&#125;); for(int i=1,j=1;i&lt;=tot;i++)&#123; while(j&lt;=n and a[c[j]].b.x&lt;=q[i].x) Insert(a[c[j]].b.y,a[c[j]].length()),j++; ans[q[i].id]+=q[i].tp*Query(q[i].y+eps); &#125; &#125; static pair&lt;int,int&gt; op[maxn&lt;&lt;1]; for(int i=1;i&lt;=n;i++) op[i*2-1]=make_pair(a[c[i]].a.x,c[i]),op[i*2]=make_pair(a[c[i]].b.x,c[i]); n&lt;&lt;=1; sort(op+1,op+1+n); X=0; for(int i=1,j=1;i&lt;=tot;i++)&#123; while(j&lt;=n and op[j].first&lt;=q[i].x) add(rt,op[j].first-X),X=op[j].first,update(op[j].second),j++; add(rt,q[i].x-X),X=q[i].x,ans[q[i].id]+=q[i].tp*query(q[i].y); &#125; memset(C,0,sizeof C),rt=tot=0; &#125; inline void solve()&#123; solve(c[0],cnt[0],b[0]); solve(c[1],cnt[1],b[1]); &#125; inline void work()&#123; srand(time(0)); n=read(); double len=0; for(int i=1;i&lt;=n;i++)&#123; a[i].a.x=read(),a[i].a.y=read(),a[i].b.x=read(),a[i].b.y=read(); if(a[i].a.x&gt;a[i].b.x) swap(a[i].a,a[i].b); int t=a[i].a.y&gt;a[i].b.y; if(t) a[i].updown(); c[t][++cnt[t]]=i; len+=a[i].length(); &#125; m=read(); for(int i=1;i&lt;=m;i++) b[0][i].a.x=read(),b[0][i].a.y=read(),b[0][i].b.x=read(),b[0][i].b.y=read(),b[1][i]=b[0][i],b[1][i].updown(),swap(b[1][i].a.y,b[1][i].b.y); solve(); for(int i=1;i&lt;=n;i++) swap(a[i].a.x,a[i].a.y),swap(a[i].b.x,a[i].b.y); for(int i=1;i&lt;=m;i++) swap(b[0][i].a.x,b[0][i].a.y),swap(b[0][i].b.x,b[0][i].b.y),swap(b[1][i].a.x,b[1][i].a.y),swap(b[1][i].b.x,b[1][i].b.y); eps=0; solve(); for(int i=1;i&lt;=m;i++) printf(&quot;%.10f\\n&quot;,ans[i]/len); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P6753 [BalticOI 2013 Day1] Ball Machine","slug":"P6753 [BalticOI 2013 Day1] Ball Machine","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.455Z","comments":true,"path":"2022/04/30/P6753 [BalticOI 2013 Day1] Ball Machine/","permalink":"https://starcried.github.io/2022/04/30/P6753%20[BalticOI%202013%20Day1]%20Ball%20Machine/","excerpt":"","text":"P6753 [BalticOI 2013 Day1] Ball Machine题意给你一个树，每次从根节点放一个求，如果其子节点有空这个球会向下滚，若有多个节点为空则找儿子中以子树内编号的最小值为优先级从小到大找第一个为空的位置滚。 有两种操作，第一种插入若干个球，输出最后一个球到的节点编号；第二种删除一个位置，此时若有可以向下滚的球那么这个球就会滚，输出有多少个球滚了。 保证数据合法。 思路首先我们思考只有1操作的情况。 对于1操作，球加入的顺序为按照以子树内编号的最小值为优先级的后序遍历 dfs 序。我们得到了 40pts。 对于2操作，删掉一个球后答案一定是其所有祖先中有球的位置的个数。原因显然，因为删球前一定是最佳状态，即没有球能动，所以删掉这个球后只有其祖先会向下移动并且一定会向下移动。 发现祖先有球的段一定是连续的，于是我们就可以用倍增找到最浅的有球的祖先，并且顺便输出答案。 但是2操作后会把父亲节点删去。注意这时候删去的节点并非最后加入的点。而且下一次加入球时会找 dfs 序最小的。这时候我们就需要一些东西比如 stl 的 vector &#x2F; priority_queue &#x2F; set 进行维护了。 还有最最最重要的一点！对于操作1，我们是依次一个一个加入的，这样的时间复杂度为什么是正确的？ 显然，因为每个2操作只会删1个点，所以我们最多会插入 n+q 个点。所以要什么重链剖分和线段树暴力就能过 实现我用的是 vector 存储空节点来实现这个过程的。它的好处在于对于1操作删除是 $O(1)$ 的。不过插入必须用 upper_bound 和 insert 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int n,Q; int fa[maxn][21],rt,dfn[maxn],tot,id[maxn],mn[maxn]; bool vis[maxn]; vector&lt;int&gt; q,G[maxn]; void dfs1(int x)&#123; mn[x]=x; for(int i=0;i&lt;G[x].size();i++) dfs1(G[x][i]),mn[x]=min(mn[x],mn[G[x][i]]); &#125; inline bool cmp1(int a,int b)&#123;return mn[a]&lt;mn[b];&#125; void dfs(int x)&#123; for(int i=0;i&lt;20;i++) fa[x][i+1]=fa[fa[x][i]][i]; sort(G[x].begin(),G[x].end(),cmp1); for(int i=0;i&lt;G[x].size();i++) dfs(G[x][i]); dfn[x]=++tot; id[tot]=x; &#125; inline bool cmp(int a,int b)&#123;return dfn[a]&gt;dfn[b];&#125; inline void work()&#123; n=read(),Q=read(); for(int i=1;i&lt;=n;i++)&#123; if((fa[i][0]=read())==0) rt=i; G[fa[i][0]].push_back(i); &#125; dfs1(rt); dfs(rt);q.resize(n),q.clear(); for(int i=n;i;i--) q.push_back(id[i]); while(Q--) if(read()==1)&#123; int num=read(); while(--num)vis[q.back()]=1,q.pop_back(); printf(&quot;%d\\n&quot;,q.back()); vis[q.back()]=1;q.pop_back(); &#125;else&#123; int x=read(); if(!vis[x])&#123;puts(&quot;0&quot;);continue;&#125;//数据合法，好像没用 int f=x,ans=0; for(int i=20;~i;i--) if(vis[fa[f][i]])f=fa[f][i],ans|=(1&lt;&lt;i); vis[f]=0; q.insert(upper_bound(q.begin(),q.end(),f,cmp),f); printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 其他强烈吐槽洛谷的翻译！一直以为是以直接相连节点的编号大小为优先级，结果是子树内的最小值……建议大家看原题面。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P6295 有标号 DAG 计数","slug":"P6295 有标号 DAG 计数","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.454Z","comments":true,"path":"2022/04/30/P6295 有标号 DAG 计数/","permalink":"https://starcried.github.io/2022/04/30/P6295%20%E6%9C%89%E6%A0%87%E5%8F%B7%20DAG%20%E8%AE%A1%E6%95%B0/","excerpt":"","text":"P6295 有标号 DAG 计数题意求 $n$ 个点有标号弱联通 DAG 数量。 推导设 $f_i$ 表示 $i$ 个点有标号 DAG 数量（不保证弱联通），有：$$f(i)&#x3D;\\sum_{j&#x3D;1}^i\\binom ij(-1)^{j-1}f(i-j)2^{j(i-j)}$$意义为选至少 $j$ 个度数为零的点，向剩下的 $i-j$ 个点随便连有向边，容斥一下就得到了上式。 下面进行推导。根据一个 trick:$$j(i-j)&#x3D;\\binom i2-\\binom j2-\\binom {i-j}2$$所以有:$$\\begin{aligned}&amp;f(i)&#x3D;\\sum_{j&#x3D;1}^i\\frac{i!}{j!(i-j)!} (-1)^{j-1} f(i-j) \\frac{2^\\binom i2}{2^\\binom j22^\\binom{i-j}2}\\\\Rightarrow&amp;\\frac{f(i)}{i!2^\\binom i2}&#x3D;\\sum_{j&#x3D;1}^i\\frac{(-1)^{j-1}}{j!2^\\binom j2} \\frac{f(i-j)}{(i-j)!2^\\binom{i-j}2}\\end{aligned}$$设$$\\begin{aligned}F(x)&#x3D;\\sum_{i&#x3D;0}^\\infty\\frac{f(i)}{i!2^{\\binom i2}}\\ G(x)&#x3D;\\sum_{i&#x3D;1}^\\infty\\frac{(-1)^{i-1}}{i!2^\\binom i2}\\end{aligned}$$则有$$F(x)&#x3D;F(x)G(x)+1$$加 1 是因为常数项为 1. 解得$$F(x)&#x3D;\\frac1{1-G(x)}$$根据 $F$ 的定义，我们解出 $F$ 后乘上 $2^\\binom i2$ 即为 $f$ 的 EGF。根据多项式 ln 和 exp 的组合意义，我们将得到的 EGF ln 一下即可得到题目要求的弱联通的 DAG 数量的 EGF。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=4e5+10,mod=998244353,g=3,gi=998244354/3; inline int fpow(int a,long long b)&#123;int ans=1;for(;b;b&gt;&gt;=1,a=1ll*a*a%mod) if(b&amp;1) ans=1ll*ans*a%mod; return ans;&#125; struct NTT&#123; int r[maxn],lim; inline void getr(int li)&#123;lim=li;for(int i=0;i&lt;=lim;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(lim&gt;&gt;1));&#125; void operator () (int *a,int type) const &#123; for(int i=0;i&lt;lim;i++) if(i&lt;r[i]) swap(a[i],a[r[i]]); for(int mid=1;mid&lt;lim;mid&lt;&lt;=1)&#123; int rt=fpow(type==1?g:gi,(mod-1)/(mid&lt;&lt;1)); for(int r=mid&lt;&lt;1,j=0;j&lt;lim;j+=r)&#123; int p=1; for(int k=0;k&lt;mid;k++,p=1ll*p*rt%mod)&#123; int x=a[j+k],y=1ll*a[j+k+mid]*p%mod; a[j+k]=(x+y)%mod,a[j+k+mid]=(x-y+mod)%mod; &#125; &#125; &#125; if(type==-1) for(int p=fpow(lim,mod-2),i=0;i&lt;lim;i++) a[i]=1ll*a[i]*p%mod; &#125; &#125;ntt; void Inv(const int *a,int *ans,int n)&#123; if(n==1) return ans[0]=fpow(a[0],mod-2),ans[1]=0,void(); static int res[maxn]; Inv(a,ans,n&gt;&gt;1); int lim=n&lt;&lt;1; ntt.getr(lim); for(int i=0;i&lt;n;i++) res[i]=a[i]; for(int i=n;i&lt;lim;i++) ans[i]=res[i]=0; ntt(ans,1),ntt(res,1); for(int i=0;i&lt;lim;i++) ans[i]=ans[i]*(2-1ll*ans[i]*res[i]%mod+mod)%mod; ntt(ans,-1); for(int i=n;i&lt;lim;i++) ans[i]=0; &#125; inline void deri(const int *a,int *ans,int n)&#123;for(int i=1;i&lt;n;i++) ans[i-1]=1ll*a[i]*i%mod;ans[n-1]=0;&#125; inline void inte(const int *a,int *ans,int n)&#123;for(int i=n-1;i;i--) ans[i]=1ll*a[i-1]*fpow(i,mod-2)%mod;ans[0]=0;&#125; inline void ln(const int *a,int *ans,int n)&#123; static int res[maxn]; Inv(a,ans,n); deri(a,res,n); int lim=n&lt;&lt;1; ntt.getr(lim); ntt(ans,1),ntt(res,1); for(int i=0;i&lt;lim;i++) res[i]=1ll*ans[i]*res[i]%mod,ans[i]=0; ntt(res,-1); for(int i=n;i&lt;lim;i++) res[i]=0; inte(res,ans,n); &#125; int a[maxn],b[maxn],n,inv[maxn],mul[maxn]; inline void work()&#123; n=read(); inv[0]=mul[0]=1;for(int i=1;i&lt;=n;i++) mul[i]=1ll*mul[i-1]*i%mod; inv[n]=fpow(mul[n],mod-2);for(int i=n-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod; for(int i=1;i&lt;=n;i++) a[i]=(i&amp;1?mod-1ll:1ll)*inv[i]%mod*fpow(fpow(2,1ll*i*(i-1)/2),mod-2)%mod; a[0]=1; int lim=1;for(;lim&lt;=n;lim&lt;&lt;=1); Inv(a,b,lim); for(int i=0;i&lt;=n;i++) b[i]=1ll*b[i]*fpow(2,1ll*i*(i-1)/2)%mod,a[i]=0; for(int i=n+1;i&lt;lim;i++) a[i]=b[i]=0; ln(b,a,lim); for(int i=1;i&lt;=n;i++) printf(&quot;%lld\\n&quot;,1ll*a[i]*mul[i]%mod); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P6845 [CEOI2019] Dynamic Diameter","slug":"P6845 [CEOI2019] Dynamic Diameter","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.455Z","comments":true,"path":"2022/04/30/P6845 [CEOI2019] Dynamic Diameter/","permalink":"https://starcried.github.io/2022/04/30/P6845%20[CEOI2019]%20Dynamic%20Diameter/","excerpt":"","text":"P6845 [CEOI2019] Dynamic Diameter题意一颗带权树，每次更改一条边的权，每次修改后求出最大直径。强制在线。 思路$O(n\\log^2n)$ 的暴力做法。 根据经典结论，对于两个点集的树上最大直径（权值非负），并集点集的树上最大直径的端点一定是原四个端点中的两个。 那么我们就可以用线段树维护点集，合并时 $O(\\log n)$ 查询两点间距离合并就可以做到 $O(n\\log^2n)$ 的复杂度了。 思考如何支持在线修改边权。两点间距离为 $dis(x)+dis(y)-2*dis(lca(x,y))$ 那么先树剖发现修改一条边的权实际上是将子树内 $dis$ 增加，那么子树就是区间加。我们可以用树状数组维护修改。 考虑哪些部分的线段树上的点集最大直径被改了。发现子树内和子树外的最大直径不会变化，那么我们只需要更改子树内与外之间合并的最大直径就行了。我们按照 $dfn$ 用线段树进行维护，那么我们每次只需要将子树区间重新 pushup 一下就可以了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cstdlib&gt;#include&lt;utility&gt;using namespace std;inline long long read()&#123; long long x=0;int w=0;char c=getchar(); while(!isdigit(c)) w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c)) x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int n,q; int ecnt=1,head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],go[maxn]; long long W,w[maxn],dis[maxn]; inline void addedge()&#123; int a=read(),b=read(); to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt; w[ecnt&gt;&gt;1]=read(); &#125; int dep[maxn],fa[maxn],top[maxn],siz[maxn],son[maxn],dfn[maxn],id[maxn]; void dfs1(int x,int f)&#123; fa[x]=f,dep[x]=dep[f]+1,siz[x]=1; for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=f)&#123; dis[u]=dis[x]+w[i&gt;&gt;1],dfs1(u,x),go[i&gt;&gt;1]=u; if(siz[u]&gt;siz[son[x]]) son[x]=u; siz[x]+=siz[u]; &#125; &#125; void dfs2(int x,int topf)&#123; top[x]=topf,dfn[x]=++dfn[0],id[dfn[0]]=x; if(!son[x]) return; dfs2(son[x],topf); for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=fa[x] and u!=son[x]) dfs2(u,u); &#125; inline int LCA(int x,int y)&#123; while(top[x]!=top[y]) dep[top[x]]&gt;dep[top[y]]?(x=fa[top[x]]):(y=fa[top[y]]); return dep[x]&lt;dep[y]?x:y; &#125; #define ls (ro&lt;&lt;1) #define rs (ro&lt;&lt;1|1) #define mid ((l+r)&gt;&gt;1) namespace S&#123; long long c[maxn]; inline void upd(int x,long long k)&#123;for(;x&lt;=n;x+=x&amp;-x) c[x]+=k;&#125; inline long long query(int x)&#123;long long ans=dis[id[x]];for(;x;x-=x&amp;-x) ans+=c[x];return ans;&#125; inline void update(int x,int y,long long w)&#123;upd(x,w),upd(y+1,-w);&#125; &#125; inline long long Dis(pair&lt;int,int&gt; a)&#123;return S::query(dfn[a.first])+S::query(dfn[a.second])-2*S::query(dfn[LCA(a.first,a.second)]);&#125; namespace T&#123; pair&lt;int,int&gt; e[maxn&lt;&lt;2]; inline pair&lt;int,int&gt; merge(const pair&lt;int,int&gt;&amp; a,const pair&lt;int,int&gt;&amp; b)&#123; pair&lt;int,int&gt; p[6]=&#123;a,b,make_pair(a.first,b.first),make_pair(a.first,b.second),make_pair(a.second,b.first),make_pair(a.second,b.second)&#125;; long long dis[6]; for(int i=0;i&lt;6;i++) dis[i]=Dis(p[i]); return p[max_element(dis,dis+6)-dis]; &#125; void build(int ro=1,int l=1,int r=n)&#123; if(l==r) return e[ro]=make_pair(id[l],id[l]),void(); build(ls,l,mid),build(rs,mid+1,r); e[ro]=merge(e[ls],e[rs]); &#125; void update(int x,int y,int ro=1,int l=1,int r=n)&#123; if(x==l and y==r) return; if(y&lt;=mid) update(x,y,ls,l,mid); else if(x&gt;mid) update(x,y,rs,mid+1,r); else update(x,mid,ls,l,mid),update(mid+1,y,rs,mid+1,r); e[ro]=merge(e[ls],e[rs]); &#125; &#125; #undef ls #undef rs #undef mid inline void work()&#123; n=read(),q=read(),W=read(); for(int i=1;i&lt;n;i++) addedge(); dfs1(1,0),dfs2(1,1); T::build(); long long ans=0; while(q--)&#123; int e=(read()+ans)%(n-1)+1; long long v=(read()+ans)%W; S::update(dfn[go[e]],dfn[go[e]]+siz[go[e]]-1,v-w[e]),w[e]=v; T::update(dfn[go[e]],dfn[go[e]]+siz[go[e]]-1); printf(&quot;%lld\\n&quot;,ans=Dis(T::e[1])); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P7003 [NEERC2013]Hack Protection","slug":"P7003 [NEERC2013]Hack Protection","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.456Z","comments":true,"path":"2022/04/30/P7003 [NEERC2013]Hack Protection/","permalink":"https://starcried.github.io/2022/04/30/P7003%20[NEERC2013]Hack%20Protection/","excerpt":"","text":"P7003 [NEERC2013]Hack Protection题意给定一个序列 $a$ ，求有多少个区间满足区间内的数的异或和等于与的和的值。 思路首先我们求一个异或前缀和 $s$，对于每一个区间 $[l,r]$ ，它的贡献为区间内按位与的和等于 $s_r \\bigoplus s_{l-1}$ 的段的个数。 设 $x$ 为某个区间的按位与的和，上面的也就是：$$s_r \\bigoplus s_{l-1}&#x3D;x\\ \\Leftrightarrow \\ s_r&#x3D;x \\bigoplus s_{l-1}$$发现，如果我们固定 $x$ 和 $s_{l-1}$ ，那么 $s_r$ 就是固定的，我们就可以求区间内与 $s_r$ 相等的数的个数来统计答案。 考虑枚举 $l$ ，发现，对于往后按位与的过程，$x$ (与上文定义相同)最多会变化 $\\log$ 次，我们就可以将其分为这么多段，然后在 $s$ 中求与 $s_r$ 相等的数的个数就可以了。 求每一段的按位与结果，可以记录变成 0 的那一位是什么，或者直接 st 表查询都行。 对于最后一个问题，我们可以用主席树，或者简单地离散化加 vector 上二分即可。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;utility&gt;#define int unsigned using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int pre[maxn][35],n,a[maxn],b[maxn],s[maxn]; long long ans; vector&lt;int&gt; V[maxn]; pair&lt;int,int&gt; q[35]; inline void work()&#123; n=read(); for(int i=1;i&lt;=n;i++) s[i]=read(),a[i]=b[i]=a[i-1]^s[i]; sort(b+1,b+1+n); int cnt=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+1+cnt,a[i])-b; for(int i=1;i&lt;=n;i++) V[a[i]].push_back(i); for(int j=0;j&lt;31;j++) pre[n+1][j]=n+1; for(int i=n;i;i--) for(int j=0;j&lt;31;j++) pre[i][j]=((s[i]&gt;&gt;j)&amp;1)?pre[i+1][j]:i; for(int l=1;l&lt;=n;l++)&#123; int tot=0,x=s[l]; q[0].first=l; for(int j=0;j&lt;31;j++) if((s[l]&gt;&gt;j)&amp;1) q[++tot]=make_pair(pre[l][j],j); q[++tot]=make_pair(n+1,0); sort(q+1,q+1+tot); for(int i=1;i&lt;=tot;i++)&#123; int y=lower_bound(b+1,b+1+cnt,x^b[a[l-1]])-b; if(y&lt;=n and b[y]==(x^b[a[l-1]])) ans+=(lower_bound(V[y].begin(),V[y].end(),q[i].first)-lower_bound(V[y].begin(),V[y].end(),q[i-1].first)); x^=(1&lt;&lt;q[i].second); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P6982 [NEERC2015]Jump","slug":"P6982 [NEERC2015]Jump","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.455Z","comments":true,"path":"2022/04/30/P6982 [NEERC2015]Jump/","permalink":"https://starcried.github.io/2022/04/30/P6982%20[NEERC2015]Jump/","excerpt":"","text":"P6982 [NEERC2015]Jump题意给你一个未知的 01 串，每次可以输出询问一个 01 串，如果该串中正确的个数刚好等于 $n$ 或者 $n&#x2F;2$ ，将会返回相应的答案，否则会返回 0 。求出这个串。（询问次数不大于 $n+500$ ) 思路先无视询问次数，我们来想一下确定性算法怎么做。 第一步，我们来试着找出 $n&#x2F;2$ 正确的串。 首先，我们设一个全 0​ 串，每次修改最左边的 0 为 1，在这至多 $n$ 次询问中，我们一定能找到一个有 $n&#x2F;2$ 位正确的串。 正确性证明：假设全 0 时有小于 $n&#x2F;2$ 位正确，那么最糟情况，也就是变成全 1 时一定有多于 $n&#x2F;2$ 位正确；反之亦然。我们每次只改变一位的正确性，也就是说每次正确的位数只会改变 1，这样在移动的过程中一定会有一个情况恰好 $n&#x2F;2$ 位正确。 第二步，我们来找到正确的串。 我们固定一个位置，每次询问将该位置和其他一个位置取反。显然：若返回的答案为 $n&#x2F;2$ ，那么说明固定位置和这个位置的正确性是相反的。我们这样询问固定位置和其他每一个位置，就能够得到包含所有位置的两个正确性相反的集合。然后，我们将这个得到的 01 串和取反后的串询问，找到正确的输出即可。 于是我们得到一个询问次数为 $2n$ 的确定性算法。 过不了。怎么办呢？不要伤心，不要心急！然后我们发现第一步我们随机选择的正确率是挺高的。询问499次，每次询问有 $\\frac{\\tbinom{\\frac{n}{2}}{n}}{2^n}$ 的几率询问到 $n&#x2F;2$ 正确的串，询问499次后，发现这个几率非常大，用电脑算出来是 $0.99997$ ……于是我们就做完了。 实现记得清空缓冲区。下面的代码使用了阴间的bitset实现，常数挺大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; int n,ans; bitset&lt;1002&gt; a,b; inline void write(bitset&lt;1002&gt;&amp; x)&#123; for(int i=0;i&lt;n;i++) cout&lt;&lt;x[i]; cout&lt;&lt;endl; &#125; inline void work()&#123; srand(time(0)); ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=499;i++)&#123; for(int j=0;j&lt;n;j++) a[j]=rand()%2; write(a); cin&gt;&gt;ans; if(ans==n)return; else if(ans==n/2)break; &#125; a[0]=a[0]^1; for(int i=1;i&lt;n;i++)&#123; a[i]=a[i]^1; write(a); cin&gt;&gt;ans; b[i]=a[i]^(ans==n/2); a[i]=a[i]^1; &#125; b[0]=a[0]; write(b); cin&gt;&gt;ans; if(ans==n)return; b.flip(); write(b); cin&gt;&gt;ans; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P7362 [eJOI 2020 Day2] XOR Sort","slug":"P7362 [eJOI 2020 Day2] XOR Sort","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.457Z","comments":true,"path":"2022/04/30/P7362 [eJOI 2020 Day2] XOR Sort/","permalink":"https://starcried.github.io/2022/04/30/P7362%20[eJOI%202020%20Day2]%20XOR%20Sort/","excerpt":"","text":"P7362 [eJOI 2020 Day2] XOR Sort题意给你一个长度为 $n$ 的序列，每次操作可以将一个数异或上相邻的一个数，求将序列改为严格单调递增序列或严格单调不降序列的操作次数的操作序列。 注意，改为严格单调递增序列的数据 $n\\leq 200$ 且每个数不相同，改为严格单调不降序列的数据 $n\\leq 1000$。 不要求操作次数最小，次数需不大于 $40000$，元素大小小于 $2^{20}$。 思路严格单调递增序列的数据实测如果改了数列很容易造成数字相同然后挂掉的情况出现。反而严格单调不降的条件用异或容易满足且数据范围大。我们考虑对数据分治。 严格单调递增序列 我们考虑冒泡排序的思想，每次用异或交换相邻两项，可以过第一档部分分。 考虑优化这个过程。考虑每次将一个最大的数换到序列最后的方法。设$$A&#x3D;{a,b,c,d,e,f,g}$$若此时 $d$ 是最大的数，我们想把它换到最后面，设 $\\oplus $ 表示二进制异或操作，我们可以先将序列变为$${a\\oplus b,b\\oplus c,c\\oplus d,d\\oplus e,e\\oplus f,f\\oplus g,g}$$对于 $d\\oplus e$ 后面的元素，我们将它们按顺序与前一项异或，容易发现序列变为$${a\\oplus b,b\\oplus c,c\\oplus d,d\\oplus e,d\\oplus f,d\\oplus g,d}$$那么我们就将 $d$ 换到队尾去了。为了消除 $d$ 的影响，我们将前面的元素也进行类似的操作$${a\\oplus d,b\\oplus d,c\\oplus d,d\\oplus e,d\\oplus f,d\\oplus g,d}$$此时对于缩小了一个长度的序列重复进行求解即可。注意每次寻找的是原数列上的最大值而非每次更新完后的值。 操作次数为 $\\frac 12\\times 2n^2&#x3D;n^2$。 严格单调不降序列 从高位向低位考虑，每次我们仅考虑序列这一位的数，若非全 $0$ 则一定能通过异或将其变为只剩一个 $1$ 。从左往右考虑清零，若 $a_i$ 该位为 $1$，那么我们让 $a_{i+1}\\oplus a_i$ 使该位为 $1$（若本为 $1$ 则不操作）。操作完后使最后一位为 $1$，并将序列长度减 $1$（结尾位置前移）。 注意当有一位为全 $0$ 的时候我们不能将序列长度缩短，因为我们保证序列单调不降的方法是后面的最高位二进制位数比前面的大，全 $0$ 的话会导致不满足并被卡。虽然实际上该题数据没有卡这个。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;utility&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1005; int n,a[maxn]; int Ans; pair&lt;int,int&gt; ans[1000005]; inline void work1()&#123; static int b[maxn]; for(int i=1;i&lt;=n;i++) a[i]=b[i]=read(); for(int len=n-1;~len;len--)&#123; int x=0; for(int i=1;i&lt;=len+1;i++) if(b[i]&gt;b[x]) x=i; for(int i=1;i&lt;=len+1 and i&lt;n;i++) a[i]^=a[i+1],ans[++Ans]=make_pair(i,i+1); for(int i=x;i&lt;=len;i++) a[i+1]^=a[i],ans[++Ans]=make_pair(i+1,i),swap(b[i],b[i+1]); for(int i=x-1;i&gt;1;i--) a[i-1]^=a[i],ans[++Ans]=make_pair(i-1,i); &#125; &#125; inline void work2()&#123; for(int i=1;i&lt;=n;i++) a[i]=read(); for(int cnt=0,k=19;~k;k--)&#123; bool ok=false; for(int i=1;i&lt;=n-cnt;i++) ok|=(a[i]&gt;&gt;k)&amp;1; if(!ok) continue; for(int i=1;i&lt;n-cnt;i++) if((a[i]&gt;&gt;k)&amp;1)&#123; if((a[i+1]&gt;&gt;k)&amp;1^1) a[i+1]^=a[i],ans[++Ans]=make_pair(i+1,i); a[i]^=a[i+1],ans[++Ans]=make_pair(i,i+1); &#125; ++cnt; &#125; &#125;&#125;signed main()&#123; star::n=read(); if(read()==1) star::work1(); else star::work2(); printf(&quot;%d\\n&quot;,star::Ans); for(int i=1;i&lt;=star::Ans;i++) printf(&quot;%d %d\\n&quot;,star::ans[i].first,star::ans[i].second); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P7473 [NOI Online 2021 入门组] 重力球","slug":"P7473 [NOI Online 2021 入门组] 重力球","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.457Z","comments":true,"path":"2022/04/30/P7473 [NOI Online 2021 入门组] 重力球/","permalink":"https://starcried.github.io/2022/04/30/P7473%20[NOI%20Online%202021%20%E5%85%A5%E9%97%A8%E7%BB%84]%20%E9%87%8D%E5%8A%9B%E7%90%83/","excerpt":"","text":"P7473 [NOI Online 2021 入门组] 重力球题意给你一个正方形平面，某些位置有障碍，对于平面上两个球，每次你可以改变重力方向使两个球下落到最底端，求使两个球位置重合的最小改变重力次数。障碍固定，多次询问两个球的位置。 思路考虑最暴力的想法，总共有 $n^4$ 种状态，即两个球的坐标。 考虑优化状态数，发现只有障碍物（边界）旁边（四联通）的位置才有用。实际最大位置数为 $250\\times 4+250\\times 4&#x3D;2000$ 左右。那么实际状态数最大为 $2000\\times 2000&#x3D;4000000$ 左右。 我们把这些状态看做点，每个点只能有四条出边，那么边数和点数同阶。这样我们就有了另外一个暴力的想法：对于每个初始局面，暴力 BFS。 因为有多组询问考虑优化。实际上最终重合的状态有 $2000$ 个，我们反向建边，然后从这些点开始 BFS 出到所有状态的最小代价。每次查询的时候枚举第一次改变重力的方向即可。（注意判重合） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=255,maxm=2010; int n,m,Q,tot,a[maxn][maxn],t[maxn][maxn][4]; unsigned dis[maxm][maxm]; vector&lt;int&gt; to[maxm][4]; inline void addedge(int a,int b,int c)&#123;to[a][c].push_back(b);&#125; inline void work()&#123; n=read(),m=read(),Q=read(); while(m--) a[read()][read()]=-1; for(int i=1;i&lt;=n;a[0][i]=a[i][0]=a[n+1][i]=a[i][n+1]=-1,i++) for(int j=1;j&lt;=n;j++) if(!a[i][j] and (a[i-1][j]==-1 or a[i+1][j]==-1 or a[i][j-1]==-1 or a[i][j+1]==-1)) a[i][j]=++tot; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) t[i][j][0]=a[i][j-1]==-1?a[i][j]:t[i][j-1][0],t[i][j][1]=a[i-1][j]==-1?a[i][j]:t[i-1][j][1]; for(int i=n;i;i--) for(int j=n;j;j--) t[i][j][2]=a[i][j+1]==-1?a[i][j]:t[i][j+1][2],t[i][j][3]=a[i+1][j]==-1?a[i][j]:t[i+1][j][3]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(a[i][j]&gt;0) for(int k=0;k&lt;4;k++) addedge(t[i][j][k],a[i][j],k); static pair&lt;int,int&gt; q[maxm*maxm]; int hd=0,tl=0; memset(dis,-1,sizeof dis); for(int i=1;i&lt;=tot;i++) q[++tl]=make_pair(i,i),dis[i][i]=1; while(hd&lt;tl)&#123; pair&lt;int,int&gt; x=q[++hd]; for(int i=0;i&lt;4;i++) for(auto u:to[x.first][i]) for(auto v:to[x.second][i]) if(dis[u][v]==-1) dis[u][v]=dis[x.first][x.second]+1,q[++tl]=make_pair(u,v); &#125; while(Q--)&#123; int x1=read(),y1=read(),x2=read(),y2=read(); if(x1==x2 and y1==y2) puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;,min(&#123;dis[t[x1][y1][0]][t[x2][y2][0]],dis[t[x1][y1][1]][t[x2][y2][1]],dis[t[x1][y1][2]][t[x2][y2][2]],dis[t[x1][y1][3]][t[x2][y2][3]]&#125;)); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ3187 Backward Digit Sums","slug":"POJ3187 Backward Digit Sums","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.459Z","comments":true,"path":"2022/04/30/POJ3187 Backward Digit Sums/","permalink":"https://starcried.github.io/2022/04/30/POJ3187%20Backward%20Digit%20Sums/","excerpt":"","text":"Backward Digit Sums 好熟悉的题目&hellip;&hellip;但是忘了是怎么做的&hellip;&hellip;好像是随机排列？ 反正都是暴力，看了下网上的题解，好像也没有更好的正解了。有想法的告诉我一下蟹蟹~ 题意 我们可以用1~n这n个数字用类似杨辉三角的方法加起来，我们就可以把他们拆回去。这样的排列可能有多种，我们要它字典序最小的一种。 思路 n比较小，考虑排列所有可能一个个试&hellip;&hellip;这里用一下新东西。 next_permutation,意义为下一个排列，引用于&lt;algorithm&gt;头文件。 用法：next_permutation(a,a+n)表示排列a到a+n的下一种排序方法。若要排列整数，建立数组a，next_permutation(a,a+n)表示按字典序排列其第a[0]到a[n-1]元素。这和sort的范围表示类似。 next_permutation的返回值为布尔类型，如果能够继续排列并排列了就返回true。如果没有后续排列返回false。我们可以利用这个特性进行判断。 代码 1 #include&lt;iostream&gt; 2 #include&lt;cstring&gt; 3 #include&lt;cstdio&gt; 4 #include&lt;algorithm&gt; 5 #include&lt;queue&gt; 6 #include&lt;cmath&gt; 7 using namespace std; 8 int n,sum,a[100],A[100]; 9 void read(int &amp;x) 10 { 11 char c=getchar(); 12 while(c&lt;'0' or c&gt;'9')c=getchar(); 13 x=c-'0',c=getchar(); 14 while(c&gt;='0' and c&lt;='9') 15 x*=10,x+=c-'0',c=getchar(); 16 } 17 int main() 18 { 19 read(n);read(sum); 20 if(n==1){ 21 printf(\"1\\n\");return 0; 22 } 23 for(int i=0;i&lt;n;i++)A[i]=i+1; 24 do{//由于我们不想让next_permutation第一次就排列，我必须改掉总是先用while的坏习惯（并不 25 for(int i=0;i&lt;n;i++)a[i]=A[i]; 26 int cur=n; 27 bool ok=0; 28 while(cur&gt;1){ 29 for(int i=0;i&lt;cur-1;i++)a[i]=a[i]+a[i+1]; 30 if(cur==2 and a[0]==sum) 31 { 32 printf(\"%d\",A[0]); 33 for(int i=1;i&lt;n;i++)printf(\" %d\",A[i]); 34 printf(\"\\n\"); 35 return 0; 36 } 37 cur--; 38 } 39 }while(next_permutation(A,A+n)); 40 } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ1944","slug":"POJ1944","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.458Z","comments":true,"path":"2022/04/30/POJ1944/","permalink":"https://starcried.github.io/2022/04/30/POJ1944/","excerpt":"","text":"poj1944 一道我不会做的贪心题。 （思维才是OI的重点） 但是if您也不会，那就来听我瞎扯吧。 首先，这个图是一个圈，只能连接邻点，使所有求的点联通。 我们先不考虑环，那么就可以想出一个假的做法：用一个a数组记录入度和出度，出度为正，入度为负，用一个sum=0从0遍历每个点记录当前出入度，每次加ai，若sum大于0给答案加上1就行了。 然后，我们来考虑环。我们发现。不管怎么连这个图，肯定都会有一个断边的，连接的路径绝不会是一个完整的环。因为如果连成了完整地环，肯定有一条边断掉这个图还是联通的，即这条边是无用的。那么，我们欺负n小就可以分别从第i个点出发像上述查找一条链的做法一样地计算，然后取最大值就行了。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cctype&gt; using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=1010,maxm=10010; int n,m,a[maxn],l[maxm],r[maxm]; int main() { n=read(),m=read(); for(int i=0;i&lt;m;i++)l[i]=read(),r[i]=read(); int ans=0x3f3f3f3f; for(int i=0;i&lt;n;i++){ memset(a,0,sizeof a); int x,y; for(int j=0;j&lt;m;j++){ x=(l[j]+i)%n; y=(r[j]+i)%n; if(x&gt;y)swap(x,y); a[x]++; a[y]--; } int now=0,pre=0; for(int i=0;i&lt;n;i++){ now+=a[i]; if(now)pre++; } if(pre&lt;ans)ans=pre; } printf(\"%d\\n\",ans); return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ3048","slug":"POJ3048","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.458Z","comments":true,"path":"2022/04/30/POJ3048/","permalink":"https://starcried.github.io/2022/04/30/POJ3048/","excerpt":"","text":"素数筛，数据范围不大，直接暴力筛。 坑：有个数据是 1 1，答案是1.差点没把我卡去世。 我的三观哪去了。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;utility&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxp=2e4+5,maxn=5e3+5; int fac[maxp],a[maxn]; int main() { int n; std::ios::sync_with_stdio(false); cin&gt;&gt;n; int maxpp=0; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; maxpp=max(maxpp,a[i]); } fac[1]=1; for(int i=2;i&lt;=maxpp;i+=2)fac[i]=2; for(int i=3;i&lt;=maxpp;i+=2) if(!fac[i]) for(int j=i;j&lt;=maxpp;j+=i) fac[j]=i; int maxi; for(int zp,maxx=0,i=1;i&lt;=n;i++) { zp=a[i]; if(fac[zp]&gt;maxx)maxx=fac[zp],maxi=zp; } printf(\"%d\",maxi); return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ3190 - 优先队列 贪心","slug":"POJ3190 - 优先队列 贪心","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.459Z","comments":true,"path":"2022/04/30/POJ3190 - 优先队列 贪心/","permalink":"https://starcried.github.io/2022/04/30/POJ3190%20-%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%20%E8%B4%AA%E5%BF%83/","excerpt":"","text":"POJ3190 将所有牛从小到大排序然后用优先队列（小根堆）依次记录插入的牛的结束时间，如果插入牛时起始时间大于首元素，ans不增加并弹出首元素。 挺简单的。那么为什么我会写（水）这篇博客呢？ #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;utility&gt; #include&lt;vector&gt; #include&lt;ctype.h&gt; using namespace std; const int maxn=5e4+10; inline int read() { int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } pair&lt;pair&lt;int,int&gt;,int&gt; a[maxn]; int n,id[maxn]; int main() { n=read(); priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt; q; for(int i=1;i&lt;=n;i++) { a[i].first.first=read(),a[i].first.second=read(); a[i].second=i; } int ans=0,tmp; sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++) { if(q.empty() or q.top().first&gt;=a[i].first.first) tmp=++ans; else tmp=q.top().second,q.pop(); q.push(make_pair(a[i].first.second,tmp)); id[a[i].second]=tmp; } printf(\"%d\\n\",ans); for(int i=1;i&lt;=n;i++) printf(\"%d\\n\",id[i]); return 0; } /* 5 1 10 2 4 3 6 5 8 4 7 */ 如果您勇于实践，您会发现这个代码tle了。初步判定是我pair套多了。因为您随便在其他博客扒一个代码都会过。 这是一个教训。 还有就是注意priority_queue的排序方式。 如果queue中没有元素而您用访问top的话会挂。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ3268[非公开][草稿]","slug":"POJ3268[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.461Z","comments":true,"path":"2022/04/30/POJ3268[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/POJ3268[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"Silver Cow Party 题意：求有向图一个点与其他所有点往返最短路径的最大值。 思路：主要就是往返有问题，因为又是有向图，所以我们只得乖乖跑两遍。我们考虑n&lt;=1000，lwc曾经曰过，n&lt;=5000就可以用二维数组暴力。当然我们不会暴力，但是我们可以用矩阵存储这个10002的图。这样一来我们就可以转换矩阵以推出","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ3264线段树求最值","slug":"POJ3264线段树求最值","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.460Z","comments":true,"path":"2022/04/30/POJ3264线段树求最值/","permalink":"https://starcried.github.io/2022/04/30/POJ3264%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B1%82%E6%9C%80%E5%80%BC/","excerpt":"","text":"刚开始还觉得有点怪怪的。因为想着如果每个树只是单纯地记录它所在的区间的话会不会有不在区间内的数据给更新了，但是我好像是傻掉了因为如果有这种情况出现的话在父亲节点就会分成l,mid和mid+1,r两个区间查找，当节点区间和查找的区间完全吻合时就ok了。 这道题没有修改，连懒标记都不需要，是一道实打实的板子我却浪费了这么长时间我恨我自己 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;ctype.h&gt; #include&lt;cstring&gt; using namespace std; const int maxn&#x3D;50005;inline int read(){ int x&#x3D;0,w&#x3D;0;char c&#x3D;getchar(); while(!isdigit(c))w|&#x3D;c&#x3D;&#x3D;‘-‘,c&#x3D;getchar(); while(isdigit(c))x&#x3D;(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c&#x3D;getchar(); return w?-x:x;}struct SegmentTree{ struct Node{ int l,r; int mx,mn; int tagmx,tagmn; }e[4*maxn]; #define ls (ro&lt;&lt;1) #define rs (ro&lt;&lt;1|1) #define INF 0x3f3f3f3f &lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; maxx,minn; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; n,m; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; build(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; ro,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; r) &#123; e[ro].l&lt;/span&gt;=l,e[ro].r=&lt;span style=&quot;color: #000000;&quot;&gt;r; e[ro].mn&lt;/span&gt;=INF,e[ro].mx=-&lt;span style=&quot;color: #000000;&quot;&gt;INF; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(l==r)&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mid=(l+r)&amp;gt;&amp;gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; build(ls,l,mid); build(rs,mid&lt;/span&gt;+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,r); &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; insert(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; ro,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; k) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[ro].l==&lt;span style=&quot;color: #000000;&quot;&gt;e[ro].r)&#123; e[ro].mx&lt;/span&gt;=e[ro].mn=k;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &#125; e[ro].mn&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;min(e[ro].mn,k); e[ro].mx&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;max(e[ro].mx,k); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mid=(e[ro].l+e[ro].r)&amp;gt;&amp;gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(i&amp;lt;=&lt;span style=&quot;color: #000000;&quot;&gt;mid)insert(ls,i,k); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; insert(rs,i,k); &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; query(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; ro,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; r) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[ro].mn&amp;gt;=minn and e[ro].mx&amp;lt;=maxx)&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[ro].l==l and e[ro].r==&lt;span style=&quot;color: #000000;&quot;&gt;r)&#123; minn&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;min(minn,e[ro].mn); maxx&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;max(maxx,e[ro].mx); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mid=(e[ro].l+e[ro].r)&amp;gt;&amp;gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(r&amp;lt;=&lt;span style=&quot;color: #000000;&quot;&gt;mid)query(ls,l,r); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(l&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;mid)query(rs,l,r); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt; &#123;query(ls,l,mid);query(rs,mid+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,r);&#125; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; getans() &#123; n&lt;/span&gt;=read();m=&lt;span style=&quot;color: #000000;&quot;&gt;read(); build(&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;,&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,n); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span style=&quot;color: #000000;&quot;&gt;) insert(&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,i,read()); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;i&amp;lt;=m;i++&lt;span style=&quot;color: #000000;&quot;&gt;) &#123; maxx&lt;/span&gt;=-INF,minn=&lt;span style=&quot;color: #000000;&quot;&gt;INF; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l=read(),r=&lt;span style=&quot;color: #000000;&quot;&gt;read(); query(&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,l,r); printf(&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;%d\\n&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;,maxx-&lt;span style=&quot;color: #000000;&quot;&gt;minn); &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#undef&lt;/span&gt; ls &lt;span style=&quot;color: #0000ff;&quot;&gt;#undef&lt;/span&gt; rs &lt;span style=&quot;color: #0000ff;&quot;&gt;#undef&lt;/span&gt; INF&lt;span style=&quot;color: #000000;&quot;&gt; }st;int main(){ st.getans(); return 0;} 用一下结构体~","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ3268-最短路径-反向存边","slug":"POJ3268-最短路径-反向存边","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.460Z","comments":true,"path":"2022/04/30/POJ3268-最短路径-反向存边/","permalink":"https://starcried.github.io/2022/04/30/POJ3268-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%8F%8D%E5%90%91%E5%AD%98%E8%BE%B9/","excerpt":"","text":"因为是单向边，牛儿来回的路径长度并不相同，所以需要用两次dijkstra，一次正向从x开始dijkstra，再将边全部反向存再来一次。 因为是板子题比较良心n比较小，我们就可以用矩阵来存储啦。如果n比较大的话，我的想法是再造一个图，同时反向存边。内存可能占用比较大但是想起来简单。 代码很短。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;utility&gt; #include&lt;vector&gt; #include&lt;functional&gt; #include&lt;ctype.h&gt; using namespace std; typedef pair&lt;int,int&gt; pairr; const int maxn=1005; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } int mapp[maxn][maxn]; int n,m,t; int dis[maxn]; inline void dijkstra(int st) { memset(dis,0x3f3f3f3f,sizeof dis); priority_queue &lt;pairr,vector&lt;pairr &gt;,greater&lt;pairr &gt; &gt;q; q.push(make_pair(0,st));dis[st]=0; while(!q.empty()) { int v=q.top().second;q.pop(); for(int i=1;i&lt;=n;i++) if(mapp[v][i]) { if(dis[i]&gt;dis[v]+mapp[v][i]) { dis[i]=dis[v]+mapp[v][i]; q.push(make_pair(dis[i],i)); } } } } int way[maxn]; int main() { n=read();m=read();t=read(); for(int i=1;i&lt;=m;i++) mapp[read()][read()]=read(); dijkstra(t); for(int i=1;i&lt;=n;i++)way[i]=dis[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;i;j++)swap(mapp[i][j],mapp[j][i]); dijkstra(t); int ans=0; for(int i=1;i&lt;=n;i++)ans=max(ans,dis[i]+way[i]); printf(\"%d\\n\",ans); return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ3615-Floyd","slug":"POJ3615-Floyd","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.461Z","comments":true,"path":"2022/04/30/POJ3615-Floyd/","permalink":"https://starcried.github.io/2022/04/30/POJ3615-Floyd/","excerpt":"","text":"http://poj.org/problem?id=3615 因为只需要求所在路径的最大高度的最小值，而且n&lt;=300,我们可以用floyd跑。 g[i][j]=min(g[i][j],max(g[i][k],g[k][j]),简单地比大小，求最大值的最小值。 注意要先将g设为无限大。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;ctype.h&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; inline int read() { int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=305,maxm=25005,INF=0x3f3f3f3f; /*憨憨行为请无视 struct Edge{ int to,nxt,h; }e[maxm]; int ecnt,head[maxn]; inline void addedge(int from,int to,int h) { e[++ecnt]=(Edge){to,head[from],h};head[from]=ecnt; } */ int n,m,t; int g[maxn][maxn]; int main() { memset(g,INF,sizeof g); n=read();m=read();t=read(); for(int i=1;i&lt;=m;i++) g[read()][read()]=read(); for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) g[i][j]=min(g[i][j],max(g[i][k],g[k][j])); for(int a,b,i=1;i&lt;=t;i++) { a=read(),b=read(); if(g[a][b]==INF)printf(\"-1\\n\"); else printf(\"%d\\n\",g[a][b]); } return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"Tarjan判断为什么不能把dfn写成low","slug":"Tarjan判断为什么不能把dfn写成low","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.463Z","comments":true,"path":"2022/04/30/Tarjan判断为什么不能把dfn写成low/","permalink":"https://starcried.github.io/2022/04/30/Tarjan%E5%88%A4%E6%96%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8Adfn%E5%86%99%E6%88%90low/","excerpt":"","text":"Tarjan，我相信大多数人是这么写的： void tarjan(int x) { dfn[x]=low[x]=++cnt; st.push(x),vis[x]=1; for(int i=head[x];i;i=nxt[i]) { int u=to[i]; if(!dfn[u]) { tarjan(u); low[x]=min(low[x],low[u]); }else if(vis[u]) low[x]=min(low[x],dfn[u]); } //...... } 那么，在else句中，为什么是low[x]=min(low[x],dfn[u])而非low[x]=min(low[x],low[u])呢？ 我们来观察这样一个图： （画图工具画的有点难看） 很明显，③是割点。如果从1开始Tarjan，我们发现，如果用dfn更新，那么1、2、3在同一个强连通分量，即low=1。而4、5的low则是3.这样是正确的。 但如果用low更新的话，4、5的low全部都将更新为1.因为当5查询到3时，若用low更新5的low，5的low就被更新为3的low&mdash;&mdash;1.这显然是错误的。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"POJ3662","slug":"POJ3662","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.461Z","comments":true,"path":"2022/04/30/POJ3662/","permalink":"https://starcried.github.io/2022/04/30/POJ3662/","excerpt":"","text":"poj3662 大意：n个点p条边的无向图，求在删去k条边后使1和n号点联通路径上的最长边最小值。 一开始理解错题意以为是分层图求最短路径，结果写完发现k太大了发现事情没有那么简单（讨厌英语题面！） 说一下解法吧，二分答案，尽量小，每次二分完跑最短路径，但是要重置边权。即把比答案小的边改为0，比答案大的改为1，若最短路径比k大，就加答案；反之亦然。 （还好都有最短路径算没白写） 唯一的一点技巧：最初想着每次找完mid把所有边的权值改一下，觉得太麻烦了，那么就每次dijkstra加点的时候判断一下吧！（反正又占不了多少时间&hellip;&hellip;吧） #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;cctype&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } namespace star { const int maxn=1010,maxm=1000010; int n,m,k; int ecnt,head[maxn],nxt[maxm],t[maxm],val[maxm]; inline void addedge(int from,int to,int dis){ t[++ecnt]=to;nxt[ecnt]=head[from];head[from]=ecnt;val[ecnt]=dis; } typedef pair&lt;int,int&gt; pii; int dis[maxn]; inline void dijkstra(int mid) { priority_queue&lt;pii,vector&lt;pii &gt;,greater&lt;pii &gt; &gt; q; q.push(make_pair(0,1)); memset(dis,0x3f3f3f3f,sizeof dis); dis[1]=0; while(!q.empty()) { int x=q.top().second;q.pop(); for(int i=head[x];i;i=nxt[i]){ int u=t[i]; if(dis[u]&gt;dis[x]+(val[i]&gt;mid)){ dis[u]=dis[x]+(val[i]&gt;mid); q.push(make_pair(dis[u],u)); } } } } inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; work() &#123; n&lt;/span&gt;=read(),m=read(),k=&lt;span style=&quot;color: #000000;&quot;&gt;read(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mlen=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; a,b,c,i=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;i&amp;lt;=m;i++&lt;span style=&quot;color: #000000;&quot;&gt;) &#123; a&lt;/span&gt;=read(),b=read(),c=&lt;span style=&quot;color: #000000;&quot;&gt;read(); mlen&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;max(mlen,c); addedge(a,b,c); addedge(b,a,c); &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;,r=&lt;span style=&quot;color: #000000;&quot;&gt;mlen; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;while&lt;/span&gt;(l&amp;lt;&lt;span style=&quot;color: #000000;&quot;&gt;r)&#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mid=l+r&amp;gt;&amp;gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; dijkstra(mid); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(dis[n]==&lt;span style=&quot;color: #800080;&quot;&gt;0x3f3f3f3f&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;)&#123; printf(&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;-1\\n&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;);&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(dis[n]&amp;gt;k)l=mid+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt; r=&lt;span style=&quot;color: #000000;&quot;&gt;mid; &#125; printf(&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;%d\\n&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,l); &#125; }int main(){ star::work(); return 0;}&#x2F;5 7 11 2 53 1 42 4 83 2 35 2 93 4 74 5 6&#x2F; &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"Splay","slug":"Splay","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.462Z","comments":true,"path":"2022/04/30/Splay/","permalink":"https://starcried.github.io/2022/04/30/Splay/","excerpt":"","text":"学习自该博客 （dalao讲得真好，我只为了记忆写重点） Splay是一种数据结构，用于在线调整二叉排序树的操作，用于让树平衡（空树或任意节点的左右两个子树的深度差的绝对值不超过1）转换根节点或者其他操作。 二叉排序树，左子树任意一个点的值小于根节点，右子树任意一个点大于根节点的树。很显然，如果你想把一群点构造成这样一个树，你可以构造出许多不同的、满足关系的树。 （以下所有图片来自网上） 比如下面两个树就是等价的： 不平衡 平衡 &nbsp; &nbsp; 那么Splay要怎么旋转呢？大概是把要旋转的点更改到它的父亲节点的位置。我们发现，要满足关系，如果原来的点在父节点的右子树，旋转后父节点就连接在该节点的左子树上。反之亦然。大概是这样的： &nbsp; 差不多就是这样。 可以用结构体或者数组记录节点信息。我就写个结构体吧因为dalao的是用数组的。 struct tree{ int val,fa,son[2],cnt,siz; //val权 fa父节点 son[0]左节点 son[1]右节点 cnt出现次数 siz树大小（包括子树siz和自身cnt） } int siz,root;//siz时间戳,root根节点（因为splay会更改根节点） 插入时用三种情况：空树，直接插入；查询到权相同的点，cnt++；没有查询到点，向下插入新点。 inline void insert(int x) { if(siz==0){ siz++; e[siz].son[1]=e[siz].son[0]=e[siz].fa=0; e[siz].siz=e[siz].cnt=1; root = 1; e[siz].val=x; return; } int now=root,f=0; while(1){ if(e[now].val==x){ e[now].cnt++; update(now); update(f); splay(now，0); break; } f=now; now=son[now][x&gt;e[now].val]; if(!now){ siz++; e[siz].son[1]=e[siz].son[0]=0; e[siz].fa=f; e[siz].siz=e[siz].cnt=1; e[f].son[x&gt;e[now].val]=siz; e[siz].val=x; update(f); splay(siz，0); break; } } } 如果没有重复的值，你也可以直接dfs建树。 int build_tree(int l,int r,int f){ if(l &gt; r)return 0; int mid=l+r&gt;&gt;1; int now=++siz; e[now].fa=f; e[now].son[0]=e[now].son[1]=0; e[now].cnt++; e[now].val=a[mid]; e[now].siz++; e[now].son[0]=build_tree(l,mid-1,now); e[now].son[1]=build_tree(mid+1,r,now); update(now); return now; } 那么我们刚才说了那么久的旋转代码如下： inline void rotate(int x) { int f=e[x].fa,ff=e[f].fa;//记录父节点和祖父节点 bool w=which(x);//splay[自动]旋转的奥秘，得到x的位置 //以下旋转共6步，就是分别记录三个点间的关系，便于记忆 e[f].son[w]=e[x].son[w^1]; e[e[f].son[w]].fa=f; e[f].fa=x; e[x].son[w^1]=f; e[x].fa=ff; if(ff) e[ff].son[e[ff].son[1]==f]=x; update(f); update(x); &#125;&lt;/span&gt;&lt;/pre&gt; 这里有个问题：如果连续的两条边方向相同，若只是将底部的点向上旋转会单旋使树失衡。那么我们只要在旋转之前把父节点旋转一下就好了。具体的图请看dalao博客（不想复制以防侵权） goal是旋转的目标点，旋转后x节点会在goal的子节点。 inline void splay(int x,int goal){ for(int i;(i=e[x].fa)!=goal;rotate(x)) { if(e[i].fa!=goal){ rotate(which(x)==which(i)?i:x); } } if(goal==0) root=x; } 查询：查询点的位置，我们按从小到大查询。发现因为子树的siz是全部小于节点的，所以如果x（要查询的数）&lt;=siz[son[0]]，我们往左查询；否则x-=siz[son[0]]，跳到右子树重复查询，直到x==0，返回查到的点就ok了。 inline int find(int x) { int now=root; while(1) { pushdown(now); if(x&lt;=e[e[now].son[0]].siz) now=e[now].son[0]; else{ x-=e[e[now].son[0]].siz+1; if(!x)return now; now=e[now].son[1]; } } } 查询前驱和后继，就是查询和这个点左右最近的两个点，先把它变为根节点，再查询左子树的最右节点和右子树最左节点： int findpre(int x)//注意x是编号而不是值,这个查前驱 { splay(x,0)； //注意变成根节点。如果不是那么下面都是假的 int now=son[x][0]; while(son[now][1])now=son[now][1]; return now; } 后缀一样（当然是相反）。 删除有点麻烦留坑待填. 大概的思路： if节点有多个数，即cnt&gt;1，直接减去就好了。 else if节点没有子树，直接删掉就好了。 else if只有左子树，用左儿子替代之。 else if只有右子树，用右儿子替代之。 else if左右子树都有，我们把它的前驱作为新根，把它splay一下，然后把原来点的右儿子连成它的右儿子就OK了。 写个例题吧： P3391文艺平衡树 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;ctype.h&gt; #define INF 0x3f3f3f3f using namespace std; inline int read() { int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } namespace star { const int maxn=1e5+10; int n,m,root,siz,a[maxn]; struct node{ int son[2],siz,fa,tag,cnt,val; }e[maxn]; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;bool&lt;/span&gt; which(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; x)&#123;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt; e[e[x].fa].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;]==&lt;span style=&quot;color: #000000;&quot;&gt;x;&#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; update(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; x)&#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(!x)&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; e[x].siz&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;e[x].cnt; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[x].son[&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;])e[x].siz+=e[e[x].son[&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]].siz; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[x].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;])e[x].siz+=e[e[x].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]].siz; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; pushdown(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; x)&#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(x and e[x].tag)&#123; e[e[x].son[&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;]].tag^=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; e[e[x].son[&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;]].tag^=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; e[x].tag&lt;/span&gt;=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; swap(e[x].son[&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;],e[x].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]); &#125; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; rotate(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; x) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; f=e[x].fa,ff=e[f].fa;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;记录父节点和祖父节点 &lt;/span&gt; pushdown(x),pushdown(f); bool w&#x3D;which(x);&#x2F;&#x2F;splay[自动]旋转的奥秘，得到x的位置 &#x2F;&#x2F;以下旋转共6步，就是分别记录三个点间的关系，便于记忆 e[f].son[w]&#x3D;e[x].son[w^1]; e[e[f].son[w]].fa&#x3D;f; e[f].fa&#x3D;x; e[x].son[w^1]&#x3D;f; e[x].fa&#x3D;ff; if(ff) e[ff].son[e[ff].son[1]&#x3D;&#x3D;f]&#x3D;x; update(f); update(x); &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; splay(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; x,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; goal)&#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i;(i=e[x].fa)!=&lt;span style=&quot;color: #000000;&quot;&gt;goal;rotate(x)) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[i].fa!=&lt;span style=&quot;color: #000000;&quot;&gt;goal)&#123; rotate(which(x)&lt;/span&gt;==which(i)?&lt;span style=&quot;color: #000000;&quot;&gt;i:x); &#125; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(goal==&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;) root=&lt;span style=&quot;color: #000000;&quot;&gt;x; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; build_tree(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; r,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; f)&#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(l &amp;gt; r)&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mid=l+r&amp;gt;&amp;gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; now=++&lt;span style=&quot;color: #000000;&quot;&gt;siz; e[now].fa&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;f; e[now].son[&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;]=e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;]=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; e[now].cnt&lt;/span&gt;++&lt;span style=&quot;color: #000000;&quot;&gt;; e[now].val&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;a[mid]; e[now].siz&lt;/span&gt;++&lt;span style=&quot;color: #000000;&quot;&gt;; e[now].son[&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;]=build_tree(l,mid-&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,now); e[now].son[&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;]=build_tree(mid+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,r,now); update(now); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; now; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; find(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; x) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; now=&lt;span style=&quot;color: #000000;&quot;&gt;root; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;while&lt;/span&gt;(&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;) &#123; pushdown(now); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(x&amp;lt;=e[e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;]].siz) now=e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&#123; x&lt;/span&gt;-=e[e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;]].siz+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(!x)&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; now; now&lt;/span&gt;=e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]; &#125; &#125; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; reverse(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; x,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; y) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l=find(x-&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;),r=find(y+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); splay(l,&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); splay(r,l); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; pos=e[root].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]; pos&lt;/span&gt;=e[pos].son[&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]; e[pos].tag&lt;/span&gt;^=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; dfs(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; now)&#123; pushdown(now); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;])dfs(e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[now].val!=INF and e[now].val!=-INF)printf(&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;%d &lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,e[now].val); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;])dfs(e[now].son[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]); &#125; &#x2F; inline void insert(int x) { if(siz&#x3D;&#x3D;0){ siz++; e[siz].son[1]&#x3D;e[siz].son[0]&#x3D;e[siz].fa&#x3D;0; e[siz].siz&#x3D;e[siz].cnt&#x3D;1; root &#x3D; 1; e[siz].val&#x3D;x; return; } int now&#x3D;root,f&#x3D;0; while(1){ if(e[now].val&#x3D;&#x3D;x){ e[now].cnt++; update(now); update(f); splay(now,0); break; } f&#x3D;now; now&#x3D;son[now][x&gt;e[now].val]; if(!now){ siz++; e[siz].son[1]&#x3D;e[siz].son[0]&#x3D;0; e[siz].fa&#x3D;f; e[siz].siz&#x3D;e[siz].cnt&#x3D;1; e[f].son[x&gt;e[now].val]&#x3D;siz; e[siz].val&#x3D;x; update(f); splay(siz,0); break; } } }&#x2F; inline void work() { n&#x3D;read(),m&#x3D;read(); a[1]&#x3D;-INF,a[n+2]&#x3D;INF; for(int i&#x3D;1;i&lt;&#x3D;n;i++)a[i+1]&#x3D;i; root&#x3D;build_tree(1,n+2,0); for(int i&#x3D;1;i&lt;&#x3D;m;i++){ int x&#x3D;read(),y&#x3D;read(); reverse(x+1,y+1); } dfs(root); }}int main(){ star::work(); return 0;} 好长丫~~~ &nbsp;注意，每次更新完都splay是必要的，这会更新所有节点的siz值，否则是假的。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"Trie树","slug":"Trie树","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.465Z","comments":true,"path":"2022/04/30/Trie树/","permalink":"https://starcried.github.io/2022/04/30/Trie%E6%A0%91/","excerpt":"","text":"就是把字符串转变成一个树，每个节点连接下一个字符，用空间换时间。 对于区分大小写或不区分的题目，只需要改变ch[][26]的值就行了。 ch[u][x]表示u节点（标号决定）下一个x字符节点的标号。 如果题目让记录附加值，那就用val[标号]在插入时记录一下就好了。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int maxn=2333; struct trie{ ll ch[maxn][26],siz,val[maxn]; trie(){ siz=1;//一开始的时候只有根节点这一个节点 memset(ch[0],0,sizeof(ch[0])); memset(val,0,sizeof(val)); } inline ll idx(char c){return c-'a';} void insert(char *s,ll v) { ll u=0,len=strlen(s+1); for(ll i=1;i&lt;=len;i++){ ll c=idx(s[i]); if(!ch[u][c]){ memset(ch[siz],0,sizeof ch[siz]); val[siz]=0; ch[u][c]=siz++; } u=ch[u][c]; } val[u]=v; } ll query(char *s) { ll u=0,len=strlen(s+1); for(ll i=1;i&lt;=len;i++){ ll c=idx(s[i]); if(!ch[u][c])return -1; u=ch[u][c]; } return val[u]; } }tr; int main() { return 0; } P2580 于是他错误的点名开始了 （名字好奇怪） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int maxn=10005*50; int n; struct trie { int cnt,ch[maxn][26]; int vis[maxn]; trie() { cnt=1; memset(ch[0],0,sizeof ch[0]); memset(vis,0,sizeof vis); } inline int ex(char c){return c-'a';} inline void insert(char *s) { int u=0,len=strlen(s+1); for(int i=1;i&lt;=len;i++) { int c=ex(s[i]); if(!ch[u][c]){ memset(ch[cnt],0,sizeof ch[cnt]); ch[u][c]=cnt++; } u=ch[u][c]; } } inline int query(char *s) { int u=0,len=strlen(s+1); for(int i=1;i&lt;=len;i++) { int c=ex(s[i]); if(!ch[u][c])return 2; u=ch[u][c]; } if(!vis[u]){ vis[u]++;return 1; } return 3; } }tr; int main() { scanf(\"%d\",&amp;n); char a[100]; for(int i=1;i&lt;=n;i++) { scanf(\"%s\",a+1); tr.insert(a); } int m; scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++) { scanf(\"%s\",a+1); switch(tr.query(a)) { case(1):{ printf(\"OK\\n\"); break; } case(2):{ printf(\"WRONG\\n\"); break; } case(3):{ printf(\"REPEAT\\n\"); break; } } } return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"bzoj2118","slug":"bzoj2118","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.423Z","comments":true,"path":"2022/04/30/bzoj2118/","permalink":"https://starcried.github.io/2022/04/30/bzoj2118/","excerpt":"","text":"2118: 墨墨的等式 Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 259 MBSubmit: 2390&nbsp;&nbsp;Solved: 937[Submit][Status][Discuss] Description 墨墨突然对等式很感兴趣，他正在研究a1x1+a2x2+&hellip;+anxn=B存在非负整数解的条件，他要求你编写一个程序，给定N、{an}、以及B的取值范围，求出有多少B可以使等式存在非负整数解。 Input 输入的第一行包含3个正整数，分别表示N、BMin、BMax分别表示数列的长度、B的下界、B的上界。输入的第二行包含N个整数，即数列{an}的值。 Output 输出一个整数，表示有多少b可以使等式存在非负整数解。 Sample Input 2 5 10 3 5 Sample Output 5 HINT 对于100%的数据，N&le;12，0&le;ai&le;5*10^5，1&le;BMin&le;BMax&le;10^12。 分析 我们发现这已经不是简单的数论题了！（我开始并没有发现）对于这种无限取的背包问题，可以转化为取mod最短路的问题。具体怎么想呢？ 首先我们将a排序（因为这道题n比较小其实可以不用但是这样更优秀）考虑对于a1，对于所有能够取到的数x，都有x+a1*k（k任意）一定会被取到。所以我们就可以把所有能够取到的数%a1，发现结果属于0~a1-1中的一个，那么我们就把每一个0~a1看做一个集合包括所有能够取到的数%a1=该值。 那么最小路怎么解释呢？相当于每次加一个数就走了一条边，我们将所有&lt;r的数%a1的最小值看做最短路，求完后遍历0~a1分别求r和l-1的组合的个数（前缀和）减去即可。 这里我用dijkstra。 &nbsp; 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;ctype.h&gt; 4 #include&lt;algorithm&gt; 5 #include&lt;cstring&gt; 6 #include&lt;queue&gt; 7 #include&lt;utility&gt; 8 #include&lt;vector&gt; 9 #include&lt;functional&gt; 10 using namespace std; 11 const int maxn=5e5+5; 12 typedef long long ll; 13 typedef pair&lt;ll,int&gt; pairr; 14 15 int n,a[15]; 16 ll L, R; 17 18 struct Edge{ 19 int to,nxt,dis; 20 }e[maxn*10]; 21 22 int head[maxn];int ecnt; 23 24 inline void addedge(int from,int to,int dis) 25 { 26 e[++ecnt]=(Edge){to,head[from],dis},head[from]=ecnt; 27 } 28 29 ll dis[maxn]; 30 bool vis[maxn]; 31 void dijkstra() 32 { 33 priority_queue &lt;pairr,vector&lt;pairr &gt;,greater&lt;pairr &gt; &gt;q; 34 for(int i=0;i&lt;a[1];i++)dis[i]=(ll)1e60; 35 dis[0]=0; 36 q.push(make_pair(0,0)); 37 while(!q.empty()) 38 { 39 int v=q.top().second;q.pop(); 40 if(vis[v])continue;vis[v]=1; 41 for(int i=head[v];i!=-1;i=e[i].nxt) 42 { 43 int u=e[i].to; 44 ll w=(ll)e[i].dis; 45 if(dis[u]&gt;dis[v]+w) 46 { 47 dis[u]=dis[v]+w; 48 q.push(make_pair(dis[u],u)); 49 } 50 } 51 } 52 } 53 54 inline ll getans(ll x) 55 { 56 ll ans=0; 57 for(int i=0;i&lt;a[1];i++) 58 if(dis[i]&lt;=R){ 59 ll zp=max(0ll,(x-dis[i])/a[1]); 60 if(zp*a[1]+dis[i]&lt;x)ans++; 61 ans+=zp; 62 } 63 return ans; 64 } 65 66 int main() 67 { 68 scanf(\"%d%lld%lld\",&amp;n,&amp;L,&amp;R); 69 memset(head,-1,sizeof(head)); 70 for(int i=1;i&lt;=n;i++) 71 { 72 scanf(\"%d\",&amp;a[i]); 73 if(a[i]==0)n--,i--; 74 } 75 sort(a+1,a+1+n); 76 for(int i=0;i&lt;a[1];i++) 77 for(int j=2;j&lt;=n;j++) 78 addedge(i,(a[j]+i)%a[1],a[j]); 79 dijkstra(); 80 // printf(\"%lld\\n\",getans(R)-getans(L-1)+1); 81 ll ans=0; 82 for (int i=0;i&lt;a[1];i++) if (dis[i]&lt;=R) { 83 ll l=max(0ll,(L-dis[i])/a[1]); 84 if (l*a[1]+dis[i]&lt;L) l++; 85 ll r=(R-dis[i])/a[1]; 86 if (r*a[1]+dis[i]&gt;R) r--; 87 ans+=r-l+1; 88 } 89 printf(\"%lld\\n\",ans); 90 return 0; 91 } PS调了几天竟然是板子写错了！！！淦","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"[省选联考 2020 A B 卷] 冰火战士","slug":"[省选联考 2020 A B 卷] 冰火战士","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-10T13:31:08.233Z","comments":true,"path":"2022/04/30/[省选联考 2020 A B 卷] 冰火战士/","permalink":"https://starcried.github.io/2022/04/30/[%E7%9C%81%E9%80%89%E8%81%94%E8%80%83%202020%20A%20B%20%E5%8D%B7]%20%E5%86%B0%E7%81%AB%E6%88%98%E5%A3%AB/","excerpt":"","text":"对树状数组的理解加深了！ 转化题意动态维护一个单调不降和一个单调不增序列，每次修改后输出两序列取最小值后的最大值和其最大位置。 思路首先，阅读原题，知道最后答案一定是某个战士的温度，所以我们将温度离散化。 再次阅读，发现冰系是一个（以温度为自变量的）单调不降序列，每次修改一个战士就是修改一段后缀。火系相反，修改前缀。 深度阅读，发现题目其实就是求两个序列的交点。于是转化成上述题意。 考虑二分答案求出两点的交，即温度最大的冰系能量和不大于火系能量和的位置。如果用树状数组动态维护每次查询的话，时间复杂度是 $O(log^2n)$ ，无法通过。 实际上，树状数组也是可以二分的。回忆树状数组的树形结构，一个点 $P+2^i$ 实际上存储了 $P+1$到$P+2^i$ 的所有信息，所以我们在树状数组上二分，实际上就是像倍增一样，从大到小依次枚举这个点加上 $2^i$ 的祖先，能跳则跳。 于是我们就可以通过这题了。注意我这里存储火系前缀和的方式是记录一个全局和再在树状数组上减去。 最后答案乘二。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c)) w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c)) x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=4e6+10; int n,b[maxn],cnt,sumfire; struct BIT&#123; int c[maxn]; inline void update(int x,int k)&#123;for(;x&lt;=cnt;x+=x&amp;-x)c[x]+=k;&#125; &#125;S1,S2; inline int query(int x)&#123; if(x&lt;1 or x&gt;cnt) return 0; int ans1=0,ans2=sumfire; for(;x;x-=x&amp;-x) ans1+=S1.c[x],ans2+=S2.c[x]; return min(ans1,ans2); &#125; struct query&#123; bool type; int t,v,op; &#125;e[maxn]; inline void work()&#123; n=read(); for(int i=1;i&lt;=n;i++) if((e[i].op=read())==1) e[i].type=read(),e[i].t=b[++cnt]=read(),e[i].v=read(); else e[i]=e[read()],e[i].op=2,e[i].v=-e[i].v; sort(b+1,b+1+cnt); cnt=unique(b+1,b+1+cnt)-b-1; for(int i=1;i&lt;=n;i++) e[i].t=lower_bound(b+1,b+1+cnt,e[i].t)-b; for(int i=1;i&lt;=n;i++)&#123; if(e[i].type==0) S1.update(e[i].t,e[i].v); else S2.update(e[i].t+1,-e[i].v),sumfire+=e[i].v; int x1=0,sum=-sumfire; for(int j=21;~j;j--)&#123; int to=x1|(1&lt;&lt;j),zp; if(to&lt;=cnt and (zp=sum+S1.c[to]-S2.c[to])&lt;=0) sum=zp,x1=to; &#125; int ans1=query(x1),x2=x1+1,ans2=query(x2); if(ans1&lt;=0 and ans2&lt;=0)puts(&quot;Peace&quot;); else if(ans1&gt;ans2) printf(&quot;%d %d\\n&quot;,b[x1],ans1&lt;&lt;1); else &#123; int p=0,sum=sumfire; for(int j=21;~j;j--)&#123; int to=p|(1&lt;&lt;j),zp; if(to&lt;=cnt and (zp=sum+S2.c[to])&gt;=ans2) sum=zp,p=to; &#125;//因为现在的情况一定是火系战士能量低所以光用火系的找答案就行了 printf(&quot;%d %d\\n&quot;,b[p],sum&lt;&lt;1); &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 其他 三分是不正确的因为这玩意的峰不知道在哪而且会有平台。 如果用其他方式存火系的信息请务必考虑是否算进了当前点的值。 听说这题数据特水每次暴力移动上次答案的指针都能过 输出太大在洛谷上OLE了，但LOJ上可以提交，希望管理员修复一下（已修复）","categories":[{"name":"题解","slug":"题解","permalink":"https://starcried.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"树状数组","slug":"树状数组","permalink":"https://starcried.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"二分","slug":"二分","permalink":"https://starcried.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"Tips","slug":"Tips","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.464Z","comments":true,"path":"2022/04/30/Tips/","permalink":"https://starcried.github.io/2022/04/30/Tips/","excerpt":"","text":"编译时加入以下命令在运行时出现数组越界和整形溢出警告： -ftrapv -fsanitize=address -fsanitize=undefined","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"bzoj4636-在线线段树[非公开][草稿]","slug":"bzoj4636-在线线段树[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.423Z","comments":true,"path":"2022/04/30/bzoj4636-在线线段树[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/bzoj4636-%E5%9C%A8%E7%BA%BF%E7%BA%BF%E6%AE%B5%E6%A0%91[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"动态线段树 动态线段树和线段树不太一样，主要是因为它是动态的，用于处理一些区间较大的问题。这样的话就不可以用朴素写法的ls和rs了。我们需要一个时间戳记录每个点并在询问时dfs线段树。 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"deque[非公开][草稿]","slug":"deque[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.431Z","comments":true,"path":"2022/04/30/deque[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/deque[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"deque['dek] double-ended-queue，双端队列，引用于&lt;queue&gt;。它的特别之处在于它可以处理前端和后端的元素，似乎更灵活了，但是实际操作却远没有栈和queue有用。 弊端 deque因为其能够处理双端，使得它不能像vector一样有效率。它存储的特殊性（不像vector一样连续使用内存）导致它不是那么有用。但是在一些算法上（如单调队列）也是很容易理解的。 方法 含义 deque 构造一个deque push_back 向最后插入一个元素 push_front 向头部插入一个元素 pop_back 删除最后一个元素 pop_front 删除头部第一个元素 clear 清除deque 单调队列","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"hash表 哈希表","slug":"hash表 哈希表","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.434Z","comments":true,"path":"2022/04/30/hash表 哈希表/","permalink":"https://starcried.github.io/2022/04/30/hash%E8%A1%A8%20%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"","text":"https://blog.csdn.net/duan19920101/article/details/51579136 简单理解就是一个通过映射直接查找的表（散列表），用哈希函数将数据按照其存储特点进行存储。查询效率接近是O(1)的。 存储方式是结合了数组和链表的思想，用链表将存储的数据直接相连，便于查询和修改。 其实就是一个储存优化的方式。 缺点 它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。 构造 根据不同的数据特点有不同的构造方法： https://blog.csdn.net/weixin_38169413/article/details/81612307 基本上就是解决冲突的方法不同。 开放地址法： 对于存储x,把他存到(x+i)%mod里。 i最开始等于零。如果冲突，就i++，重复直到找到空地址。mod大于数据大小并一般为质数。 eg：存名字和成绩按名字查询 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; struct stu{ string to; int nxt,da; }e[100]; int head[100000],cnt; inline int hsh(string s) { int ln,hash=0,seed=31,t;//seed is a prime int len=s.length(); for(int i=0;i&lt;=len;i++) { hash=hash*seed+s[i]; hash%=99999; } t=head[hash]; while(t!=-1) { if(e[t].to==s)return t; t==e[t].nxt; } if(t==-1) { e[++cnt]=(stu){s,head[hash],0};head[hash]=cnt; t=cnt; } return t; } inline int findhsh(string s) { int ln,hash=0,seed=31,t;//seed is a prime int len=s.length(); for(int i=0;i&lt;=len;i++) { hash=hash*seed+s[i]; hash%=99999; } t=head[hash]; while(t!=-1) { if(e[t].to==s)return e[t].da; t=e[t].nxt; } return t; } int main() { std::ios::sync_with_stdio(false); memset(head,-1,sizeof head); int n; cin&gt;&gt;n; string x; int y,m,nn; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;x&gt;&gt;y; m=hsh(x);//地址 e[m].da=y; } cin&gt;&gt;nn; for(int i=1;i&lt;=nn;i++) { cin&gt;&gt;x; cout&lt;&lt;findhsh(x)&lt;&lt;endl; } return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"P7324 [WC2021] 表达式求值","slug":"P7324 [WC2021] 表达式求值","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.456Z","comments":true,"path":"2022/04/30/P7324 [WC2021] 表达式求值/","permalink":"https://starcried.github.io/2022/04/30/P7324%20[WC2021]%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/","excerpt":"","text":"P7324 [WC2021] 表达式求值闲话WC2021 我只得了 20 分，三道题总共 20 分。我是下场了突然后知后觉这件事的，主要原因是我开了 C++11，然后 T1 T2 都没分了。在洛谷上测本来能拿银牌的。T1 的乱搞能拿 48，还挺高的。 幸亏咱们陕西省选不看冬令营成绩。幸亏是在省选前犯的这个错误。告诫后人和自己，写题前一定要看编译选项，否则只能后悔莫及。 T2 场上写的是不带问号的 $O(n|E|)$ 和带问号 $O(n|E|m^2)$ 的 70 分暴力。后者可以用 minmax 卷积优化掉一个 $m$ 获得 85 分的好成绩。 思路首先要会上面提到的带问号的暴力，不需要优化。 我在场上写的是这样子的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344int a[maxn][10],but[maxn][10],tmp[10];int* solve(int l,const int &amp;r,const int *a)&#123; l++; int *ans=s[l]==&#x27;(&#x27;?solve(l,to[l],a):but[l];//这里的 to 是预处理的括号匹配位置，完全可以用把 l 设成全局变量的方法解决 l=s[l]==&#x27;(&#x27;?to[l]+1:l+1; while(l+1&lt;r)&#123; char op=s[l++]; int *res=s[l]==&#x27;(&#x27;?solve(l,to[l],a):but[l]; l=s[l]==&#x27;(&#x27;?to[l]+1:l+1; switch(op)&#123; case &#x27;&lt;&#x27;:&#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) if(a[i]&lt;a[j]) tmp[i]=(tmp[i]+1ll*ans[i]*res[j])%mod; else tmp[j]=(tmp[j]+1ll*ans[i]*res[j])%mod; for(int i=0;i&lt;m;i++) ans[i]=tmp[i]; break; &#125; case &#x27;&gt;&#x27;:&#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) if(a[i]&gt;a[j]) tmp[i]=(tmp[i]+1ll*ans[i]*res[j])%mod; else tmp[j]=(tmp[j]+1ll*ans[i]*res[j])%mod; for(int i=0;i&lt;m;i++) ans[i]=tmp[i]; break; &#125; case &#x27;?&#x27;:&#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) tmp[i]=(tmp[i]+1ll*ans[i]*res[j])%mod,tmp[j]=(tmp[j]+1ll*ans[i]*res[j])%mod; for(int i=0;i&lt;m;i++) ans[i]=tmp[i]; break; &#125; &#125; &#125; return ans;&#125;inline void work()&#123; for(int i=0;i&lt;m;i++) for(int j=1;j&lt;=n;j++) a[j][i]=star::a[i][j-1]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=len;j++) for(int k=0;k&lt;m;k++) but[j][k]=(isdigit(s[j]) and s[j]-&#x27;0&#x27;==k); int* res=solve(1,len,a[i]); for(int j=0;j&lt;m;j++) ans=(ans+1ll*res[j]*a[i][j])%mod; &#125; printf(&quot;%d\\n&quot;,ans);&#125; 即把 $n$ 组数分开来讨论，求每种数贡献的方案数，最后乘上值加起来。 那么问题就在于求每种数的方案数，这样的工作我们需要做 $n$ 遍，非常不划算。 然后发现，对于大小关系相同的每组数，每种数贡献的方案数是相同的，改变的只是它们的值，我们没有必要每次都算一遍方案数。 发现，一个数在一组数中的相对大小关系的情况总数只有 $2^m$ 种，即是否比该数大。 那么我们预处理出一个数的所有相对大小关系总数（这个部分是 $O(2^m|E|)$ 的），然后对于 $n$ 组数每个枚举 $m$ 个数差分统计答案即可（差分得到该数的方案数。此部分是 $O(nmlogm)$ 的）。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;utility&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=5e4+10,maxm=12,S=1050,mod=1e9+7; int n,m,a[maxn][maxm],D,f[S],pos,b[maxm],ans; char s[maxn]; pair&lt;int,int&gt; solve()&#123; int num=0;bool ok=true;char lst=&#x27;&gt;&#x27;; pair&lt;int,int&gt; ans(1,0),now,tmp; while(lst!=&#x27;)&#x27; and ++pos) if(isdigit(s[pos])) num=s[pos]^48; else if(s[pos]==&#x27;(&#x27;) now=solve(),ok=false; else ok and (now=make_pair((D&gt;&gt;num)&amp;1,(D&gt;&gt;num)&amp;1^1),0), ok=true,tmp=make_pair(0,0), lst!=&#x27;&gt;&#x27; and (tmp.second=(tmp.second+1ll*ans.second*now.second)%mod,tmp.first=(tmp.first+1ll*(ans.first+ans.second)*(now.first+now.second)-1ll*ans.second*now.second%mod+mod)%mod), lst!=&#x27;&lt;&#x27; and (tmp.first=(tmp.first+1ll*ans.first*now.first)%mod, tmp.second=(tmp.second+1ll*(ans.first+ans.second)*(now.first+now.second)-1ll*ans.first*now.first%mod+mod)%mod), ans=tmp,lst=s[pos],num=0; return ans; &#125; inline bool cmp(const int &amp;x,const int &amp;y)&#123;return a[pos][x]&lt;a[pos][y];&#125; inline void work()&#123; n=read(),m=read(); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) a[j][i]=read(); scanf(&quot;%s&quot;,s+1);s[strlen(s+1)+1]=&#x27;)&#x27;; for(D=0;D&lt;(1&lt;&lt;m);D++) pos=0,f[D]=solve().second; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++) b[j]=j; pos=i;sort(b,b+m,cmp); for(int j=0,d=0;j&lt;m;d|=(1&lt;&lt;b[j++])) ans=(ans+1ll*(a[i][b[j]]-(j?a[i][b[j-1]]:0))*f[d])%mod; &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"lower_bound和upper_bound","slug":"lower_bound和upper_bound","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.437Z","comments":true,"path":"2022/04/30/lower_bound和upper_bound/","permalink":"https://starcried.github.io/2022/04/30/lower_bound%E5%92%8Cupper_bound/","excerpt":"","text":"原理 运用二分的方法进行查找，可以用于逆序对等题目。template出门右转百度。 用法 lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个&nbsp; &nbsp; &nbsp; &nbsp;大于&nbsp; &nbsp;num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 我们可以使用&lt;functional&gt;里的greater改变lower_bound和upper_bound的排序办法来查找。 lower_bound( begin,end,num,greater(type))：从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 upper_bound( begin,end,num,greater(type))：从数组的begin位置到end-1位置二分查找第一个&nbsp; &nbsp; &nbsp; &nbsp;小于&nbsp; &nbsp;num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 总之lower_bound会带上这个数字本身啦~","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"erase","slug":"erase","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.433Z","comments":true,"path":"2022/04/30/erase/","permalink":"https://starcried.github.io/2022/04/30/erase/","excerpt":"","text":"erase详细解释及原理 我们先定义一个字符串string string.erase(iterator) iterator表示要删除元素的迭代器。 string.erase(it_begin,it_end) 两个元素，表示删除从begin到end-1的所有元素。 string.erase(0,1) string独有，删除第0到1-0的字符。 erase的返回值是end的迭代器。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"kruskal重构树-NOI2018归程[非公开][草稿]","slug":"kruskal重构树-NOI2018归程[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.435Z","comments":true,"path":"2022/04/30/kruskal重构树-NOI2018归程[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/kruskal%E9%87%8D%E6%9E%84%E6%A0%91-NOI2018%E5%BD%92%E7%A8%8B[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"这是NOI2018第一题，在洛谷上评分已经被降到了紫题。 kruskal重构树： kruskal重构树是什么呢？大家一定都知道kruskal吧，那么kruskal重构树是什么呢？大家一起跟小编来看看吧~ kruskal重构树其实就是在kruskal排序边后将加入的边的点插入一个重构树并在查询时在树上dfs和查询的树型结构。虽然很难以置信，但真相就是这样。大家有没有学到呢？ 我错了我不营销耗了 其实kruskal重构树一般是按照边权进行排序的。但是这个题不一样。这个题是按照海拔高度进行排序的。所谓重构树的树形结构就是用来存储海拔的。 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"set 和 multiset[非公开][草稿]","slug":"set 和 multiset[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.462Z","comments":true,"path":"2022/04/30/set 和 multiset[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/set%20%E5%92%8C%20multiset[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"set和multiset都是stl中的容器，可以按照特定的顺序将元素存储。 区别 set不允许元素重复，而multiset可以。 详细用法 c.insert()为插入元素","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"Matrix-tree定理","slug":"matrix-tree定理","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T06:40:26.158Z","comments":true,"path":"2022/04/30/matrix-tree定理/","permalink":"https://starcried.github.io/2022/04/30/matrix-tree%E5%AE%9A%E7%90%86/","excerpt":"","text":"矩阵树定理定义 邻接矩阵：$A&#x3D;(a_{ij})$，其中 $a_{ij}$ 表示 $i$ 到 $j$ 有几条边相连。 度数矩阵：$C&#x3D;(c_{ij})$，为对角矩阵，其中 $c_{ii}$ 表示 $i$ 的度数。 基尔霍夫矩阵：$D&#x3D;C-A$。 余子式：$M_{ij}$ 表示去掉第 $i$ 行第 $j$ 列后得到矩阵的行列式。 定理无向图的生成树个数等于其基尔霍夫矩阵 $D$ 的任意余子式的行列式。 如果图不连通，那么任意余子式为0。 例题P4208 [JSOI2008] 最小生成树计数 根据定理，我们只需要求出联通的边权相同的点集，在该集合中根据矩阵树定理求出生成树的多少，然后把所有集合的结果相乘就好辣！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=105,maxm=1005,mod=31011; int n,m,N; int a[maxn][maxn],fa[maxn],but[maxn],bel[maxn]; struct Edge&#123; int u,v,w; bool operator &lt; (const Edge&amp; rhs) const&#123; return w&lt;rhs.w; &#125; &#125;e[maxm],em[maxm]; int find(int x)&#123;return x==fa[x]?x:fa[x]=find(fa[x]);&#125; long long Gauss(int n)&#123; long long ans=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; while(a[j][i])&#123; long long t=a[i][i]/a[j][i]; for(int k=i;k&lt;=n;k++) a[i][k]=(a[i][k]-t*a[j][k]%mod+mod)%mod; swap(a[i],a[j]); ans=-ans; &#125; &#125; ans=(ans*a[i][i]%mod+mod)%mod; &#125; return ans; &#125; inline void work()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) e[i].u=read(),e[i].v=read(),e[i].w=read(); sort(e+1,e+m+1); int cnt=0,cnte=0; for(int i=1;i&lt;=m;i++)&#123; int x=find(e[i].u),y=find(e[i].v),z=e[i].w; if(x!=y)&#123; fa[x]=y; em[++cnte]=e[i]; if(z!=but[cnt]) but[++cnt]=z; &#125; &#125; if(cnte!=n-1) return (void)puts(&quot;0&quot;); long long ans=1; for(int i=1;i&lt;=cnt;i++)&#123; for(int j=1;j&lt;=n;j++) fa[j]=j; for(int j=1;j&lt;=cnte;j++) if(em[j].w!=but[i]) fa[find(em[j].u)]=find(em[j].v); N=0; for(int j=1;j&lt;=n;j++) if(find(j)==j) bel[j]=++N; for(int j=1;j&lt;=n;j++) bel[j]=bel[find(j)]; memset(a,0,sizeof(a)); for(int j=1;j&lt;=m;j++) if(e[j].w==but[i])&#123; int x=bel[e[j].u],y=bel[e[j].v]; a[x][y]--,a[y][x]--; a[x][x]++;a[y][y]++; &#125; ans=ans*Gauss(N-1)%mod; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"矩阵","slug":"矩阵","permalink":"https://starcried.github.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://starcried.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]},{"title":"static","slug":"static","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.463Z","comments":true,"path":"2022/04/30/static/","permalink":"https://starcried.github.io/2022/04/30/static/","excerpt":"","text":"工程代码员请看详解 static adj.静止的;固定的;无活力的;静电的;静电干扰的 就是静态的意思啦~ 当我们在一个函数内部普通地定义一个变量时，相当于在程序中进栈，出函数就会被清除，程序也不会对其初始化，所以可以在不同函数内使用。 但是在前面加上static前缀就不一样了： 变量在全局数据区分配内存空间；编译器自动对其初始化 其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束 程序会将数据成员初始化为0。但是作用于为函数内。不同的文件可以用同名变量。 所以对于我们有什么用呢？ 在写结构体的时候会增强模块化特性，有利于封装和维护。 在函数内部定义数组和其他类型时，因为C++局部变量的特性，无法返回指针。但是可以在定义时加static就可以返回了（因为是在全局范围内定义的）。 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"tarjan算法 强连通 边双联通 点双联通[非公开][草稿]","slug":"tarjan算法 强连通 边双联通 点双联通[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.463Z","comments":true,"path":"2022/04/30/tarjan算法 强连通 边双联通 点双联通[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/tarjan%E7%AE%97%E6%B3%95%20%E5%BC%BA%E8%BF%9E%E9%80%9A%20%E8%BE%B9%E5%8F%8C%E8%81%94%E9%80%9A%20%E7%82%B9%E5%8F%8C%E8%81%94%E9%80%9A[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"概念在无向图中： 边双联通：删去图中任何一条边图仍联通 点双联通：删去图中任何一个点图仍联通（不具有传递性） 此图为边双连通图但非点双联通图。 割点：如果删去一个点将会把图分成两个或两个以上的图，那么这个点就是割点。如上图 B 点。 桥：如果删去一个边将会把图分成两个图，那么这个边就是桥。 点双连通分量：不存在割点的极大连通分量。 边双连通分量：不存在桥的极大连通分量。 Tarjan tarjan是基于DFS的一种算法，可以求解有向图&#x2F;无向图的割点和桥，能够对图进行缩点、寻找必经点、割点、桥、最小公共祖先等问题。 （大概是这样） 割点 桥 原理 时间戳 dfn就是搜索到这个点的次序，可以理解为编号，可以用来判定祖先和是否被访问。搜索树 就是路径啦~追溯值 low用于记录从当前节点 x 作为搜索树的根节点出发，能够访问到的所有节点中，时间戳最小的值。归属 belong，就是tarjan访问完形成强联通分量之后把每个属于该强联通分量的点标记属于该强联通分量。每多一个强联通分量_n++,belong[i]&#x3D;_n。大小 siz 就是该强联通分量的大小。等等，按需任取求割点 我们寻思，如果一个点是割点，它有什么性质？对了，我们很容易就想到它的low肯定是大于等于dfn的。为什么呢？如果这个点x用tarjanDFS到了一个点是他的祖先，即使把这个点删掉也不会影响路重新回到它本身，说明它不符合割点的定义。 于是我们可以得到程序（讲解在程序中） 这里以洛谷P3388模板为例 求桥","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"transform和tolower","slug":"transform和tolower","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.464Z","comments":true,"path":"2022/04/30/transform和tolower/","permalink":"https://starcried.github.io/2022/04/30/transform%E5%92%8Ctolower/","excerpt":"","text":"transform:&lt;algorithm&gt; tolower:&lt;ctype.h&gt; transform有两种使用方法 第一种（参数）： 源目标起始迭代器地址 源目标结束迭代器地址 输出迭代器地址 自定义函数符（一元函数） 例如某一个题：(也就是我这里将两个函数相提并论的原因） 将字符串不分辨大小写进行比较： string S,T; int main() { while(cin&gt;&gt;S&gt;&gt;T){ transform(S.begin(),S.end(),S.begin(),::tolower); transform(T.begin(),T.end(),T.begin(),::tolower); if(S==T)printf(\"Same.\\n\"); else printf(\"Different.\\n\"); } return 0; } tolower函数是将大写字符转化成小写字符。。。 tolower基本用法是tolower(char),只能一次转化一个字符而非字符串，但是和transform连用就可以（毕竟transform就是一个一个转换的）。::tolower表示引用tolower的比较方法。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"unique","slug":"unique","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.465Z","comments":true,"path":"2022/04/30/unique/","permalink":"https://starcried.github.io/2022/04/30/unique/","excerpt":"","text":"unique unique一般先用sort将要处理的序列排序，因为unique只会&ldquo;删除&rdquo;相邻的重复元素。 我们定义一个数列a[]={1,3,3,4,5,6,6,7}(a.begin为a首元素的迭代器，a.end同理） unique(a.begin(),a.end())或者unique(a,a+a.size())，数组变为{1,3,4,5,6,7,6,7}. unique(a.begin(),a.end(),cmp) ，这里的cmp是自定义bool函数，假如他return b==a+1,即下一个元素比该元素大1时才&lsquo;相等&rsquo;，数组变为{1,3,3,5,7,6,6,7}. 这个和sort的格式类似。相信我们都发现了：unique函数会将重复元素用下一位元素&lsquo;顶替&rsquo;，而未处理的元素值并不会改变。 unique函数的返回值是更新完的序列的end（迭代器）。 实践是检验真理的唯一标准 //测试unique函数 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int a[]={1,3,3,4,6,6,7}; int ans=unique(a,a+7)-a; cout&lt;&lt;ans&lt;&lt;endl; for(int i=0;i&lt;7;i++) { cout&lt;&lt;a[i]&lt;&lt;' '; } return 0; } 输出为 5 1 3 4 6 7 6 7&nbsp; 我们一般用它的时候若要返回更新完的a序列的长度，一般写成int len=unique(a,a+n)-a。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"主定理","slug":"主定理","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.468Z","comments":true,"path":"2022/04/30/主定理/","permalink":"https://starcried.github.io/2022/04/30/%E4%B8%BB%E5%AE%9A%E7%90%86/","excerpt":"","text":"定义主定理（Master Theorem）通常是指在算法分析领域中的一个定理，特别是用于分析递归算法的时间复杂度。 时间复杂度相关定义在计算机科学中，算法的时间复杂度（time complexity）是一个函数，它定性描述该算法的运行时间。其原理在于，将计算机的每种基本运算（如加减乘除）所需的时间视为常数，然后考察一个算法调用了多大量级的基本运算。时间复杂度常用大 $O$ 符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 $n$ 的输入，它至多需要 $5n^3 + 3n$ 的时间运行完毕，那么它的渐近时间复杂度是 $O(n^3)$。 为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元执行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。 相同大小的不同输入值仍可能造成算法的执行时间不同，因此我们通常使用算法的最坏情况复杂度（时间复杂度上界），记为 $T(n)$ ，定义为任何大小的输入 $n$ 所需的最大执行时间。另一种较少使用的方法是平均情况复杂度，通常有特别指定才会使用（如用于随机算法）。 对 Bachmann–Landau 符号描述如下： $f(n)&#x3D;O(g(n))$ 表示 $g$ 是 $f$ 的上界； $f(n)&#x3D;\\Omega(g(n))$ 表示 $g$ 是 $f$ 的下界； $f(n)&#x3D;\\Theta(g(n))$ 表示 $g$ 是 $f$ 的上界和下界。 内容在算法中，假设有递归关系式： $$ T(n)&#x3D;aT\\left(\\frac nb\\right)+f(n),\\ a\\geq 1,b&gt;1$$ 其中，$n$ 为问题规模，$a$ 为子问题数量，$\\frac nb$ 为每个子问题的规模（假设每个子问题规模基本一致），$f(n)$ 为递归以外的计算。 情况1： 若 $\\exists \\epsilon &gt;0$ ，有 $f(n)&#x3D;O(n^{\\log_ba-\\epsilon})$ ，则 $T(n)&#x3D;\\Theta(n^{\\log_ba})$ 情况2： 若 $\\exists \\epsilon \\geq0 $，有 $f(n)&#x3D;\\Theta(n^{\\log_ba}\\log^\\epsilon n)$ ，则 $T(n)&#x3D;\\Theta(n^{\\log_ba}\\log^{\\epsilon+1}n)$ 情况3： 若 $\\exists \\epsilon &gt;0,c&lt;1$ ，有 $f(n)&#x3D;\\Omega(n^{\\log_ba+\\epsilon}),af\\left(\\frac nb\\right)\\leq cf(n)$ ，则 $T(n)&#x3D;\\Theta(f(n))$ 证明设总复杂度为 $T(n)$，有 $$ T(n)&#x3D;\\sum_{i&#x3D;0}^{\\log_bn}a^i f\\left(\\frac n{b^i}\\right) $$ 将上述三种情况分别代入得 $T(n)$ 得 情况1： $$ \\begin{aligned} T(n)&amp;&#x3D;O(\\sum_{i&#x3D;0}^{\\log_bn}a^i\\left(\\frac n{b^i}\\right)^{\\log_ba-\\epsilon})\\ &amp;&#x3D;O(n^{\\log_ba-\\epsilon}\\sum_{i&#x3D;0}^{\\log_bn}\\left(\\frac a{b^{\\log_ba&#x3D;\\epsilon}}\\right)^i)\\ &amp;&#x3D;O(n^{\\log_ba-\\epsilon}\\sum_{i&#x3D;0}^{\\log_bn}b^{\\epsilon j})\\ &amp;&#x3D;O(n^{\\log_ba-\\epsilon}\\left(\\frac{n^\\epsilon-1}{b^\\epsilon-1}\\right))\\ &amp;&#x3D;O(n^{\\log_ba}) \\end{aligned}$$ 情况2： $$\\begin{aligned}T(n) &amp; &#x3D;\\Theta\\left(\\sum_{i&#x3D;0}^{\\log_b n} a^i\\left(\\frac{n}{b^i}\\right)^{\\log b a} \\log ^k\\left(\\frac{n}{b^i}\\right)\\right) \\&amp; &#x3D;\\Theta\\left(\\sum{i&#x3D;0}^{\\log_b n} a^i\\left(\\frac{n^{\\log _b a}}{b^{i^{\\log _b a}}}\\right)\\left(\\log n-\\log b^i\\right)^k\\right) \\&amp; &#x3D;\\Theta\\left(n^{\\log b a} \\sum{i&#x3D;0}^{\\log_b n}\\left(\\frac{a}{b^{\\log _b a}}\\right)^i\\left(\\log ^k n-\\log ^k b^i\\right)\\right) \\&amp; &#x3D;\\Theta\\left(n^{\\log b a} \\sum{i&#x3D;0}^{\\log_b n} \\log ^k n-\\log ^k b^i\\right) \\&amp; &#x3D;\\Theta\\left(n^{\\log _b a}\\left(\\log b n \\cdot \\log ^k n-\\sum{i&#x3D;0}^{\\log_b n} \\log ^k b^i\\right)\\right) \\&amp; &#x3D;\\Theta\\left(\\log _b n \\cdot \\log ^k n \\cdot n^{\\log _b a}-n^{\\log b a} \\sum{i&#x3D;0}^{\\log_b n} \\log ^k b^i\\right)\\&amp; &#x3D;\\Theta\\left(n^{\\log _b a}\\log ^{k+1} n\\right)\\end{aligned}\\$$ 情况3： $$\\begin{aligned} &amp;af(\\frac nb)\\leq cf(n)\\ &amp;\\Rightarrow a^if(\\frac nb)\\leq c^if(n)\\ &amp;\\Rightarrow T(n)\\leq \\sum_{i&#x3D;0}^{\\log_b n}c^if(n)\\ &amp;\\Rightarrow T(n)\\leq f(n)\\sum_{i&#x3D;0}^\\infty c^i\\ &amp;\\Rightarrow T(n)\\leq \\left(\\frac 1{1-c}\\right)f(n)\\ &amp;\\Rightarrow T(n)&#x3D;O(f(n))\\end{aligned}$$ 又由于 $f(n)&#x3D;\\Omega(n^{\\log_ba+\\epsilon})$，$T(n)&#x3D;\\Omega(f(n))$，因此 $$T(n)&#x3D;\\Theta(f(n))$$ 综上，定理得证。 应用一般的递归算法都可以用主定理分析时间复杂度。如大多数分治算法等。下面给出一个具体的问题作为实例。 最小圆覆盖问题 ：给定平面上的 $n$ 个点，求出一个最小的一圆包围所有的点。 对于一个答案，一定有至少两个点在圆上。若不然，则圆可以继续缩小。因此我们只需要找到两个点（作为直径）或三个点即可确定一个最小圆覆盖。 我们用到随机增量法，即将给出的点以随机的顺序进行遍历。${p_i}$ 为加入的点集。设前 $i-1$ 个点确定的最小覆盖圆为 $C$，此时加入 $p_i$： 若 $p_i$ 在 $C$ 内，则最小覆盖圆不变。 若 $p_i$ 在 $C$ 外，则其一定在新确定的最小覆盖圆上。此时遍历前 $i-1$ 个点。设当前遍历到 $p_j$，则将 $p_i,p_j$ 确定的圆设为当前最小覆盖圆，并遍历前 $j-1$ 个点，若有点 $p_k$ 在圆外，则将 $p_i,p_j,p_k$ 确定的圆设为当前最小覆盖圆。 可以证明，这样一定能获得一个最小圆覆盖。 设三个循环的复杂度分别为 $T_1(n),T_2(n),T_3(n)$。现在考虑第一层循环，即加入一个点的循环。由于最多只有三个点在最小覆盖圆上，且我们的点是随机加入的，理论上每个点其之前点确定的最小覆盖圆上的概率是相同的，因此点 $p_i$ 在加入时在当前圆外并调用下层循环的概率是 $\\frac 3i$。第二层调用类似。因此计算时间复杂度为 $$ \\begin{aligned} &amp;T_1(n)&#x3D;\\sum_{i&#x3D;1}^n\\frac 3iT_2(i)+O(n)\\ &amp;T_2(n)&#x3D;\\sum_{i&#x3D;1}^n\\frac 3iT_3(i)+O(n)\\ &amp;T_3(n)&#x3D;O(n) \\end{aligned}$$ 其中两点及三点确定一个圆可由公式推出，计算量固定可视为常数。 这里每一层对上一层实际上是有 $n$ 个规模为 $1$ 的子问题。由主定理得，最终算法的时间复杂度为 $T_1(n)&#x3D;O(n)$。 PS:tex 写多了感觉不会写 markdown 了……","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"二项式反演","slug":"二项式反演","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T06:33:19.747Z","comments":true,"path":"2022/04/30/二项式反演/","permalink":"https://starcried.github.io/2022/04/30/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/","excerpt":"","text":"二项式反演$$g_n&#x3D;\\sum_{i&#x3D;0}^n(-1)^i\\binom ni f_i\\Leftrightarrow f_n&#x3D;\\sum_{i&#x3D;0}^n(-1)^i\\binom ni g_i\\g_n&#x3D;\\sum_{i&#x3D;0}^n\\binom ni f_i\\Leftrightarrow g_n&#x3D;\\sum_{i&#x3D;0}^n(-1)^{n-i}\\binom ni f_i$$ 反演对于一个数列 $f$，若有另一个数列 $g$ 满足$$g_n&#x3D;\\sum_{i&#x3D;0}^{n}a_if_i$$反演即是求出$$f_n&#x3D;\\sum_{i&#x3D;0}^nb_ig_i$$ 证明反演魔术：反演原理及二项式反演","categories":[{"name":"数学","slug":"数学","permalink":"https://starcried.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"https://starcried.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"中国剩余定理","slug":"中国剩余定理","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.467Z","comments":true,"path":"2022/04/30/中国剩余定理/","permalink":"https://starcried.github.io/2022/04/30/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","excerpt":"","text":"“有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？”——《孙子算经》 #中国剩余定理即求多个同余方程的解。 举个栗子。求一个数x，使得：$$\\begin{cases}x≡2(mod 3)\\x≡3(mod 5)\\x≡2(mod 11)\\end{cases}$$ 设M&#x3D;3511&#x3D;165, a1&#x3D;3,a2&#x3D;5,a3&#x3D;11, M1&#x3D;M&#x2F;a1&#x3D;55 M2&#x3D;M&#x2F;a2&#x3D;33 M3&#x3D;M&#x2F;a3&#x3D;15 然后我们再求a的逆元c。（扩展欧几里得） 然后结果就是(a1M1c1 + a2M2c2 + a3M3c3)%M 当然，我们要求的不仅仅是符合3个数的要求。于是我们就可以得到代码： （变量名和以上有出入） 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;void exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(!b)d=a,x=1,y=0; else&#123; exgcd(b,a%b,d,y,x); y-=(a/b)*x; &#125;&#125;ll China(int n,ll *m,ll*a)&#123; ll M=1,d,y,x=0; for(int i=0;i&lt;n;i++)M*=m[i]; for(int i=0;i&lt;n;i++)&#123; ll w=M/m[i]; exgcd(m[i],w,d,d,y); x=(x+y*w*a[i])%M; &#125; return (x+M)%M;&#125;ll m[15],a[15];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%lld%lld&quot;,&amp;m[i],&amp;a[i]); printf(&quot;%lld&quot;,China(n,m,a)); return 0;&#125; 以上是中国剩余定理的内容（CRT） #扩展中国剩余定理（exCRT)简单来说就是对于每两个同余方程，我们可以把它们合并成一个同余方程，并在每次计入一个新的同余方程的时候得到新的解。我们理性地思考一下，如：$$\\begin{cases}x≡y_1(mod m_1)\\x≡y_2(mod m_2)\\…\\x≡y_n(mod m_n)\\end{cases}$$$$M&#x3D;LCM_{i−1}^{k−1}mi$$其中$m_1,m_2,m_3…m_n$为不一定两两互质的整数,求x的最小非负整数解.假设前n-1项已经求出解为x，那么对于第n个式子：$$x+tM≡y_n(mod m_n)$$M和yn、mn是已知的，我们只需exgcd求出x和t就行了。 或者我们把合并感性理解一下，假设原来只有一个同余方程$$x≡y_1(mod m_1)\\Rightarrow x+k_1m_1&#x3D;y_1$$我们再加入一个方程$$x≡y_2(mod m_2)\\Rightarrow x+k_2m_2&#x3D;y_2$$两者相减，得到$$k_1m_1-k_2m_2&#x3D;y_1-y_2$$再用exgcd解得$k_1$和$k_2$即可。那么要求x的值回代即可。 那么对于一个新加入的式子就有：$$-k_1m_1+y_1+tm_3&#x3D;k_3m_3+y_3$$（k1、m1和y1表示上次的x，用②式表示也可以）发现新的未知数是t和k3，重新用exgcd求解即可。 当然这里只写了三个式子。想要更多同余方程组的解？请多次exgcd。这个思维和上面的思维是等价的。洛谷P4777 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;using namespace std;typedef long long ll;inline ll read()&#123; bool w=0;ll x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const ll maxn=1e5+100; ll y[maxn],m[maxn],n; inline void exgcd(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;d)&#123; if(!b)d=a,x=1,y=0; else exgcd(b,a%b,y,x,d),y-=x*(a/b); &#125; ll mul(ll a,ll b,ll mod)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%mod; a=(a+a)%mod; b&gt;&gt;=1; &#125; return res; &#125; inline ll excrt() &#123; ll xx,yy,k; ll M=m[1],ans=y[1]; for(int i=2;i&lt;=n;i++) &#123; ll a=M,b=m[i],c=(y[i]-ans%b+b)%b;//x≡y(mod m)，ans为上一次的解。 ll gcd; exgcd(a,b,xx,yy,gcd);//tM+km=y-x,c是常数项，xx和yy分别表示t和k ll bg=b/gcd;//这个是为了exgcd的最后一个步骤，求解出最小非负整数解 if(c%gcd!=0) return -1; xx=mul(xx,c/gcd,bg); ans+=xx*M; M*=bg;//M为前k个m的lcm ans=(ans%M+M)%M; &#125; return (ans%M+M)%M; &#125; inline void cried() &#123; n=read(); for(int i=1;i&lt;=n;i++)m[i]=read(),y[i]=read(); printf(&quot;%lld\\n&quot;,excrt()); &#125;&#125;int main()&#123; star::cried(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"动态逆序对专练","slug":"动态逆序对专练","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-10T15:03:34.788Z","comments":true,"path":"2022/04/30/动态逆序对专练/","permalink":"https://starcried.github.io/2022/04/30/%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9%E4%B8%93%E7%BB%83/","excerpt":"","text":"就是三倍经验 题意维护一个序列，每次修改后求出当前序列逆序对个数。 思路题目让我们求出$$\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;i+1}^n[a_i&gt;a_j]$$也就是让我们求出满足$$pos_i&lt;pos_j&amp;&amp;a_i&gt;a_j$$的点对数量。 对于不修改的情况，这显然是一个三维偏序问题，用树状数组或归并处理都可以。 对于修改的情况，我们可以用CDQ分治离线解决，或者使用树套树在线处理。 我这么懒当然是用树套树啦~ 树状数组套值域线段树思想树状数组维护序列，值域线段树维护值域。 优点是可以写成非递归式查询，常数相对较小。 缺点是即使是动态开点空间消耗仍然很大。 实现具体实现是每个树状数组节点开一棵线段树。修改时修改所有树状数组上包括的线段树，查询时类似。 12345678void update(int &amp;ro,int l,int r,int x,int k)&#123;//l和r是当前值域区间，x为位置 if(!ro) ro=++tot; val[ro]+=k; if(l==r)return; int mid=l+r&gt;&gt;1; if(x&lt;=mid)update(ls[ro],l,mid,x,k); else update(rs[ro],mid+1,r,x,k);&#125; 墙裂安利非递归式线段树查询 12345678910111213141516171819202122232425262728inline long long query(int l,int r,int x,int type)&#123; int cnta=0,cntb=0; long long ans=0; for(int i=l-1;i;i-=i&amp;-i) qa[++cnta]=rt[i];//树状数组查询方法：差分 for(int i=r;i;i-=i&amp;-i) qb[++cntb]=rt[i];//先将所有要处理的树状数组上的线段树全部记录，然后一起查询 l=1,r=n; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(x&gt;mid)&#123; if(type)&#123;//type表示查询的类型，按照正常线段树查询的思路处理即可。这里type=1表示查左边 for(int i=1;i&lt;=cnta;i++) ans-=val[ls[qa[i]]]; for(int i=1;i&lt;=cntb;i++) ans+=val[ls[qb[i]]]; &#125; for(int i=1;i&lt;=cnta;i++) qa[i]=rs[qa[i]]; for(int i=1;i&lt;=cntb;i++) qb[i]=rs[qb[i]]; l=mid+1; &#125;else&#123; if(!type)&#123; for(int i=1;i&lt;=cnta;i++) ans-=val[rs[qa[i]]]; for(int i=1;i&lt;=cntb;i++) ans+=val[rs[qb[i]]]; &#125; for(int i=1;i&lt;=cnta;i++) qa[i]=ls[qa[i]]; for(int i=1;i&lt;=cntb;i++) qb[i]=ls[qb[i]]; r=mid; &#125; &#125; return ans;&#125; 例题P3157 [CQOI2011]动态逆序对 给你一个排列，每次删除一个位置上的数，求每次操作后的逆序对数。 思路插入原序列之后得到原序列答案，每次删除一个数 $x$ 查询 $pos_i&lt;x$ 、$a_i&gt;a_x$ 和 $pos_i&gt;x$ 、$a_i&lt;a_x$ 的答案并用之前的答案减去，然后删除它的影响。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10,maxm=3e7+10; int n,m,a[maxn],ls[maxm],rs[maxm],tot,rt[maxn],val[maxm]; void update(int &amp;ro,int l,int r,int x,int k)&#123; if(!ro) ro=++tot; val[ro]+=k; if(l==r)return; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(ls[ro],l,mid,x,k); else update(rs[ro],mid+1,r,x,k); &#125; int qa[maxn],qb[maxn]; long long ans; inline long long query(int l,int r,int x,int type)&#123; int cnta=0,cntb=0; long long ans=0; for(int i=l-1;i;i-=i&amp;-i) qa[++cnta]=rt[i]; for(int i=r;i;i-=i&amp;-i) qb[++cntb]=rt[i]; l=1,r=n; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(x&gt;mid)&#123; if(type)&#123; for(int i=1;i&lt;=cnta;i++)ans-=val[ls[qa[i]]]; for(int i=1;i&lt;=cntb;i++)ans+=val[ls[qb[i]]]; &#125; for(int i=1;i&lt;=cnta;i++)qa[i]=rs[qa[i]]; for(int i=1;i&lt;=cntb;i++)qb[i]=rs[qb[i]]; l=mid+1; &#125;else&#123; if(!type)&#123; for(int i=1;i&lt;=cnta;i++)ans-=val[rs[qa[i]]]; for(int i=1;i&lt;=cntb;i++)ans+=val[rs[qb[i]]]; &#125; for(int i=1;i&lt;=cnta;i++)qa[i]=ls[qa[i]]; for(int i=1;i&lt;=cntb;i++)qb[i]=ls[qb[i]]; r=mid; &#125; &#125; return ans; &#125; int pos[maxn]; inline void work()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) &#123; ans+=query(1,i-1,a[i]=read(),0);pos[a[i]]=i; for(int x=i;x&lt;=n;x+=x&amp;-x) update(rt[x],1,n,a[i],1); &#125; printf(&quot;%lld\\n&quot;,ans); while(--m)&#123; int x=read(); ans-=query(1,pos[x]-1,x,0)+query(pos[x]+1,n,x,1); printf(&quot;%lld\\n&quot;,ans); for(int j=pos[x];j&lt;=n;j+=j&amp;-j) update(rt[j],1,n,x,-1); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; CF785E Anton and Permutation 给你一个原序列为递增排列的序列，每次交换两个位置上的数，求每次操作后的逆序对数。 思路相对于上一题，并非删除而是交换两个位置上的数，实际上就是在原位置删除两个数然后在彼此的位置又加上这两个数。 这里我先减去影响然后更新再加上影响，最后单独讨论一下这两个数之间互换对答案的贡献。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=2e5+1,maxm=3e7+1; int n,Q,a[maxn],rt[maxn]; long long ans; int ls[maxm],rs[maxm],tot,val[maxm]; void update(int &amp;ro,int l,int r,int x,int k)&#123; if(!ro) ro=++tot; val[ro]+=k; if(l==r)return; int mid=l+r&gt;&gt;1; if(x&lt;=mid)update(ls[ro],l,mid,x,k); else update(rs[ro],mid+1,r,x,k); &#125; int qa[maxn],qb[maxn]; inline long long query(int l,int r,int x,int type)&#123; int cnta=0,cntb=0; long long ans=0; for(int i=l-1;i;i-=i&amp;-i) qa[++cnta]=rt[i]; for(int i=r;i;i-=i&amp;-i) qb[++cntb]=rt[i]; l=1,r=n; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(x&gt;mid)&#123; if(type)&#123; for(int i=1;i&lt;=cnta;i++) ans-=val[ls[qa[i]]]; for(int i=1;i&lt;=cntb;i++) ans+=val[ls[qb[i]]]; &#125; for(int i=1;i&lt;=cnta;i++) qa[i]=rs[qa[i]]; for(int i=1;i&lt;=cntb;i++) qb[i]=rs[qb[i]]; l=mid+1; &#125;else&#123; if(!type)&#123; for(int i=1;i&lt;=cnta;i++) ans-=val[rs[qa[i]]]; for(int i=1;i&lt;=cntb;i++) ans+=val[rs[qb[i]]]; &#125; for(int i=1;i&lt;=cnta;i++) qa[i]=ls[qa[i]]; for(int i=1;i&lt;=cntb;i++) qb[i]=ls[qb[i]]; r=mid; &#125; &#125; return ans; &#125; inline void work()&#123; n=read(),Q=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=i; for(int j=i;j&lt;=n;j+=j&amp;-j) update(rt[j],1,n,a[i],1); &#125; while(Q--)&#123; int x=read(),y=read(); if(x==y)&#123; printf(&quot;%lld\\n&quot;,ans);continue; &#125; if(x&gt;y)swap(x,y); ans=ans-query(1,x-1,a[x],0)-query(x+1,n,a[x],1)-query(1,y-1,a[y],0)-query(y+1,n,a[y],1); for(int i=x;i&lt;=n;i+=i&amp;-i) update(rt[i],1,n,a[x],-1),update(rt[i],1,n,a[y],1); for(int i=y;i&lt;=n;i+=i&amp;-i) update(rt[i],1,n,a[x],1),update(rt[i],1,n,a[y],-1); swap(a[x],a[y]); ans=ans+query(1,x-1,a[x],0)+query(x+1,n,a[x],1)+query(1,y-1,a[y],0)+query(y+1,n,a[y],1); ans+=(a[x]&lt;a[y]?1:-1); printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; P1975 [国家集训队]排队 给你一个序列，每次交换两个位置上的数，求每次操作后逆序对数。 思路给上面的代码加个离散化XD 后面单独讨论两个数的贡献时有一点区别。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=2e4+1,maxm=3e6+1; int n,Q,a[maxn],cnt,b[maxn],rt[maxn]; long long ans; int ls[maxm],rs[maxm],tot,val[maxm]; void update(int &amp;ro,int l,int r,int x,int k)&#123; if(!ro) ro=++tot; val[ro]+=k; if(l==r)return; int mid=l+r&gt;&gt;1; if(x&lt;=mid)update(ls[ro],l,mid,x,k); else update(rs[ro],mid+1,r,x,k); &#125; int qa[maxn],qb[maxn]; inline long long query(int l,int r,int x,int type)&#123; int cnta=0,cntb=0; long long ans=0; for(int i=l-1;i;i-=i&amp;-i) qa[++cnta]=rt[i]; for(int i=r;i;i-=i&amp;-i) qb[++cntb]=rt[i]; l=1,r=n; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(x&gt;mid)&#123; if(type)&#123; for(int i=1;i&lt;=cnta;i++) ans-=val[ls[qa[i]]]; for(int i=1;i&lt;=cntb;i++) ans+=val[ls[qb[i]]]; &#125; for(int i=1;i&lt;=cnta;i++) qa[i]=rs[qa[i]]; for(int i=1;i&lt;=cntb;i++) qb[i]=rs[qb[i]]; l=mid+1; &#125;else&#123; if(!type)&#123; for(int i=1;i&lt;=cnta;i++) ans-=val[rs[qa[i]]]; for(int i=1;i&lt;=cntb;i++) ans+=val[rs[qb[i]]]; &#125; for(int i=1;i&lt;=cnta;i++) qa[i]=ls[qa[i]]; for(int i=1;i&lt;=cntb;i++) qb[i]=ls[qb[i]]; r=mid; &#125; &#125; return ans; &#125; inline void work()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=b[i]=read(); sort(b+1,b+1+n); cnt=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+1+cnt,a[i])-b; for(int i=1;i&lt;=n;i++)&#123; ans+=query(1,i-1,a[i],0); for(int j=i;j&lt;=n;j+=j&amp;-j) update(rt[j],1,n,a[i],1); &#125; printf(&quot;%lld\\n&quot;,ans); Q=read(); while(Q--)&#123; int x=read(),y=read(); if(x==y)&#123; printf(&quot;%lld\\n&quot;,ans);continue; &#125; if(x&gt;y)swap(x,y); ans=ans-query(1,x-1,a[x],0)-query(x+1,n,a[x],1)-query(1,y-1,a[y],0)-query(y+1,n,a[y],1); for(int i=x;i&lt;=n;i+=i&amp;-i) update(rt[i],1,n,a[x],-1),update(rt[i],1,n,a[y],1); for(int i=y;i&lt;=n;i+=i&amp;-i) update(rt[i],1,n,a[x],1),update(rt[i],1,n,a[y],-1); swap(a[x],a[y]); ans=ans+query(1,x-1,a[x],0)+query(x+1,n,a[x],1)+query(1,y-1,a[y],0)+query(y+1,n,a[y],1); if(a[x]&lt;a[y]) ans+=1; else if(a[x]&gt;a[y]) ans-=1; printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 对于后两个题更简单并且更优秀的分块解法，我不会因为没有普适性所以我们不学，嗯嗯。","categories":[{"name":"题解","slug":"题解","permalink":"https://starcried.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"逆序对","slug":"逆序对","permalink":"https://starcried.github.io/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"}]},{"title":"分数规划","slug":"分数规划","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T16:08:32.768Z","comments":true,"path":"2022/04/30/分数规划/","permalink":"https://starcried.github.io/2022/04/30/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","excerpt":"","text":"问题描述有 $n$ 个物品，每种物品两个权值 $a_i$，$b_i$，求一组 $w_i\\in{0,1}$，使得 $$\\frac{\\sum_{i&#x3D;1}^n w_i\\cdot a_i}{\\sum_{i&#x3D;1}^n w_i\\cdot b_i}$$ 最大（或最小）。 有可能包含其他限制。 二分法显然答案是单调的。对一个答案 $mid$，有 $$\\begin{aligned}&amp;\\frac{\\sum_{i&#x3D;1}^n w_i\\cdot a_i}{\\sum_{i&#x3D;1}^n w_i\\cdot b_i}&gt;mid\\\\Leftrightarrow&amp;\\sum_{i&#x3D;1}^n w_i\\cdot a_i-mid\\sum_{i&#x3D;1}^n w_i\\cdot b_i&gt;0\\\\Leftrightarrow&amp;\\sum_{i&#x3D;1}^n w_i\\cdot (a_i-mid \\cdot b_i)&gt;0\\\\end{aligned}$$ 因此可以对该权值 $a_i-mid \\cdot b_i$ 进行贪心对答案进行检查。顺便满足题目要求。 例题POJ2976 123456789101112131415161718192021222324252627282930313233343536//01分数规划 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,k;int a[1010],b[1010];double d[1010];const double eps=1e-7;inline bool ok(double x)&#123; for(int i=1;i&lt;=n;i++) d[i]=a[i]-x*b[i]; sort(d+1,d+1+n); double ans=0; for(int i=n;i&gt;=k+1;i--)ans+=d[i]; return ans&gt;=0;&#125;int main()&#123;while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k) and n|k)&#123;for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,a+i);for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,b+i);double l=0,r=1;while(r-l&gt;eps)&#123;double mid=(l+r)/2;if(ok(mid))l=mid;else r=mid;&#125;printf(&quot;%.0f\\n&quot;,l*100);&#125;return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"二分法","slug":"二分法","permalink":"https://starcried.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}]},{"title":"分层图","slug":"分层图","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T12:35:23.653Z","comments":true,"path":"2022/04/30/分层图/","permalink":"https://starcried.github.io/2022/04/30/%E5%88%86%E5%B1%82%E5%9B%BE/","excerpt":"","text":"前言前几天考试了发现这个东西完全不会欸……学了又忘真是讨厌至极 QAQ 所以又在网上找着看了看写一篇博客备忘。 学习笔记真的很有用！ 分层图这个很容易理解，来源就是在一些最短路的问题上题目又加了比如说主角可以用传送宝石进行折跃之类的问题（针对），即可以选择k条边把这些边的边权变为零。 怎么样解决呢？可以在原图的基础上多复制k个相同的图，并用k条边把图之间的边用0边权边相连。就是： 于是就有人说了，复制一个图不是需要很多的空间吗，直接爆掉了怎么办(╯‵□′)╯︵┻━┻ （是的有这种可能所以图k不能太大） 其实因为都是复制的好像不需要很多空间，因为图基本上都是一样的。所以只需要用二维数组 dis 记录就行了~（所以可以理解为把二维的图变成了三维，然后有 $k$ 个 $0$ 边权的虫洞可以折跃（雾）） 只需要走一次就行。这里我用 dijkstrua~ 例题题目我是从这里搬的。代码是我的。但是我没有数据所以有可能是错的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;utility&gt;#include&lt;functional&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1e4,maxm=5e4,maxk=10,INF=~0U&gt;&gt;1;int n,m,k,start,end;struct edge&#123; int to,next,dis;&#125;e[4*maxm*(maxk+1)+maxk+1];int ecnt,head[maxn*(maxk+1)+1];void addedge(int from,int to,int dis)&#123; //这种赋值写法必须加强制类型转换，c11可以不用 e[++ecnt]=(edge)&#123;to,head[from],dis&#125;;head[from]=ecnt;&#125;void read(int &amp;x)&#123; bool flag = false; char c; do c=getchar();while(c!=&#x27;-&#x27; and (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;)); if(c==&#x27;-&#x27;)flag=true; else x+=c-&#x27;0&#x27;; c=getchar(); while(c&gt;=&#x27;0&#x27; and c&lt;=&#x27;9&#x27;)x*=10,x+=c-&#x27;0&#x27;,c=getchar();&#125;inline void readin()&#123; read(n);read(m);read(k);read(start);read(end); for(int i=1;i&lt;=m;i++) &#123; int a,b,w; read(a);read(b);read(w); //重点来了，开始建边权为零的边 for(int j=0;j&lt;=k;j++) &#123; addedge(a+n*j,b+n*j,w);addedge(b+n*j,a+n*j,w); //这两行是建图并复制图，共建造k+1个图 if(j!=k)//小心别建到虚无中去~ &#123; addedge(a+n*j,b+n*(j+1),0);addedge(b+n*j,a+n*(j+1),0); //这两行是在图之间建边权为0的边 &#125; &#125; &#125;&#125;//分层图的核心已经完成，下面是开心的dijkstrua时间 int dis[maxn*(maxk+1)];bool vis[maxn*(maxk+1)];typedef pair&lt;int,int&gt; pairr;void dijskra()&#123; priority_queue &lt;pairr,vector&lt;pairr &gt;,greater&lt;pairr &gt; &gt; q; q.push(make_pair(0,start)); memset(dis,0x3f3f3f3f,sizeof(dis)); dis[start]=0; while(!q.empty()) &#123; int u=q.top().second;q.pop(); if(!vis[u]) &#123; vis[u]=1; for(int i=head[u];i;i=e[i].next) &#123; int to=e[i].to; if(dis[u]+e[i].dis&lt;dis[to]) &#123; dis[to]=dis[u]+e[i].dis; q.push(make_pair(dis[to],to)); &#125; &#125; &#125; &#125;&#125;int main()&#123; readin(); dijskra(); cout&lt;&lt;dis[end]; return 0;&#125; P4568 [JLOI2011]飞行路线 如果掌握了方法的话这个题和上一道基本上是一模一样的，只需要把板子粘下来就行了。不过我们可以从上一道题发现建的边数太多了啊喂……所以我们这次用一下前面提到的二元数组记录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;utility&gt;#include&lt;functional&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1e4,maxm=5e4,maxk=10,INF=~0U&gt;&gt;1;int n,m,k,start,end;struct edge&#123; int to,next,dis;&#125;e[4*maxm*(maxk+1)+maxk+1];int ecnt,head[maxn*(maxk+1)+1];void addedge(int from,int to,int dis)&#123; e[++ecnt]=(edge)&#123;to,head[from],dis&#125;;head[from]=ecnt;&#125;void read(int &amp;x)&#123; bool flag = false; char c; do c=getchar();while(c!=&#x27;-&#x27; and (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;)); if(c==&#x27;-&#x27;)flag=true; else x=c-&#x27;0&#x27;; c=getchar(); while(c&gt;=&#x27;0&#x27; and c&lt;=&#x27;9&#x27;)x*=10,x+=c-&#x27;0&#x27;,c=getchar();&#125;int read2()&#123; int x; char c=getchar(); while(c&lt;&#x27;0&#x27; or c&gt;&#x27;9&#x27;)c=getchar(); x=c-&#x27;0&#x27;;c=getchar(); while(c&gt;=&#x27;0&#x27; and c&lt;=&#x27;9&#x27;) x*=10,x+=c-&#x27;0&#x27;,c=getchar(); return x;&#125;void readin()&#123;// read(n);read(m);read(k);read(start);read(end); n=read2(),m=read2(),k=read2(),start=read2(),end=read2(); for(int i=0;i&lt;m;i++) &#123; int a,b,w;// read(a);read(b);read(w); a=read2(),b=read2(),w=read2(); //重点来了，开始建边权为零的边 for(int j=0;j&lt;=k;j++) &#123; addedge(a+n*j,b+n*j,w);addedge(b+n*j,a+n*j,w); //这两行是建图并复制图，共建造k+1个图 if(j!=k)//小心别建到虚无中去~ &#123; addedge(a+n*j,b+n*(j+1),0);addedge(b+n*j,a+n*(j+1),0); //这两行是在图之间建边权为0的边 &#125; &#125; &#125;&#125;//分层图的核心已经完成，下面是开心的dijskrua时间 int dis[maxn*(maxk+1)];bool vis[maxn*(maxk+1)];typedef pair&lt;int,int&gt; pairr;void dijkstra()&#123; priority_queue &lt;pairr,vector&lt;pairr &gt;,greater&lt;pairr &gt; &gt; q; q.push(make_pair(0,start)); memset(dis,0x3f3f3f3f,sizeof(dis)); dis[start]=0; while(!q.empty()) &#123; int u=q.top().second;q.pop(); if(!vis[u]) &#123; vis[u]=1; for(int i=head[u];i;i=e[i].next) &#123; int to=e[i].to; if(dis[u]+e[i].dis&lt;dis[to]) &#123; dis[to]=dis[u]+e[i].dis; q.push(make_pair(dis[to],to)); &#125; &#125; &#125; &#125;&#125;int main()&#123; readin(); dijkstra(); for(int i=1;i&lt;=k;++i) &#123; addedge(end+(i-1)*n,end+i*n,0); &#125; cout&lt;&lt;dis[end+k*n]; return 0;&#125; 飞行路线1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;utility&gt; 4 #include&lt;queue&gt; 5 #include&lt;functional&gt; 6 #include&lt;vector&gt; 7 #include&lt;algorithm&gt; 8 #include&lt;cstring&gt; 9 using namespace std;10 const int maxn=1e4,maxm=5*1e4,maxk=10;11 typedef pair&lt;int,int&gt; pairr;12 struct edge&#123;13 int to,nxt,dis;14 &#125;e[maxm*4];15 int n,m,k,start,end,d[maxn][maxk+1];16 bool vis[maxn][maxk+1];17 inline int read()18 &#123;19 int x=0;char c=getchar();20 while(!isdigit(c))c=getchar();21 while(isdigit(c))x=x*10+c-&#x27;0&#x27;,c=getchar();22 return x;23 &#125;24 int ecnt,head[maxn];25 inline void addedge(int from,int to,int dis)26 &#123;27 e[++ecnt]=(edge)&#123;to,head[from],dis&#125;,head[from]=ecnt;28 &#125;29 30 void input()31 &#123;32 n=read(),m=read(),k=read(),start=read(),end=read();33 for(int i=0;i&lt;m;i++)34 &#123;35 int from=read(),to=read(),dis=read();36 addedge(from,to ,dis);addedge(to,from,dis);37 &#125;38 &#125;39 40 void dijkstra()41 &#123;42 priority_queue &lt;pairr,vector&lt;pairr&gt;,greater&lt;pairr &gt; &gt; q;43 memset(d,0x3f3f3f3f,sizeof(d));44 d[start][0]=0;45 q.push(make_pair(0,start));46 while(!q.empty())47 &#123;48 int v=q.top().second;q.pop();49 int kk=v/n; //kk标记当前已用的k次数 50 v%=n; //v变为图中点的位置 51 for(register int i=head[v];i;i=e[i].nxt)52 &#123;53 int u=e[i].to,w=e[i].dis;54 if(d[v][kk]+w&lt;d[u][kk]) 55 &#123;56 d[u][kk]=d[v][kk]+e[i].dis;57 q.push(make_pair(d[u][kk],u+(kk)*n));58 &#125;59 if(kk==k)continue;//用完了就算了QAQ 60 if(d[u][kk+1]&gt;d[v][kk])//可以用而且不穿越解非最优就传送 61 &#123;62 d[u][kk+1]=d[v][kk];63 q.push(make_pair(d[u][kk+1],u+(kk+1)*n));//这里编号乘一下以记录层数（因为没有结构体就酱紫了） 64 &#125;65 &#125;66 &#125;67 &#125;68 int main()69 &#123;70 input();71 dijkstra();72 // cout&lt;&lt;d[end][k];//输出全部用过达到的距离 73 //这个输出被最后一组数据hack了，好像是不用用完k个的。所以我们找个min74 int ans=0x3f3f3f3f; 75 for(int i=0;i&lt;=k;i++)ans=min(ans,d[end][i]);76 printf(&quot;%d\\n&quot;,ans);77 return 0;78 &#125; 笔者用的是pair记录，好像用结构体能更清楚一些并记录层数，其实没什么区别的。大家随意（干杯）","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"https://starcried.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"在 Ubuntu 22.04 上部署 WordPress","slug":"在 Ubuntu 22.04 上部署 WordPress","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.474Z","comments":true,"path":"2022/04/30/在 Ubuntu 22.04 上部署 WordPress/","permalink":"https://starcried.github.io/2022/04/30/%E5%9C%A8%20Ubuntu%2022.04%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20WordPress/","excerpt":"","text":"很简单的事情被搞得很复杂，踩了很多坑……以及莫名其妙的错误。本来碰壁了之后会一拖再拖。昨天新冠阳性难受了一整天，晚上退烧了，不想学数学就想搞搞这个，第二天早上就弄好了。果然这种东西需要的最重要的是耐心和时间。 教程搞了好久才找到这篇博客重新搞了一遍。博主基本上是手把手教了，很新，而且有链接可以直接跳转引用的位置去看。用的是 Nginx, MySQL, php7.4, php-fpm。 下面是一些小细节。 配置 Nginx 的时候记得把域名和网站文件位置替换成自己的。 如果想把 WordPress 部署在根域名 example.com 而非子域名 example.com/wordpress，只需把文件内容直接放在 html 文件夹内即可。 普适教训 国外的信息比国内的新很多，最好还是去外面搜索信息吧。 论坛是很有价值的，大多数问题都可以在（国外）论坛被解决。实在找不到也可以发帖自己问。 不要错过任何一条信息，尤其是在用命令行的时候。 看教程的时候要注意各种版本。有时候最新版可能会不适配。 历程第一次拖了好长时间是因为 mysql 无法登录，提示密码错误。但在网上搜到的所有教程都说刚装好的 mysql 是可以不用密码 root 登录的。想到可能是我之前瞎操作让系统帮我设了密码啥的没记下来，于是开始尝试重置密码。但是试了很多教程，要么是要找的配置文件压根不存在，要么是版本不同，搞下去越来越乱。 于是干脆重装了系统……不得不说，问题解决了。 另外，mysql 在不同系统上的操作以及文件名也不完全相同。我甚至专门去把 mysql 指令学习了一点。 然后大概就……没了。我也不知道我为什么花费了那么长时间。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"基数排序","slug":"基数排序","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T15:49:02.960Z","comments":true,"path":"2022/04/30/基数排序/","permalink":"https://starcried.github.io/2022/04/30/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"算法描述基数排序（又叫做桶排序）是一种非比较排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别进行排序。 基数排序的步骤如下： 找出最大数，确定位数。 确定每个位数的范围，并统计每个数字在每个位数上的数量。 位数从低到高按每个位数从小到大进行排序。 输出排序后的数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;const int maxn=1e5+10;int a[maxn],buck[maxn];inline int get_max(int a[],int n)&#123; int maxx=0; for(int i=0;i&lt;n;i++) maxx=max(maxx,a[i]); return maxx;&#125;inline void count_sort(int a[],int n,int exp)&#123; int output[n],buck[10]=&#123;0&#125;; for(int i=0;i&lt;n;i++) buck[(a[i]/exp)%10]++; for(int i=1;i&lt;10;i++) buck[i]+=buck[i-1]; for(int i=n-1;i&gt;=0;i--) output[--buck[(a[i]/exp)%10]]=a[i]; for(int i=0;i&lt;n;i++) a[i]=output[i];&#125;inline void radix_sort(int a[],int n)&#123; int maxx=get_max(a,n); for(int i=1;(maxx/i)&gt;0;i*=10) count_sort(a,n,i);&#125;int main()&#123; int n=read(); for(int i=0;i&lt;n;i++) a[i]=read(); radix_sort(a,n); for(int i=0;i&lt;n;i++) if(i!=n)printf(&quot;%d &quot;,a[i]); else printf(&quot;%d\\n&quot;,a[i]); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"}]},{"title":"原根[非公开][草稿]","slug":"原根[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.473Z","comments":true,"path":"2022/04/30/原根[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E5%8E%9F%E6%A0%B9[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"定义 设m是正整数，a是整数，若a模m的阶等于&phi;(m)，则称a为模m的一个原根。 阶是什么呢？阶就是使 注意，一个正整数有原根的充要条件是 欧拉定理 若正整数n,a互素，则 a&phi;n= 例如要求10的原根， &phi;10=4 1^4=1 2^4mod 10=6 3^4mod 10=1 但是这样枚举太暴力了。 我们可以求出x-1的所有的质因子，对于任何a&isin;[2,x-1],只需要检验a(x-1)/pi mod x有没有pi使它等于1.如没有就没有原根。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"容斥原理[非公开][草稿]","slug":"容斥原理[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.475Z","comments":true,"path":"2022/04/30/容斥原理[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"容斥原理就是 例1 http://acm.hdu.edu.cn/showproblem.php?pid=4135 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; typedef long long ll; int prime[33],pn;//pn是1-n互质数的个数 inline ll calc(ll n); int main() { ll a,b; int t,n; scanf(\"%d\",&amp;t); for(int cas=1;cas&lt;=t;cas++) { scanf(\"%lld%lld%d\",&amp;a,&amp;b,&amp;n); pn=0; for(int i=2;i*i&lt;=n;i++){//无序求n的互质数 if(n%i)continue; while(!n%i)n/=i; prime[pn++]=i; } if(n!=1)prime[pn++]=n;//加上n printf(\"Case #%d: %lld\\n\",cas,calc(b)-calc(a-1)); } } inline ll calc(ll n) { ll res=0; for(int i=1;i&lt;(1&lt;&lt;pn);i++){ int tmp=1,cnt=0; for(int j=0;j&lt;pn;j++){ if(((i&gt;&gt;j)&amp;1)==0)continue; ++cnt; tmp*=prime[j];//数的最小公倍数 } if(cnt&amp;1)res+=n/tmp;//如果是奇数个数，根据容斥原理加上 else res-=n/tmp; } return n-res; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"匈牙利算法（二分图最大匹配）[非公开][草稿]","slug":"匈牙利算法（二分图最大匹配）[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.473Z","comments":true,"path":"2022/04/30/匈牙利算法（二分图最大匹配）[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%89[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"无用的文字 又是一篇笔记，因为不做题的话太容易忘了啊啊啊QAQ看到一个题目知道用什么算法做但就是想不出来的感觉太难受了&hellip;&hellip; 二分图 二分图就是一个图被分成两个图一个图G，其中的点被分成A,B两组，且A&cup;B​=G，A&cap;B=&empty;。这两个点集A,B分别称为左部和右部，其中的点分别被称为左部点和右部点。 这个概念只是用来判断一道题的适用算法的。 匈牙利算法 匈牙利算法是用来寻找最大匹配的一个算法。 prepare 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边...形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。 我太懒了就想存个板子思路讲清就行了吧图解什么的看看别的大佬的就行了 因为挺简单的XD 可以通过DFS或BFS实现。当然我只会DFS 问题类型分为最大匹配和最优匹配。 //匈牙利算法代码实现； //二分图最大匹配； //即左边的点和右边的点连线最多； //匈牙利算法主要用了增广路径比原路径多; /*因为原路径相当于从左边一点向右匹配， 每次匹配后只有两点两两相配，增广路匹配数+1； 深搜即可 */ #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;ctype.h&gt; using namespace std; int n,m; const int maxn=233; int a[maxn],mapp[maxn][maxn]; bool vis[maxn]; inline int read() { int x=0,w=1;char c=getchar(); while(!isdigit(c)){ if(c=='-')w=-1; c=getchar(); } while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return x*w; } bool match(int x)//x为左侧点标号 { for(int i=1;i&lt;=m;i++) if(mapp[x][i] and !vis[i]) { vis[i]=1; if(!a[i]||match(a[i])) { a[i]=x; return true; } } return false; } inline int hungary() { int ans=0; memset(a,0,sizeof a); for(int i=1;i&lt;=n;i++) { memset(vis,0,sizeof vis); if(match(i))ans++; } return ans; } int main() { n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)mapp[i][j]=read(); printf(\"%d\\n\",hungary()); return 0; } 二分图最大匹配-矩阵存图 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"平面几何入门","slug":"平面几何入门","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.477Z","comments":true,"path":"2022/04/30/平面几何入门/","permalink":"https://starcried.github.io/2022/04/30/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95%E5%85%A5%E9%97%A8/","excerpt":"","text":"为了给同学讲课，做了一个平面几何入门的课件，保存在网上。平面几何入门奇怪的是明明是平面几何还写了一点三维的东西。应该叫计算几何的。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"并查集及其优化","slug":"并查集及其优化","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-10T14:20:26.357Z","comments":true,"path":"2022/04/30/并查集及其优化/","permalink":"https://starcried.github.io/2022/04/30/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/","excerpt":"","text":"并查集并查集是一种树型数据结构，用于处理一些动态集合的合并及查询问题。 并查集的基本操作有： 合并：将两个集合合并为一个集合。 查询：判断两个元素是否属于同一个集合。 并查集的应用场景有： 动态连通性：判断两个点是否连通。 最小生成树：计算最小生成树。 路径压缩：减少树的高度。 并查集优化并查集有两种启发式优化。第一种是路径压缩，即将每个节点的父节点压缩到根节点，总时间复杂度为 $O(n\\alpha)$，其中 $\\alpha$ 为一常数。但是会破坏树形结构。 另一种是按秩合并，即将两个集合合并时，选择秩较大的集合作为根节点，总时间复杂度为 $O(n\\log n)$。由于并其没有破坏树形结构，所以可以实现一些撤回操作。 路径压缩路径压缩的基本思想是将每个节点的父节点压缩到根节点，这样可以减少树的高度，使得查询操作更快。 1234// 初始化 parent[i] = iint find(int x) &#123; return x == parent[x]? x : parent[x] = find(parent[x]);&#125; 按秩合并我们从一道例题开始。 UVA11354 大意：求最小生成树的两个点间的最大路径。 带边权的并查集？多组数据？我们按秩合并。基本思想是使深度较小结点的树的根指向包含较多结点的树的根。 我们存边时，用结构体存边。但不用前向星。因为如果要 Kruskal 的话需要改动一下。本来我们连接最短的边时，如果两端的端点的父亲不一样的话直接连上就可以了。但是按秩排序不一样。他既要优化又要不破坏树形结构，我们就造一个秩rank，rank[i]表示的相当于子树大小或者深度的东西，每次查询就把小的连到大的上并直接把边权直接连到父亲结点上，那么就能保留原来的树形结构并做到优化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;ctype.h&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 50010;inline int read()&#123; int x = 0, w = 1; char c = getchar(); while (!isdigit(c)) &#123; if (c == &#x27;-&#x27;) w = -1; c = getchar(); &#125; while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48), c = getchar(); return x * w;&#125;int n, m, t;int fa[maxn], e[maxn], rank[maxn];struct data&#123; // 这是边 int x, y, z;&#125; a[maxn];inline bool cmp(data a, data b) &#123; return a.z &lt; b.z; &#125;inline int find(int x) &#123; return fa[x] == x ? x : find(fa[x]); &#125;inline void kruskal()&#123; int s = 0, f1, f2; for (int i = 1; i &lt;= n; i++) fa[i] = i, rank[i] = 1; for (int i = 1; i &lt;= m; i++) &#123; f1 = find(a[i].x); f2 = find(a[i].y); if (f1 != f2) &#123; if (rank[f1] &lt; rank[f2]) &#123; fa[f1] = f2; e[f1] = a[i].z; rank[f2] = max(rank[f2], rank[f1] + 1); &#125; // 高度大的做小的的根 else &#123; fa[f2] = f1; e[f2] = a[i].z; rank[f1] = max(rank[f1], rank[f2] + 1); &#125; // 相等或者相反就相反来 s++; &#125; if (s == n - 1) break; &#125;&#125;int c[maxn];int query(int x, int y)&#123; for (int i = 1; i &lt;= n; i++) c[i] = -1; int tmp = 0, ans = 0; while (1) &#123; c[x] = tmp; // c是从x开始向上边的最大值。 if (fa[x] == x) break; tmp = max(tmp, e[x]); // e代表向上连接的边权 x = fa[x]; // 向上爬 &#125; while (1) &#123; if (c[y] &gt;= 0) &#123; ans = max(ans, c[y]); break; &#125; // 找到LCA就break if (fa[y] == y) break; // 或者找到根 ans = max(ans, e[y]); y = fa[y]; &#125; // 因为一定会集中到LCA就直接用ans return ans;&#125;int main()&#123; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= m; i++) &#123; a[i] = (data)&#123;read(), read(), read()&#125;; &#125; sort(a + 1, a + 1 + m, cmp); kruskal(); t = read(); for (int x, y, i = 1; i &lt;= t; i++) &#123; x = read(), y = read(); printf(&quot;%d\\n&quot;, query(x, y)); &#125; &#125; return 0;&#125; 按秩合并不仅仅能够处理最小生成树问题，也可以处理一些大规模数据的动态加边和查询问题，每次连边后可以记录两个秩的大小，非常的方便。","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"https://starcried.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"并查集","slug":"并查集","permalink":"https://starcried.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"归并排序","slug":"归并排序","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T12:47:18.199Z","comments":true,"path":"2022/04/30/归并排序/","permalink":"https://starcried.github.io/2022/04/30/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"算法描述运用了分治的思想，将一个数组分成几乎相等的两份，分别将两段中第一个最小的数拿出来放在一个临时数组中，直到全部取完。因为是递归的，所以每一段的数列都是排序好的。 1234567891011121314void merge_sort(ll *A,ll *B,int x,int y)&#123; if(y-x&lt;=1)return; int mid=x+(y-x)/2; int p=x,q=mid,i=x; merge_sort(A,B,x,mid); merge_sort(A,B,mid,y); while(p&lt;mid or q&lt;y) &#123; if(q&gt;=y or (p&lt;mid and A[p]&lt;=A[q]))B[i++]=A[p++]; else B[i++]=A[q++],ans+=mid-p; &#125; for(int i=x;i&lt;y;i++)A[i]=B[i];&#125; 时间复杂度为 $O(n\\log n)$。 例题可以利用分治的过程处理一些问题，比如求数组的逆序对。 我们发现每次递归时左边的还没有入列的数都是大于右边的数的，此时统计左侧比右侧该数大的数的个数，即可统计到所有的逆序对。 洛谷P1908 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;template &lt;typename T&gt;inline T read()&#123; int w=0;T x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;const int maxn=5e5+10;int n;ll A[maxn],B[maxn],ans;void merge_sort(ll *A,ll *B,int x,int y)&#123; if(y-x&lt;=1)return; int mid=x+(y-x)/2; int p=x,q=mid,i=x; merge_sort(A,B,x,mid); merge_sort(A,B,mid,y); while(p&lt;mid or q&lt;y) &#123; if(q&gt;=y or (p&lt;mid and A[p]&lt;=A[q]))B[i++]=A[p++]; else B[i++]=A[q++],ans+=mid-p; &#125; for(int i=x;i&lt;y;i++)A[i]=B[i];&#125;int main()&#123; n=read&lt;int&gt;(); for(int i=1;i&lt;=n;i++)A[i]=read&lt;ll&gt;(); merge_sort(A,B,1,n+1); printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"分治","slug":"分治","permalink":"https://starcried.github.io/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"快速幂","slug":"快速幂","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T16:02:43.692Z","comments":true,"path":"2022/04/30/快速幂/","permalink":"https://starcried.github.io/2022/04/30/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"快速幂快速幂是在进行底数相同的乘法运算而幂数又极大的情况下使用的一种算法。 将幂次做二进制拆分，然后从低位到高位维护幂次积，同时若该位为 1 乘入答案。 模板P1226 【模板】快速幂 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#define int unsigned long longusing namespace std;int a,b,q;int qsm(int a,int b,int q)//快速幂&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=(ans*a)%q; a=(a*a)%q; b&gt;&gt;=1; //二进制运算，相当于b/=2; &#125; return ans%q;&#125;signed main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;q; cout&lt;&lt;a&lt;&lt;&quot;^&quot;&lt;&lt;b&lt;&lt;&quot; mod &quot;&lt;&lt;q&lt;&lt;&quot;=&quot;&lt;&lt;qsm(a,b,q); return 0;&#125; 矩阵快速幂矩阵快速幂是指用矩阵乘法来求幂次方，矩阵乘法的结合律和交换律保证了运算的顺序。可以套用以上的快速幂。 经典例题是求斐波那契数列第 $n$ 项（mod q）的值。和快速幂一样，这类题指数非常的大。 模板P3390 【模板】矩阵快速幂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline long long read()&#123; long long x=0;bool w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=105,mod=1e9+7; struct mat&#123; int n,a[maxn][maxn]; mat()&#123;&#125; mat(const int &amp;x)&#123;n=x;memset(a,0,sizeof a);&#125; inline void set()&#123;for(int i=1;i&lt;=n;i++) a[i][i]=1;&#125; inline int* operator [] (const int &amp;x) &#123;return a[x];&#125; inline const int* operator [] (const int &amp;x) const &#123;return a[x];&#125; inline mat operator * (const mat &amp;b) const&#123; mat ans(n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) ans[i][j]=(ans[i][j]+1ll*a[i][k]*b[k][j]%mod)%mod; return ans; &#125; &#125;now; inline mat fpow(mat a,long long b)&#123; mat ans(a.n); ans.set(); for(;b;b&gt;&gt;=1,a=a*a)if(b&amp;1)ans=ans*a; return ans; &#125; int n; long long k; inline void work()&#123; n=now.n=read();k=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) now[i][j]=read(); now=fpow(now,k); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,now[i][j]); puts(&quot;&quot;); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 至于矩阵乘法还能干什么，应该应用也挺多的，但是我还没那个水平…… 大家一起进步吧XD UPD：NOI2020出来了，发现D1T1用到了矩阵快速幂，于是来更新我写的水的一p的第一篇博客。 也就是更新一个例子：矩阵快速幂优化DP 我们先来个简单版的DP：给你一个图（的邻接矩阵），边权全为1，求给定时间从s到t的路径方案数。 记f[i]表示i时状态，f[i]&#x3D;f[i-1]*g。 所以我们要求x直接矩阵快速幂乘g的幂次就行了。 2022.9.29 UPD：高中时不求甚解写的东西……也不是我不想了解，是竞赛要求我在理解之前就使用矩阵。突然感觉竞赛和文化课其实没有什么本质区别。 没时间大改，把错误的地方尽量删了。","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"}]},{"title":"map 和 unordered_map","slug":"map 和 unordered_map","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.437Z","comments":true,"path":"2022/04/30/map 和 unordered_map/","permalink":"https://starcried.github.io/2022/04/30/map%20%E5%92%8C%20unordered_map/","excerpt":"","text":"map就是映射。 定义 map&lt;typename,typename&gt; 注：map的元素是pair。 特性 map会对第一个对象自动排序。 map不允许有两个相同的关键字。 map可以定义迭代器iterator。当然，map相当于一个像pair的结构体，要访问元素时注意使用-&gt;或者(*it).first/second。 first是key,second才是value。 typename也可以是结构体。 关键字 erase(iterator) insert(pair(typename,typename) find(typename(first)) 返回值为地址。 count(typename)查询元素次数。 栗子：记录学生姓名和成绩，通过姓名查找成绩 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;utility&gt; #include&lt;map&gt; #include&lt;string&gt; using namespace std; map &lt;string,int&gt;q; const int maxn=5; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } int main() { int n=read(); string c; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;c; q.insert(make_pair(c,read())); } int m=read(); for(int i=1;i&lt;=m;i++) { cin&gt;&gt;c; printf(\"%d\\n\",q[c]); } return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"扩展欧几里得(exgcd)-求解不定方程 求逆元","slug":"扩展欧几里得(exgcd)-求解不定方程 求逆元","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T16:37:35.132Z","comments":true,"path":"2022/04/30/扩展欧几里得(exgcd)-求解不定方程 求逆元/","permalink":"https://starcried.github.io/2022/04/30/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97(exgcd)-%E6%B1%82%E8%A7%A3%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%20%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"贝祖定理如果 $a$、$b$ 是整数，那么一定存在整数 $x$、$y$ 使得 $ax+by&#x3D;\\gcd(a,b)$。 换句话说，如果 $ax+by&#x3D;m$ 有解，那么 $m$ 一定是 $\\gcd(a,b)$ 的若干倍。（可以来判断一个这样的式子有没有解） 有一个直接的应用就是 如果 $ax+by&#x3D;1$ 有解，那么 $gcd(a,b)&#x3D;1$。 然而这并不能告诉我们x,y解是多少。 扩展欧几里得（exgcd）首先对 $a|b$ 一定有一个解 $a\\times 1+b\\times 0&#x3D;\\gcd(a,b)$。但是我们的 $a$ 和 $b$ 不一定满足该条件。不过我们可以辗转相除直到满足条件，然后回代： $$\\begin{aligned}&amp;b\\times x_n+(a-\\lfloor \\frac ab\\rfloor*b)\\times y_n&#x3D;\\gcd(a,b) \\\\Rightarrow &amp;a\\times y_n + b\\times(x_n – \\lfloor \\frac ab\\rfloor\\times y_n) &#x3D; \\gcd(a,b)\\\\Rightarrow &amp;x_{n+1} &#x3D; y_n , y_{n+1} &#x3D; x_n – \\lfloor \\frac ab\\rfloor\\times y_n\\\\end{aligned}$$ 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)//这个是返回值版的 &#123; if(!b) &#123; x=1;y=0; return a; //边界 &#125; int r=exgcd(b,a%b,x,y); int temp=y; //把x y变成上一层的 y=x-(a/b)*y; x=temp; //更改x和y的值，因为是引用的 return r; //得到a b的最大公因数&#125;void exgcd1(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)//这个不返回直接更新 &#123; if(!b)d=a,x=1,y=0; else &#123; exgcd1(b,a%b,d,y,x); y-=x*(a/b); &#125;&#125;int main()&#123; ll a,b,d,x,y; cin&gt;&gt;a&gt;&gt;b; d=exgcd(a,b,x,y);//最大公约数// exgcd1(a,b,d,x,y); printf(&quot;%d %d&quot;,x,y);//x，y已经被更新了 return 0;&#125; 解释一下 exgcd1() 的递推式。d 是最大公约数，这个在 b=0，即上一层 a%b==0 时找到，更新传回即可。 我们 x 和 y 都是直接更新地址的，那我们这里的 y 其实就是传给上一层的 x，相当于 y=x-(a/b)*y，因为我们传下来的时候是将 x 和 y 颠倒的，那么这里 x 就和 y 互换,即 y-=(a/b)*x，x 还是 x，传上去就变成 y 了。 求逆元上面得到的 $x$ 即为 $a$ 在 $\\pmod b$ 意义下的逆元。 注意，一个数的是有可能没有逆元的，需要提前判断，否则这时候 x 好像是返回 $1$。如果是有逆元的，解出来的 x 有可能是负数，这时候你可能需要 x=(x+mod)%mod。 求不定方程（我之前没用Markdown写得真难受） （这个部分是我学了excrt之后才更新的） （之前学的真是肤浅而且一团乱麻） exgcd 既然可以求 $ax+by&#x3D;\\gcd(a,b)$ 的解，那么一定就可以求 $ax+by&#x3D;c$ 的解。 假设 $g&#x3D;\\gcd(a,b)$，那么我们先把方程两边同时乘 $g&#x2F;c$，那么是不是就可以求 $x$ 和 $y$ 了呢？那么求完之后我们在给他乘回去不就行了？ 那就行了。 判断无解的情况：如果求出来的 $g$ 并不能被 $c$ 整除，说明在数论范围内它无解。 鉴于不定方程的性质，$x$ 的最小正整数解是在 $b$ 意义下取模的，$y$ 的最小正整数解是在 $a$ 意义下取模的。我们就可以求出 $x$，$y$ 的最小整数解和整数解的个数。因为 $x$ 和 $y$ 的增减性是相反的，我们也就可以相应算出最大值。 P5656 【模板】二元一次不定方程 (exgcd) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define int long long //watch out!using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;inline void write(int x)&#123; if(x&gt;9)write(x/10); putchar(x%10+&#x27;0&#x27;);&#125;inline void exgcd(int a,int b,int&amp; d,int&amp; x,int&amp; y)&#123; if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=(a/b)*x;&#125;inline void solve(int a,int b,int c)&#123; int cnt=0,miny,maxy,minx,maxx; int gcd,x,y; exgcd(a,b,gcd,x,y); if(c%gcd!=0)&#123;printf(&quot;-1\\n&quot;);return;&#125; a/=gcd;b/=gcd;c/=gcd;//这里学习了一下大佬的做法，将所有答案除以gcd，实际上是一样的，不过下面的x和y就不是乘c/gcd了。 x*=c; y*=c; minx=x&gt;0&amp;&amp;x%b!=0?x%b:x%b+b; maxy=(c-minx*a)/b; miny=y&gt;0&amp;&amp;y%a!=0?y%a:y%a+a; maxx=(c-miny*b)/a; if(maxx&gt;0)cnt=(maxx-minx)/b+1; if(cnt==0)printf(&quot;%d %d\\n&quot;,minx,miny); else printf(&quot;%d %d %d %d %d\\n&quot;,cnt,minx,miny,maxx,maxy);&#125;signed main()&#123; int t=read(); while(t--)&#123; int a=read(),b=read(),c=read(); solve(a,b,c); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://starcried.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"exgcd","slug":"exgcd","permalink":"https://starcried.github.io/tags/exgcd/"}]},{"title":"扩展欧拉定理","slug":"扩展欧拉定理","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T16:38:35.940Z","comments":true,"path":"2022/04/30/扩展欧拉定理/","permalink":"https://starcried.github.io/2022/04/30/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/","excerpt":"","text":"扩展欧拉定理首先，欧拉定理为$$若a与m互质，则有a^{\\varphi(m)}\\equiv1(\\mod m)$$我们可以发现费马小定理其实就是欧拉定理的特殊情况。 证明的话，构造一个与$m$互质的数列操作，利用剩余系证明 扩展欧拉定理为$$a^b\\equiv \\begin{cases}a^{b\\mod\\varphi(p)},&amp;\\gcd(a,p)&#x3D;1\\a^b,&amp;\\gcd(a,p)\\ne1,b&lt;\\varphi(p)\\a^{b\\mod\\varphi(p)+\\varphi(p)},&amp;\\gcd(a,p)\\ne1,b\\ge\\varphi(p)\\end {cases}\\pmod p$$证明请上面传送门 在程序上的体现就是加一个判断：如果$b\\ge\\varphi(p)$，我们把b的模数加上一个$\\varphi(p)$即可。 于是我们就能做掉P5091 输入幂数时取模即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; int n,m,b,phim; inline int fpow(int a,int b)&#123; int ans=1; for(;b;b&gt;&gt;=1,a=a*a%m)if(b&amp;1)ans=ans*a%m; return ans; &#125; inline void work()&#123; n=read(),m=read(); phim=m; int x=m; for(int i=2;i*i&lt;=x;i++)&#123; if(!(x%i))&#123; phim=phim-phim/i; while(!(x%i))x/=i; &#125; &#125; if(x!=1)phim=phim-phim/x; char c=getchar(); bool ok=0; while(!isdigit(c))c=getchar(); while(isdigit(c))&#123; b=b*10+(c^48);c=getchar(); if(b&gt;=phim)ok=1,b%=phim; &#125; if(!ok)printf(&quot;%lld\\n&quot;,fpow(n,b)); else printf(&quot;%lld\\n&quot;,fpow(n,b+phim)); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; CF906D 显然，对于对幂数取模的结果就是再次递归使用欧拉函数。递归求解即可。 先预处理出模数的多次取phi的结果然后递归。注意在快速幂的时候需要判断第二种情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=1e5+10; int mod,n,w[maxn],phi[maxn],tot; inline int fpow(int a,int b,int mod)&#123; int ans=1; bool ok=0; for(;b;b&gt;&gt;=1,a=a*a)&#123; if(a&gt;=mod)ok=1,a%=mod; if(b&amp;1)ans=ans*a; if(ans&gt;=mod)ok=1; ans%=mod; &#125; return ans+ok*mod; &#125; int dfs(int l,int r,int dep)&#123; if(phi[dep]==1||w[l]==1) return 1; if(l==r) return w[l]&gt;=phi[dep]?w[l]%phi[dep]+phi[dep]:w[l]; return fpow(w[l],dfs(l+1,r,dep+1),phi[dep]); &#125; inline void work()&#123; n=read(),mod=phi[0]=read(); for(int i=1;i&lt;=n;i++)w[i]=read(); while(phi[tot]!=1)&#123; int x=phi[tot++];phi[tot]=phi[tot-1]; for(int i=2;i*i&lt;=x;i++)&#123; if(!(x%i))&#123; phi[tot]=phi[tot]-phi[tot]/i; while(!(x%i))x/=i; &#125; &#125; if(x&gt;1)phi[tot]=phi[tot]-phi[tot]/x; &#125; int q=read(); while(q--)&#123; int l=read(),r=read(); printf(&quot;%lld\\n&quot;,dfs(l,r,0)%mod); &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; P3934 区间修改，单点查询，加上一个树状数组就行。每次的模数不一样，所以需要预处理一下欧拉函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=5e5+10,maxp=2e7+10; int mod,n,m,phi[maxp],tot,prime[maxp/10],cnt,a[maxn]; inline int lowbit(int x)&#123;return x&amp;(-x);&#125; inline void update(int x,int y)&#123; for(;x&lt;=n;x+=lowbit(x))a[x]+=y; &#125; inline int query(int x)&#123; int ans=0; for(;x;x-=lowbit(x))ans+=a[x]; return ans; &#125; bool mark[maxp]; inline void pre(int n)&#123; phi[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(!mark[i])prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt and i*prime[j]&lt;=n;j++)&#123; mark[i*prime[j]]=1; if(!(i%prime[j]))&#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125; &#125; inline int fpow(int a,int b,int mod)&#123; int ans=1; bool ok=0; for(;b;b&gt;&gt;=1,a=a*a)&#123; if(a&gt;=mod)ok=1,a%=mod; if(b&amp;1)ans=ans*a; if(ans&gt;=mod)ok=1; ans%=mod; &#125; return ans+ok*mod; &#125; int dfs(int l,int r,int mod)&#123; int w=query(l); if(mod==1||w==1) return 1; if(l==r) return w&gt;=mod?w%mod+mod:w; return fpow(w,dfs(l+1,r,phi[mod]),mod); &#125; inline void work()&#123; n=read(),m=read(); int pre=0,zp=0; for(int i=1;i&lt;=n;i++)zp=read(),update(i,zp-pre),pre=zp; while(m--)&#123; if(read()==1)&#123; int l=read(),r=read(),k=read(); update(l,k),update(r+1,-k); &#125;else&#123; int l=read(),r=read(),p=read(); printf(&quot;%lld\\n&quot;,dfs(l,r,p)%p); &#125; &#125; &#125;&#125;signed main()&#123; star::pre(20000000); star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"扫描线","slug":"扫描线","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.481Z","comments":true,"path":"2022/04/30/扫描线/","permalink":"https://starcried.github.io/2022/04/30/%E6%89%AB%E6%8F%8F%E7%BA%BF/","excerpt":"","text":"我的第一篇博客就是扫描线。虽然那时候什么也不懂，也非常幼稚，甚至不知扫描线的原理是如何，只是一门心思地去做，就像面对未知的生活。 扫描线处理矩阵面积之和的问题，当然它们会有互相覆盖而不能直接加起来。 扫描线就是从下往上一次扫描&ldquo;线&rdquo;，然后用线将图分成多个区域，累加即可。用线段树记录横坐标此时扫描线处的长度。 用Xi表示第i条竖直的线（用来划分区间） 用line结构体表示线水平的线 P5490 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define R register using namespace std; typedef long long ll; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=1e6+10; struct Line{ ll l,r,h; int val; bool operator &lt; (const Line &amp;zp) const {return h&lt;zp.h;} }line[maxn&lt;&lt;1]; int n; ll X[maxn&lt;&lt;1]; struct SegmentTree { #define ls (ro&lt;&lt;1) #define rs (ro&lt;&lt;1|1) int l,r,sum; struct tree{ int l,r,sum; ll len; }e[maxn&lt;&lt;2]; inline void pushup(int ro) { if(e[ro].sum)e[ro].len=X[e[ro].r+1]-X[e[ro].l]; else e[ro].len=e[ls].len+e[rs].len; } void build(int ro,int l,int r) { e[ro].l=l,e[ro].r=r; if(l==r)return; int mid=l+r&gt;&gt;1; build(ls,l,mid); build(rs,mid+1,r); } void update(int ro,int l,int r,int val) { if(X[e[ro].r+1]&lt;=l or r&lt;=X[e[ro].l])return; if(l&lt;=X[e[ro].l] and X[e[ro].r+1]&lt;=r) { e[ro].sum+=val; pushup(ro); return; } update(ls,l,r,val); update(rs,l,r,val); pushup(ro); } #undef ls #undef rs }seg; int main() { n=read(); for(int i=1;i&lt;=n;i++) { ll x1=(ll)read(),y1=(ll)read(),x2=(ll)read(),y2=(ll)read(); line[(i&lt;&lt;1)-1]=(Line){x1,x2,y1,1}; line[i&lt;&lt;1]=(Line){x1,x2,y2,-1}; X[(i&lt;&lt;1)-1]=x1,X[i&lt;&lt;1]=x2; } n&lt;&lt;=1; sort(line+1,line+n+1); sort(X+1,X+n+1); int cnt=unique(X+1,X+n+1)-X-1; seg.build(1,1,cnt-1); ll ans=0; for(register int i=1;i&lt;n;i++) { seg.update(1,line[i].l,line[i].r,line[i].val); ans+=seg.e[1].len*(line[i+1].h-line[i].h); } printf(\"%lld\\n\",ans); return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"斐波那契数列相关","slug":"斐波那契数列相关","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T06:33:01.674Z","comments":true,"path":"2022/04/30/斐波那契数列相关/","permalink":"https://starcried.github.io/2022/04/30/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9B%B8%E5%85%B3/","excerpt":"","text":"斐波那契数列$F(0)&#x3D;F(1)&#x3D;1$ 或 $F(1)&#x3D;F(2)&#x3D;1$，$F(i)&#x3D;F(i-1)+F(i-2)$. 广义斐波那契数列在转移时有系数且首两项给定。 求法注意到斐波那契数列的转移为一个矩阵乘$$\\begin{bmatrix}F(i)&amp;F(i-1)\\end{bmatrix}\\begin{bmatrix}1&amp;1\\1&amp;0\\end{bmatrix}$$当然广义斐波那契数列的转移就是把转移矩阵的系数换了一下。 所以我们可以通过矩阵快速幂快速求得所求项数。 给出广义斐波那契数列的矩阵乘代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; int mod; struct mat&#123; int a[2][2]; inline void set()&#123; memset(a,0,sizeof a); &#125; inline void zero()&#123; set();a[0][0]=a[1][1]=1; &#125; inline int* operator [] (const int x)&#123;return a[x];&#125; inline const int* operator [] (const int x) const &#123;return a[x];&#125; inline mat operator * (const mat &amp;b)const&#123; mat ans; ans.set(); for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans[i][j]=(ans[i][j]+a[i][k]*b[k][j]%mod)%mod; return ans; &#125; &#125;now,pow; inline mat fpow(mat a,int b)&#123; mat ans; ans.zero(); for(;b;b&gt;&gt;=1,a=a*a)if(b&amp;1)ans=ans*a; return ans; &#125; inline void work()&#123; int p=read(),q=read(),a1=read(),a2=read(),n=read(); mod=read(); now[0][1]=a1,now[0][0]=a2,pow[0][0]=p,pow[1][0]=q,pow[0][1]=1; printf(&quot;%lld&quot;,(now*fpow(pow,n-1))[0][1]); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 性质斐波那契数具有很多神奇的性质，虽然有些不太常用 齐肯多夫定理：任何正整数可以表示为若干个不连续的斐波那契数之和。 于是我们可以引出来一个叫做斐波那契进制的东西。 简单来说，因为任何数都可以被若干个斐波那契数的和表示，我们就可以把这个数用01串表示。其中第i位表示是否含有$F[i]$。 更形式化地讲，从大到小枚举斐波那契数，每当$ F[i]$不小于当前数就将此位置为1并减去该$ F[i]$，根据定理最后一定会被减完，即被一个01串表示。 因为斐波那契数的增长速度很快，所以这个串并不会很长。 我们来看个毒瘤题： P6791 [SNOI2020] 取石子 对于这个LCA的毒瘤题本身我并不会没什么好说的，没有发现打表之外的解法 通过打表我们可以发现，设$a_i$表示还剩i颗石子时甲必胜此次至少要取的石子个数，那么 $a_i$ 为 $i$ 在斐波那契进制下的 lowbit。 所以这个题本身和斐波那契数就只有这么点关系 对于题本身不予讨论。我也不会证 斐波那契公约数P1306 我们需要证明$F[\\gcd(i,j)]&#x3D;\\gcd(F[i],F[j])$。 其中$F[0]&#x3D;F[1]&#x3D;1$。 引理：$\\gcd(F[i],F[i-1])&#x3D;1$ 证明：$$\\gcd(F[i],F[i-1])&#x3D;\\gcd(F[i]-F[i-1],F[i-1])&#x3D;\\gcd(F[i-1],F[i-2])&#x3D;\\dots&#x3D;\\gcd(F[2],F[1])&#x3D;1$$即$F[i]$与$F[i-1]$互质。 引理：$F[m+n]&#x3D;F[m-1]F[n]+F[m]F[n+1]$ 设$F[n]&#x3D;a,F[n+1]&#x3D;b$,向下递推发现由$a$和$b$表达的$F[i]$中其系数是斐波那契数。自己推推就知道了。 $F[\\gcd(i,j)]&#x3D;\\gcd(F[i],F[j])$ 证明： 不妨设$i&lt;j$，则有$$\\gcd(F[i],F[j])\\&#x3D;\\gcd(F[i],F[j-i-1]F[i]+F[j-i]F[i+1])\\&#x3D;\\gcd(F[i],F[j-i]F[i+1])\\&#x3D;\\gcd(F[i],F[j-i])$$即$$\\gcd(F[i],F[j])&#x3D;\\gcd(F[i],F[j\\mod i])$$递归求解，发现我们就是在对F的下标求gcd，也就是$$\\gcd(F[i],F[j])&#x3D;F[\\gcd(i,j)] \\ \\square$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int mod=1e8; struct mat&#123; int a[2][2]; mat()&#123; memset(a,0,sizeof a); &#125; inline void zero()&#123; a[0][0]=a[1][1]=1; &#125; inline int* operator [] (const int x)&#123;return a[x];&#125; inline const int* operator [] (const int x) const &#123;return a[x];&#125; inline friend mat operator * (const mat &amp;a,const mat &amp;b)&#123; mat ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans[i][j]=(ans[i][j]+a[i][k]*b[k][j]%mod)%mod; return ans; &#125; &#125;now,pow; int gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125; inline mat fpow(mat a,int b)&#123; mat ans; ans.zero(); for(;b;b&gt;&gt;=1,a=a*a)if(b&amp;1)ans=ans*a; return ans; &#125; inline void work()&#123; now[0][0]=now[0][1]=pow[0][0]=pow[0][1]=pow[1][0]=1; printf(&quot;%lld&quot;,(now*fpow(pow,gcd(read(),read())-1))[0][1]); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; $F[i-1]*F[i+2]-F[i]*F[i+1]&#x3D;(-1)^i$ 还是设$F[i]&#x3D;a,F[i+1]&#x3D;b$，然后推来推去，具体看@浅色调 的过程 对于P3986，这个结论可以用来快速解决 $aF[i]+bF[i+1]&#x3D;k$ 而不用exgcd。 即有通解 $x&#x3D;k*(-1)^iF[i-1],y&#x3D;k*(-1)^{i+1}F[i-2]$ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=100,mod=1e9+7; int N,f[maxn],ans; inline void work()&#123; int k=read(); f[1]=f[2]=1;ans=k-1; for(N=3;(f[N]=f[N-1]+f[N-2])&lt;k;N++); N--; for(int x,y,j=2;j&lt;=N;j++)&#123; int q=((j-1)&amp;1)?-1:1; x=k*q*f[j+3],y=-k*q*f[j+2]; if(x&lt;0)&#123; y-=((-x)/f[j+1]+1)*f[j]; if(y&gt;0)ans=(ans+(int)ceil(1.0*y/f[j]))%mod; &#125;else if(y&lt;0)&#123; x-=((-y)/f[j]+1)*f[j+1]; if(x&gt;0)ans=(ans+(int)ceil(1.0*x/f[j+1]))%mod; &#125; &#125; printf(&quot;%lld&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; PS: @浅色调的题解对N多算了一次，减掉即可。或者在第二遍 for 循环内直接判掉 break 也行。 UPD10.15 给定一个长为n的序列，可在其中填1，求使1任意两个都不相邻的方案数。 昨天看了一道叫做01矩阵的题目想到该问题，经询问 luogu 聚铑们得到答案。 首先，这玩意和斐波那契数有什么关系？ 考虑 DP，对于位置 $i$,设 $f[i][0],f[i][1]$ 为前 $i$ 个数填完、$i$ 填 $0$ 或 $1$ 的方案数，则有转移$$f[i][0]&#x3D;f[i-1][0]+f[i-1][1]\\f[i][1]&#x3D;f[i-1][0]$$设$g[i]$为到i的方案总数，则有$$g[i]&#x3D;f[i][0]+f[i][1]\\g[i]&#x3D;f[i-1][0]+f[i-1][1]+f[i-1][0]\\g[i]&#x3D;g[i-1]+g[i-2]$$和斐波那契数列的转移相同。 板子题 总结斐波那契数列性质很多。之后遇到新的我应该会补。 如果您凑巧看到了这里并知道一些相关题目请不吝赐教~","categories":[{"name":"题解","slug":"题解","permalink":"https://starcried.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"矩阵","slug":"矩阵","permalink":"https://starcried.github.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"数学","slug":"数学","permalink":"https://starcried.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"斜堆-思维，性质","slug":"斜堆-思维，性质","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.482Z","comments":true,"path":"2022/04/30/斜堆-思维，性质/","permalink":"https://starcried.github.io/2022/04/30/%E6%96%9C%E5%A0%86-%E6%80%9D%E7%BB%B4%EF%BC%8C%E6%80%A7%E8%B4%A8/","excerpt":"","text":"斜堆斜堆是个很有趣的东西。而且它有一些很有意思的性质。 斜堆的大概就是每次往堆里面插入一个元素的操作非常“有趣”。插入的节点从根节点开始。如果插入的元素值比所在根小，它会将根“挤下去”，即替代原先的根的位置，将原先的根连到它的左子树上。如果所在根节点为空，它直接插入到此节点上。如果插入的元素比根大，那么它就会先交换所在根的两个子树，然后再递归到原先根的左子树进行插入，直到它比所在根小或者所在根为空。 我们知道根是一个二叉树。根据斜堆的定义，我们可以大概推测它的几个明显的性质： 斜堆是一个小根堆 斜堆上的任意一个节点有可能是一个完全二叉树或一个不完全二叉树，当且仅当它的左子树大于它的右子树。 根据以上性质，我们可以得出“斜堆上任意一个节点若有右子树必定有左子树”的结论。证明显然。 然后，我们就会发现几个不得了的性质： 对于一个斜堆，它最后插入的节点一定在它的最左边的链上。 若有一个节点没有右子树，并且它的左子节点拥有左节点，那么这个节点必定是最后插入的节点。 对于没有符合性质4的节点的斜堆，它最后插入的节点一定是最左边链的最深端点。 后三个性质可以轻易得到斜堆最后插入的节点位置，这就是我们解这道题的关键了：倒着推，每次删除最后插入的节点，将为了插入该节点而交换子树的节点交换回来。每删除一个节点后得到的新的堆就可以再次用相同的方法做了，直到堆中只剩一个节点或者堆中没有节点（看心情）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn=52;inline int read()&#123; int x=0;bool w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;int n,ans[maxn],root;int son[maxn][2],fa[maxn],node[maxn];int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; int x=read(); son[x%100][x/100]=i; fa[i]=x%100; &#125; root=0; int tot=0; while(son[root][0])&#123; int now=root; while(son[now][0])&#123; if(!son[now][1] and son[son[now][0]][0]) break; now=son[now][0]; &#125; if(now!=root)&#123; ans[++tot]=now; now=fa[now]; fa[son[now][0]]=0; son[now][0]=son[son[now][0]][0]; if(son[now][0]) fa[son[now][0]]=now; while(now!=root)&#123; swap(son[now][0],son[now][1]); now=fa[now]; &#125; swap(son[root][0],son[root][1]); &#125;else&#123; ans[++tot]=now; root=son[root][0]; fa[root]=0; &#125; &#125; ans[++tot]=root; for(int i=tot;i&gt;0;i--)printf(&quot;%d &quot;,ans[i]); return 0;&#125;/*6100 0 2 102 4 104*/ 当然也可以用dfs求解。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"斜率优化[非公开][草稿]","slug":"斜率优化[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.483Z","comments":true,"path":"2022/04/30/斜率优化[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"&lt;-点我进入大佬博客 &nbsp; 斜率优化，适用于一些dp方程为类似 f[i]=min(a[i]&lowast;b[j]+c[j]+d[i]) ,其中b单调递增 的问题。通过大佬的博客可以得证有k&gt;j时，k的决策是优于j的，即斜率式 a[i]&lowast;b[j]+c[j]+d[i]&gt;=a[i]&lowast;b[k]+c[k]+d[i]，j&lt;k &nbsp; 最后可以得到 slope(i,j)=(c[k]&minus;c[j]) / (b[k]&minus;b[j]) slope为i-j斜率。 于是发现这个东西符合单调数列的性质：（直接复制） &minus;a[i]&gt;=slope(q[l],q[l+1])&minus;a[i]&gt;=slope(q[l],q[l+1])。因为q[l]q[l]在q[l+1]q[l+1]之前加入，那么显然这个式子就表示q[l]q[l]决策不如q[l+1]q[l+1]优，我们可以将队首pop掉。 slope(q[r&minus;1],q[r])&gt;slope(q[r],i)slope(q[r&minus;1],q[r])&gt;slope(q[r],i)。假设我们在后面存在一个a[t]a[t]使得&minus;a[t]&gt;=slope(q[r&minus;1],q[r])&minus;a[t]&gt;=slope(q[r&minus;1],q[r])那么等到pop了q[r&minus;1]q[r&minus;1]之后，&minus;a[t]&minus;a[t]一定也会&gt;=slope(q[r],i)&gt;=slope(q[r],i)，q[r]q[r]也会被pop。所以说q[r]q[r]实际上是无用的，我们可以直接将它pop掉。 然后我们就可以得到代码： &nbsp; 但是题目中绝对不会只给你个abcd让你直接套板子的XD 最终可以设为只包含i,j的式子进行dp。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"最优比率生成树[非公开][草稿]","slug":"最优比率生成树[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.484Z","comments":true,"path":"2022/04/30/最优比率生成树[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E6%9C%80%E4%BC%98%E6%AF%94%E7%8E%87%E7%94%9F%E6%88%90%E6%A0%91[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"就是在树上的0/1分数规划啦~ 我们只需要每次生成最小生成树即可。不过因为这个所谓权值不是简单的距离最小，我们用prim算法搞它。 POJ2728 花费比最大问题。 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"最大权闭合子图","slug":"最大权闭合子图","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.485Z","comments":true,"path":"2022/04/30/最大权闭合子图/","permalink":"https://starcried.github.io/2022/04/30/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/","excerpt":"","text":"最大权闭合子图闭合子图定义有向图的一个闭合子图是该有向图的一个点集，其中这个点集中的所有点的出边连向的还是点集中的点。 最大权闭合子图给有向图的点加一个点权，能得到的点权最大的闭合子图。 网络流模型 将所有正点权的点的点权全部加入答案。接下来我们将原来正点权的点变成负点权。现在图上全是负点，我们需要尽量选最少点权使图符合条件。 设超级源点和超级汇点。 将超级源向所有原来是正点权的点连边，流量为其点权绝对值。 将所有负点权的点向超级汇连边，流量为其点权绝对值。 将所有原图上的边加入，流量为无限。 接下来跑最小割。可以证明此时最小割就是使图合法的最小代价。感性理解一下，将源点与汇点割开的最小割，因为原图的边的流量是无限，只能将超级源汇连出去的边割开。相当于就是不选某些正点或选择某些汇点。这也就保证了后面的点选择时前面的点一定会被选。 最后用前面的答案减去最小割即可。 如果需要构造方案，请看下例题。 P2762 太空飞行计划问题题意给你两个集合，一个集合所有元素有正点权，另一个有负点权，前一个集合的每一个元素有若干后一个集合的必选后继，要求若选择该元素后继必选，求能得到的最大点权和。 思路最大权闭合子图模板。将前一个集合的所有元素向其所有后继连边，就变成了一个有向图，然后用上述方法建模即可。 关于读入我使用了快读来读入换行符。其代码如下： 1234567inline int read()&#123; int w=0,x=0;static char c(0); while(!isdigit(c) and c!=&#x27;\\n&#x27;) w|=c==&#x27;-&#x27;,c=getchar(); if(c==&#x27;\\n&#x27;)return c=getchar(),INF; while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125; 其中，利用了 static 来保证之前读入的字符能够重新判断。在这个函数中，如果读到换行符将会返回 INF。 关于输出方案在这道题中，思考网络流建模方式即可得出，如果在最后一次 bfs 中一个正点权的点可以到达，说明其没有被取消选择，即被选择了；如果一个负点权的点可以到达，说明其被选择了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;namespace star&#123; const int maxn=105,maxm=2600,s=103,t=104,INF=0x3f3f3f3f; inline int read()&#123; int w=0,x=0;static char c(0); while(!isdigit(c) and c!=&#x27;\\n&#x27;) w|=c==&#x27;-&#x27;,c=getchar(); if(c==&#x27;\\n&#x27;)return c=getchar(),INF; while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x; &#125; int n,m,val[maxn],ans; int ecnt=1,head[maxn],cur[maxn],to[maxm&lt;&lt;1],nxt[maxm&lt;&lt;1],w[maxm&lt;&lt;1]; inline void addedge(int a,int b,int c)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt,w[ecnt]=c; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt,w[ecnt]=0; &#125; int dep[maxn]; inline bool bfs()&#123; memset(dep,-1,sizeof dep); static int q[maxn]; int hd=0,tl=1; q[tl]=s,dep[s]=0; while(hd&lt;tl)&#123; int x=q[++hd]; for(int u,i=head[x];i;i=nxt[i]) if(dep[u=to[i]]==-1 and w[i]) dep[u]=dep[x]+1,q[++tl]=u; &#125; return dep[t]!=-1; &#125; int dfs(int x,int flow)&#123; if(x==t)return flow; int used=0,u; for(int&amp; i=cur[x];i;i=nxt[i]) if(dep[u=to[i]]==dep[x]+1 and w[i])&#123; int v=dfs(u,min(flow-used,w[i])); used+=v,w[i]-=v,w[i^1]+=v; if(used==flow) break; &#125; return used; &#125; inline int dinic()&#123; int ans=0; while(bfs()) memcpy(cur,head,sizeof cur),ans+=dfs(s,INF); return ans; &#125; inline void work()&#123; m=read(),n=read();read(); for(int v,i=1;i&lt;=m;i++)&#123; addedge(s,i,v=read());ans+=v; while((v=read())!=INF) addedge(i,v+m,INF); &#125; for(int i=1;i&lt;=n;i++) addedge(i+m,t,read()); ans-=dinic(); for(int i=1;i&lt;=m;i++) if(dep[i]!=-1) printf(&quot;%d &quot;,i);puts(&quot;&quot;); for(int i=1;i&lt;=n;i++) if(dep[m+i]!=-1) printf(&quot;%d &quot;,i); printf(&quot;\\n%d\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; CF103E Buying Sets题意有一个大小为 n 的全集，每个元素是一个数，有 n 个子集。题目保证任意 k 个子集的并的大小 ⩾ k。 每个子集有一个可正可负的权值，你需要选出一些子集使得这些子集并的大小等于子集个数，且所选子集的权值和最小。可以为空集。 思路发现如果没有 子集并的大小等于子集个数 的限制，将边权取负就是最大权闭合子图的模板。考虑怎么满足这个限制。 我们把每个节点的点权加上一个巨大的偏移量 $\\Delta$ 即可。 原因是，如果跑最大流时要多选一个点的话，代价一定会变得很大。因为题目保证 任意 k 个子集的并的大小 ⩾ k，而且可以选空集，所以我们可以这么干。 早期代码","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"最大流最小割——bzoj1001狼抓兔子，洛谷P2598","slug":"最大流最小割——bzoj1001狼抓兔子，洛谷P2598","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.485Z","comments":true,"path":"2022/04/30/最大流最小割——bzoj1001狼抓兔子，洛谷P2598/","permalink":"https://starcried.github.io/2022/04/30/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E2%80%94%E2%80%94bzoj1001%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%EF%BC%8C%E6%B4%9B%E8%B0%B7P2598/","excerpt":"","text":"前置知识 平面图 平面图就是平面上任意边都不相交的图。（自己瞎画的不算XD） 对偶图 &nbsp; &nbsp;比如说这个图，我们发现平面图肯定会把平面分成不同的区域（感觉像拓扑图），并把这些区域当做每个点（不被包围的区域独自成点，如本图4*），给相邻的区域连上边，就转化成了一个对偶图（图中红色） 割 网络流的图中有两个点：原点和汇点。割就是删去的一些边使原点和汇点无法连接（不太严谨） 看题！bzoj1001 &nbsp; &nbsp;既然有了原点和汇点，那么就不能简单的把外部看做一个点了，我们把外部分成两个点&mdash;&mdash;超级原点和超级汇点！ &nbsp; &nbsp;然后像上面一样建边，求对偶图的最短路就行了！！！ 你问我如何判断对偶图的点之间割了哪些边？ emmm这就是它恶心的地方了&mdash;&mdash;建图并不容易。不过，它给边的方式还是有点人性的。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cstring&gt; #include&lt;utility&gt; #include&lt;queue&gt; #include&lt;functional&gt; #include&lt;vector&gt; using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c) )x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=3000000; typedef pair&lt;int,int&gt; pii; int n,m,node[1210][1210][2]; int ecnt,t[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],head[maxn&lt;&lt;1],val[maxn&lt;&lt;1]; inline void addedge(int from,int to,int dis) { t[++ecnt]=to;nxt[ecnt]=head[from];head[from]=ecnt;val[ecnt]=dis; t[++ecnt]=from;nxt[ecnt]=head[to];head[to]=ecnt;val[ecnt]=dis; } int dis[maxn]; bool vis[maxn]; inline void dijkstra(int start,int end) { memset(dis,&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;0x3f3f3f3f&lt;/span&gt;,&lt;span style=&quot;color: #0000ff;&quot;&gt;sizeof&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; dis); priority_queue&lt;/span&gt;&amp;lt;pii,vector&amp;lt;pii &amp;gt;,greater&amp;lt;pii &amp;gt; &amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt; q; q.push(make_pair(&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;,start)),dis[start]=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;while&lt;/span&gt;(!&lt;span style=&quot;color: #000000;&quot;&gt;q.empty()) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; u=&lt;span style=&quot;color: #000000;&quot;&gt;q.top().second;q.pop(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(vis[u])&lt;span style=&quot;color: #0000ff;&quot;&gt;continue&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; vis[u]&lt;/span&gt;=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i=head[u];i;i=&lt;span style=&quot;color: #000000;&quot;&gt;nxt[i]) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; v=t[i],w=&lt;span style=&quot;color: #000000;&quot;&gt;val[i]; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(dis[v]&amp;gt;=dis[u]+&lt;span style=&quot;color: #000000;&quot;&gt;w) &#123; dis[v]&lt;/span&gt;=dis[u]+&lt;span style=&quot;color: #000000;&quot;&gt;w; q.push(make_pair(dis[v],v)); &#125; &#125; &#125; }int main(){ int v&#x3D;1; n&#x3D;read()-1,m&#x3D;read()-1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;m;j++) for(int k&#x3D;0;k&lt;2;k++) node[i][j][k]&#x3D;v++; int start&#x3D;v++,end&#x3D;v; for(int j&#x3D;1;j&lt;&#x3D;m;j++)addedge(start,node[1][j][0],read()); for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) for(int j&#x3D;1;j&lt;&#x3D;m;j++) addedge(node[i][j][1],node[i+1][j][0],read()); for(int j&#x3D;1;j&lt;&#x3D;m;j++)addedge(end,node[n][j][1],read()); &#x2F;横行&#x2F; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;m+1;j++) if(j&#x3D;&#x3D;1)addedge(end,node[i][j][1],read()); else if(j&#x3D;&#x3D;m+1)addedge(start,node[i][j-1][0],read()); else addedge(node[i][j-1][0],node[i][j][1],read()); &#x2F;纵行&#x2F; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;m;j++) addedge(node[i][j][0],node[i][j][1],read()); &#x2F;斜行&#x2F; dijkstra(start,end); printf(“%d\\n“,dis[end]); return 0;} 好了，以上只是针对bzoj1001的问题的解法。实际上，这个问题还有一些通用的解法（只不过出题人不想让大家用加强了数据） 不过上一道题我们也可以用下面的方式求出网络的最小割。 不过我们换一题XD P2598狼和羊的故事 （反正狼就是nb） 通过读题，我们发现，这个orez想圈养狼真是了不起（姜戎都不敢这么干） 最大流最小割定理：网络的最大流等于最小割证明也比较简单（但我不会严谨的），感性理解一下，最大流一定有一些边是满的，我们把这些边割了它就流不成了。对于其他的边，要么不是必经之路，要么边权不比同一条流上的最大流的边小，所以~~得证~~那么这道题的话其他前辈已经讲得很好了，即求法就是1. 将所有狼连到原点，边权INF2. 将所有羊连到汇点，边权INF3. 将所有点的四周加边，边权为1这是一个对偶图的思想，相当于组成了一个网络，在这个网络中，只要点与点之间有边相连就相当于之间没有栅栏，所以一开始是全部连接的。我们要做的，就是砌栅栏把一些边断掉，使狼和羊分离。因为所有狼和所有羊都连在原点和汇点，这就相当于求最小割了。（不知道讲清楚没有） 前面两个大家应该都清楚，边权INF相当于没有影响只是把所有狼/羊连在一起罢了。第三步就是连边：因为修一个栅栏需要1，所以边权为1，简直和对偶图一模一样（本来就是一个思想）同样的，这里的难度就在于建边，建完求最大流就行了。注意数组的大小。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cctype&gt; #include&lt;utility&gt; #include&lt;queue&gt; using namespace std; inline int read() { int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } namespace star { const int maxn=100005,INF=0x3f3f3f3f; int n,m; int mapp[105][105]; int ecnt=1,head[maxn],t[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],val[maxn&lt;&lt;1]; inline void addedge(int from,int to, int dis) { t[++ecnt]=to;val[ecnt]=dis;nxt[ecnt]=head[from];head[from]=ecnt; t[++ecnt]=from;val[ecnt]=0;nxt[ecnt]=head[to];head[to]=ecnt; } int fx[]={0,1,0,-1},fy[]={1,0,-1,0}; int cnt; int dep[maxn],start,end,cur[maxn]; inline bool BFS() { queue&lt;int&gt; q; for(int i=1;i&lt;=cnt;i++)dep[i]=-1,cur[i]=head[i]; dep[start]=0; q.push(start); while(!q.empty()) { int u=q.front();q.pop(); for(int i=head[u];i;i=nxt[i]) if(val[i] and dep[t[i]]==-1) dep[t[i]]=dep[u]+1,q.push(t[i]); } if(dep[end]==-1)return 0; return 1; } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; DFS(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; x,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; flow) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(x==end)&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; flow; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; used=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i=cur[x];i;i=&lt;span style=&quot;color: #000000;&quot;&gt;nxt[i]) &#123; cur[x]&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;i; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; u=&lt;span style=&quot;color: #000000;&quot;&gt;t[i]; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(val[i] and dep[u]==dep[x]+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; w=DFS(u,min(val[i],flow-&lt;span style=&quot;color: #000000;&quot;&gt;used)); used&lt;/span&gt;+=&lt;span style=&quot;color: #000000;&quot;&gt;w; val[i]&lt;/span&gt;-=&lt;span style=&quot;color: #000000;&quot;&gt;w; val[i&lt;/span&gt;^&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;]+=&lt;span style=&quot;color: #000000;&quot;&gt;w; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(used==flow)&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; flow; &#125; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(!used)dep[x]=-&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; used; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; build() &#123; n&lt;/span&gt;=read(),m=&lt;span style=&quot;color: #000000;&quot;&gt;read(); cnt&lt;/span&gt;=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span style=&quot;color: #000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; j=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;j&amp;lt;=m;j++&lt;span style=&quot;color: #000000;&quot;&gt;) mapp[i][j]&lt;/span&gt;=++&lt;span style=&quot;color: #000000;&quot;&gt;cnt; start&lt;/span&gt;=++cnt,end=++&lt;span style=&quot;color: #000000;&quot;&gt;cnt; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; zp,i=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span style=&quot;color: #000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; j=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;j&amp;lt;=m;j++&lt;span style=&quot;color: #000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;((zp=read())==&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;)addedge(start,mapp[i][j],INF); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(zp==&lt;span style=&quot;color: #800080;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;)addedge(mapp[i][j],end,INF); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span style=&quot;color: #000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; j=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;j&amp;lt;=m;j++&lt;span style=&quot;color: #000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; k=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;;k&amp;lt;&lt;span style=&quot;color: #800080;&quot;&gt;4&lt;/span&gt;;k++&lt;span style=&quot;color: #000000;&quot;&gt;) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; xx=i+fx[k],yy=j+&lt;span style=&quot;color: #000000;&quot;&gt;fy[k]; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(xx&amp;lt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt; or xx&amp;gt;n or yy&amp;lt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt; or yy&amp;gt;m)&lt;span style=&quot;color: #0000ff;&quot;&gt;continue&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; addedge(mapp[i][j],mapp[xx][yy],&lt;/span&gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); &#125; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; work() &#123; build(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; ans=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;while&lt;/span&gt;(BFS())ans+=&lt;span style=&quot;color: #000000;&quot;&gt;DFS(start,INF); printf(&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;%d\\n&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,ans); &#125; }int main(){ star::work(); return 0;} &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"最小覆盖问题-POJ3041-P1129","slug":"最小覆盖问题-POJ3041-P1129","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.486Z","comments":true,"path":"2022/04/30/最小覆盖问题-POJ3041-P1129/","permalink":"https://starcried.github.io/2022/04/30/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-POJ3041-P1129/","excerpt":"","text":"POJ3041这道题正解对于像我这种蒟蒻来说比较难以想到。我们发现每次覆盖的只是一条线上的所有点。那么我们可以把它想象成一个二分图，两个集合分别是横轴和纵轴。想一想，这实际上是不是就是x轴轴和纵轴的最大匹配？于是这就变成了一个板子匈牙利算法题目。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;ctype.h&gt;#define R registerusing namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;const int maxn=505,maxm=10005;int n,m;int mapp[maxn][maxn];bool vis[maxn];int match[maxn];bool find(int x)&#123; for(R int i=1;i&lt;=n;i++) if(mapp[x][i] and vis[i]==0) &#123; vis[i]=1; if(match[i]==0 || find(match[i])) &#123; match[i]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; n=read(),m=read(); for(R int i=1;i&lt;=m;i++)mapp[read()][read()]=1; int ans=0; for(R int i=1;i&lt;=n;i++) &#123; memset(vis,0,sizeof vis); if(find(i))ans++; &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 洛谷P1129这道题也差不多了，$O(n^2)$就能过。也是求x和y轴的最大匹配。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;ctype.h&gt;#define R registerusing namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;const int maxn=505,maxm=10005;int n,m;int mapp[maxn][maxn];bool vis[maxn];int match[maxn];bool find(int x)&#123; for(R int i=1;i&lt;=n;i++) if(mapp[x][i] and vis[i]==0) &#123; vis[i]=1; if(match[i]==0 || find(match[i])) &#123; match[i]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; int t=read();k: while(t--) &#123; memset(mapp,0,sizeof mapp); memset(match,0,sizeof match); n=read(); for(R int i=1;i&lt;=n;i++) for(R int j=1;j&lt;=n;j++)mapp[i][j]=read(); int ans=0; for(R int i=1;i&lt;=n;i++) &#123; memset(vis,0,sizeof vis); if(!find(i))&#123; printf(&quot;No\\n&quot;); goto k; &#125; &#125; printf(&quot;Yes\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"最大网络流dinic","slug":"最大网络流dinic","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.486Z","comments":true,"path":"2022/04/30/最大网络流dinic/","permalink":"https://starcried.github.io/2022/04/30/%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E6%B5%81dinic/","excerpt":"","text":"初始化flow（最大流量）为INF（极大值），建边（正向弧和反向弧） bfs寻找增广路看看有没有路，顺便进行深度标号。如果没有路直接结束输出flow。 如果有，我们按照深度dfs。dfs时注意在给正向弧减权时给反向弧加权。 ans+=flow,重复2到4步骤，直到无路可走。 输出结束~ 以上就是网络流全部内容（误 概念什么的就不讲啦~ 下面来仔细分析板子代码。 初始化ans=0，构建边 dinic中心： while(BFS()) ans+=DFS(start,INF); BFS: inline bool BFS() { memset(dep,-1,sizeof dep); //每次BFS更新深度，-1代表未被更新或者无路径访问 dep[s]=0; //起点的深度为0 q.push(s); while(!q.empty()) { int u=q.front();q.pop(); for(R int i=head[u];i;i=e[i].nxt) if(e[i].dis and dep[e[i].to]==-1)//一定有流并且未被访问 dep[e[i].to]=dep[u]+1,q.push(e[i].to); } if(dep[end]==-1)return 0;//如果end的深度为-1，无路径到达，此时最大流 return 1; } DFS ll DFS(int x,ll flow) { if(x==end) return flow;//到终点就返回流 ll used=0;//优化，记录已用过的流 for(R int i=head[x];i;i=e[i].nxt) { int u=e[i].to; if(e[i].dis and dep[u]==dep[x]+1) { long long w=DFS(u,min(e[i].dis,flow-used));//求出最大流 used+=w; e[i].dis-=w;e[i^1].dis+=w;//i^1为相反方向的边，对应加权 if(used==flow)return flow; } } if(!used)dep[x]=-1;//无流可走，说明此点已经无意义了 return used;//最大流 } &nbsp; P3376 【模板】网络最大流 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define R register #define INF 1&lt;&lt;30 using namespace std; template &lt;typename T&gt; inline T read() { T x=0;int w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } namespace ysr { typedef long long ll; const int maxn=100000; struct Edge{ int to,nxt; ll dis; }e[200000]; int cur[maxn],head[maxn],ecnt=1;//这里记为-1的原因时便于访问正向弧和反向弧 int n,m,s,end,dep[maxn]; inline void addedge(int from,int to,ll dis){ e[++ecnt].to=to,e[ecnt].nxt=head[from],e[ecnt].dis=dis,head[from]=ecnt; } inline void add(int from,int to,ll dis){ addedge(from,to,dis);addedge(to,from,0); } ll DFS(int x,ll flow) { if(x==end) return flow; ll used=0; for(R int i=head[x];i;i=e[i].nxt) { int u=e[i].to; if(e[i].dis and dep[u]==dep[x]+1) { long long w=DFS(u,min(e[i].dis,flow-used)); used+=w; e[i].dis-=w;e[i^1].dis+=w; if(used==flow)return flow; } } if(!used)dep[x]=-1; return used; } queue&lt;int&gt;q; inline bool BFS() { memset(dep,-1,sizeof dep); dep[s]=0; q.push(s); while(!q.empty()) { int u=q.front();q.pop(); for(R int i=head[u];i;i=e[i].nxt) if(e[i].dis and dep[e[i].to]==-1) dep[e[i].to]=dep[u]+1,q.push(e[i].to); } if(dep[end]==-1)return 0; return 1; } inline void work() { n=read&lt;int&gt;(),m=read&lt;int&gt;(),s=read&lt;int&gt;(),end=read&lt;int&gt;(); ll ans=0; int a,b; ll c; for(R int i=0;i&lt;m;i++)a=read&lt;int&gt;(),b=read&lt;int&gt;(),c=read&lt;ll&gt;(),add(a,b,c); while(BFS()) ans+=DFS(s,INF); printf(\"%lld\\n\",ans); } } signed main() { ysr::work(); return 0; } 大家一定已经发现我定义了一个cur数组不知道但什么的。这其实就是【当前弧优化】的数组，虽然我在上面没有使用。 这也不是什么高深的玩意。我们证明，如果一个点在之前的dfs中已经把一些边考虑过了，由于在当前和以后的流的dfs中这些边都是增广过的，也就是再也没法做出贡献了，那么我们用一个数组cur记录一下考虑到哪里了然后下一侧dfs时接着上次的就行了。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define R register #define INF 1&lt;&lt;30 using namespace std; template &lt;typename T&gt; inline T read() { T x=0;int w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } namespace ysr { typedef long long ll; const int maxn=100000; struct Edge{ int to,nxt; ll dis; }e[200000]; int cur[maxn],head[maxn],ecnt=1;//这里记为-1的原因时便于访问正向弧和反向弧 int n,m,s,end,dep[maxn]; inline void addedge(int from,int to,ll dis){ e[++ecnt].to=to,e[ecnt].nxt=head[from],e[ecnt].dis=dis,head[from]=ecnt; } inline void add(int from,int to,ll dis){ addedge(from,to,dis);addedge(to,from,0); } ll DFS(int x,ll flow) { if(x==end) return flow; ll used=0; for(R int i=cur[x];i;i=e[i].nxt) { cur[x]=i; int u=e[i].to; if(e[i].dis and dep[u]==dep[x]+1) { long long w=DFS(u,min(e[i].dis,flow-used)); used+=w; e[i].dis-=w;e[i^1].dis+=w; if(used==flow)return flow; } } if(!used)dep[x]=-1; return used; } queue&lt;int&gt;q; inline bool BFS() { for(R int i=0;i&lt;=n;i++)cur[i]=head[i],dep[i]=-1; dep[s]=0; q.push(s); while(!q.empty()) { int u=q.front();q.pop(); for(R int i=head[u];i;i=e[i].nxt) if(e[i].dis and dep[e[i].to]==-1) dep[e[i].to]=dep[u]+1,q.push(e[i].to); } if(dep[end]==-1)return 0; return 1; } inline void work() { n=read&lt;int&gt;(),m=read&lt;int&gt;(),s=read&lt;int&gt;(),end=read&lt;int&gt;(); ll ans=0; int a,b; ll c; for(R int i=0;i&lt;m;i++)a=read&lt;int&gt;(),b=read&lt;int&gt;(),c=read&lt;ll&gt;(),add(a,b,c); while(BFS()) ans+=DFS(s,INF); printf(\"%lld\\n\",ans); } } signed main() { ysr::work(); return 0; } 还是模板 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"期望长度P1365,CF235B,P1654","slug":"期望长度P1365,CF235B,P1654","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.487Z","comments":true,"path":"2022/04/30/期望长度P1365,CF235B,P1654/","permalink":"https://starcried.github.io/2022/04/30/%E6%9C%9F%E6%9C%9B%E9%95%BF%E5%BA%A6P1365,CF235B,P1654/","excerpt":"","text":"期望长度定义这里期望长度表示一段序列连续长度的期望。具体来说，对于一段序列，每个点都有一个概率连续和断开。求所有连续序列和的期望。 当然，对于以上期望长度的定义，我们只需要求出每个点存在的期望的和即可。但是题目永远不会这么简单。 Osu! Osu!是一个音乐游戏，玩家需要对音符在恰当时候进行敲击来通关。一次到位的敲击为o，不到位的为x。一段连续到位的敲击，即combo次数为这段序列的长度。 我们接下来讨论的三个题都和这个游戏有关。 level1 一段Osu!序列为一串字符，包括’o’,’x’,’?’。其中’o’,’x’的定义如上，’?’表示此位置有一半的几率为’o’。游戏得分为所有combo次数平方的和。求得分的期望。 也就是我们要求所有序列长度平方的期望和。 期望期望具有线性性，但不具有积性。这意味着我们无法对求得的期望长度直接平方来得到答案。 并且请注意一点，若一个值的期望为0，并不意味着它的平方的期望为0。这可以帮助我们理解期望的线性性。 期望的平方在大多数情况下并没有什么实际意义。 但是，期望具有线性性。 考虑我们的答案，实际上就是长度平方的期望。考虑往后的转移。（设$f1$表示当前期望长度，$f2$表示答案，即长度平方期望的和） 根据公式$(len+1)^2&#x3D;len^2+2*len+1$若后一位$i$为’o’,则后一位$i$的期望值分别为 $f1_i&#x3D;f1_{i-1}+1$ $f2_i&#x3D;f2_{i-1}+2*f1_{i-1}+1$ 即此位$f2$的值其实是可以从前一位线性转移来的。所谓线性，就是其幂为1。 同样，考虑第$i$位为’x’的情况，$f1&#x3D;0$,$f2$直接继承前面的答案。 然后我们就可以得到’?’的情况：上述两种情况和除以2. $f1_i&#x3D;\\frac{f1_{i-1}+1}2$ $f2_i&#x3D;\\frac{2f2_{i-1}+2f1_{i-1}+1}{2}$ 于是我们就能完成P1365 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; int n; double f,len,p; inline void work()&#123; n=read(); char c=getchar(); while(c!=&#x27;o&#x27; and c!=&#x27;?&#x27; and c!=&#x27;x&#x27;)c=getchar(); while(n--)&#123; if(c==&#x27;o&#x27;)f=(f+2*len+1),len=len+1; else if(c==&#x27;?&#x27;)f=(2*(f+len)+1)/2,len=(len+1)/2; else len=0; &#125; printf(&quot;%.4lf&quot;,f); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; level2 我们发现，其实对于概率任意的情况也可以推出来。上题三种字符其实就是对应概率为1,0.5,0的三种情况。 设$p$为该点为’o’的概率，则有: $f2_i&#x3D;f2_{i-1}+p*(2*f1_{i-1}+1)$ $f1_i&#x3D;p*(f1_{i-1}+1)$ 所以上题的代码的核心部分等同于： 123456while(n--)&#123; p=c==&#x27;o&#x27;?1.0:c==&#x27;?&#x27;?0.5:0.0; f=f+p*(2*len+1); len=p*(len+1); c=getchar();&#125; 于是我们可以完成CF235B 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; int n; double f,len,p; inline void work()&#123; n=read(); while(n--)&#123; scanf(&quot;%lf&quot;,&amp;p); f=(f-len*len+(len+1)*(len+1))*p+f*(1-p); len=p*(len+1); &#125; printf(&quot;%.8lf&quot;,f); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; level3 我们已经完成了对于长度平方的期望和的问题。那么我们就可以解决新的问题：对于答案为所有combo长度立方的和的期望我们怎么求解呢？ 根据期望的线性性，我们再维护一个平方的期望即可。 根据公式$(len+1)^3&#x3D;len^3+3len^2+3len+1$，我们可以得到以下转移：$$f3_i&#x3D;f3_{i-1}+p*(3*(f2_{i-1}+f1_{i-1})+1)\\ f2_i&#x3D;p*(f2_{i-1}+2f1_{i-1}+1)\\ f1_i&#x3D;p(f1_{i-1}+1);$$ 注意！我承认我的变量名的定义有亿点点毒瘤，因为读者可以清楚地发现在上一题中$f2$的转移为$f2_i&#x3D;f2_{i-1}+p*(2*f1_{i-1}+1)$而非当前转移。实际上在定义$f2$时我的定义为答案而非二次项的期望，根据期望的线性性，答案是可以继承上一次的答案进行转移的，也就是对于’x’的情况继承$f2$而非$0$的原因。 在此level中我对$f2$重新定义为长度二次幂的期望。希望不要因为我的毒瘤误导大家。 相同的，我对$f3$的定义为答案，因此需要继承之前的答案。 于是我们就完成了P1654 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;using namespace std;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; int n; double f1,f2,f3; inline void work()&#123; n=read(); double p; while(n--)&#123; scanf(&quot;%lf&quot;,&amp;p); f3=f3+p*(3*(f2+f1)+1); f2=p*(f2+2*f1+1); f1=p*(f1+1); &#125; printf(&quot;%.1lf&quot;,f3); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; 总结期望好神奇。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"最小路径覆盖","slug":"最小路径覆盖","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.487Z","comments":true,"path":"2022/04/30/最小路径覆盖/","permalink":"https://starcried.github.io/2022/04/30/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/","excerpt":"","text":"最小路径覆盖路径覆盖路径覆盖指一个路径的集合中所有路径点集的并集为原图点集。最小路径覆盖使路径集合大小最小。 路径覆盖分为可否重复选点两种。可重复选点在建模中加大流量即可。 网络流模型 建超级源 $S$ 和超级汇 $T$，将每个点拆点。 将 $S$ 向所有点 $i$ 连边，将所有点 $i’$ 向 $T$ 连边。 对于原图边集，每一条边 $u$ 向 $v’$ 连边。 选点不重的最小路径覆盖问题，上述所有边流量为 1，答案为点数减去最小割。 考虑对于这个模型建出来的图求出的最小割是什么。它实际上是最大的可以合并的路径条数。因为每合并两条路径相当于总路径数就减少了，所以有最小路径覆盖等于点数减最大匹配。 其中最大匹配就是我们刚才的模型。可以发现，我们实际上就是建了一个二分图在求最大匹配。 P2764 最小路径覆盖问题题意如上，要求构造方案。 我的构造方式如下：利用并查集，对于每条道路的端点，若这条边被选择了就将这两条边加入一个并查集，每个并查集代表一条路径。最后从每个路径的起点进行一遍搜索即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=305,maxm=6305,S=303,T=304,INF=0x3f3f3f3f; int n,m; int ecnt=1,head[maxn],cur[maxn],to[maxm&lt;&lt;1],nxt[maxm&lt;&lt;1],w[maxm&lt;&lt;1]; inline void addedge(int a,int b,int c)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt,w[ecnt]=c; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt,w[ecnt]=0; &#125; int dep[maxn]; inline bool bfs()&#123; memset(dep,-1,sizeof dep); static int q[maxn]; int hd=0,tl=1; q[tl]=S;dep[S]=0; while(hd&lt;tl)&#123; int x=q[++hd]; for(int u,i=head[x];i;i=nxt[i]) if(dep[u=to[i]]==-1 and w[i]) dep[u]=dep[x]+1,q[++tl]=u; &#125; return dep[T]!=-1; &#125; int dfs(int x,int flow)&#123; if(x==T) return flow; int used=0,u; for(int&amp; i=cur[x];i;i=nxt[i]) if(dep[u=to[i]]==dep[x]+1 and w[i])&#123; int v=dfs(u,min(flow-used,w[i])); used+=v,w[i]-=v,w[i^1]+=v; if(used==flow)break; &#125; return used; &#125; inline int dinic()&#123; int ans=0; while(bfs()) memcpy(cur,head,sizeof head),ans+=dfs(S,INF); return ans; &#125; int fa[maxn]; bool vis[maxn]; int find(int x)&#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125; void Dfs(int x)&#123;printf(&quot;%d &quot;,x);for(int u,i=head[x];i;i=nxt[i]) if(!w[i] and (u=to[i])&gt;n and u&lt;=n*2) Dfs(u-n);&#125; inline void work()&#123; n=read(),m=read(); for(int u,v,i=1;i&lt;=m;i++) u=read(),v=read(),addedge(u,v+n,1); for(int i=1;i&lt;=n;i++) addedge(S,i,1),addedge(i+n,T,1),fa[i]=i; int ans=n-dinic(); for(int i=1;i&lt;=m;i++) if(!w[i&lt;&lt;1]) fa[find(to[i&lt;&lt;1]-n)]=find(to[i&lt;&lt;1|1]); for(int i=1;i&lt;=n;i++) if(find(i)==i) Dfs(i),puts(&quot;&quot;); printf(&quot;%d\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125; P2469 星际竞速题意给你若干单向道路，并且每个点有一个可以从任意位置任意时刻到达该点的代价。求遍历所有点的最小代价。 思路参照最小路径覆盖的思路，拆出来的第二个点与汇点间的连边表示到达该点。建模方式如下： 对于所给的所有边 $(u,v)$，将 $u$ 向 $v’$ 建边权费用边。 从源点向所有 $i$ 连无费用边。 从所有 $i’$ 向汇点连无费用边。 从源点向所有 $i’$ 连传送费用边。上述所有边流量为 1。（因为从任何位置传送与起点无关） 跑最小费用最大流即为答案。正确性，考虑建出来的图，因为源点到所有点都有传送的边，所以跑最小割一定会经过所有点，并且因为都是单向边且流量为 1，所以保证正确。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=3005,maxm=600005,S=3003,T=3004,INF=0x3f3f3f3f; int n,m; int ecnt=1,head[maxn],to[maxm],nxt[maxm],w[maxm],v[maxm]; inline void addedge(int a,int b,int c,int d)&#123; to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt,w[ecnt]=c,v[ecnt]=d; to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt,w[ecnt]=0,v[ecnt]=-d; &#125; int dis[maxn],pre[maxn]; bool vis[maxn]; inline bool spfa()&#123; queue&lt;int&gt; q; memset(pre,0,sizeof pre); memset(vis,0,sizeof vis); memset(dis,INF,sizeof dis); q.push(S);dis[S]=0; while(!q.empty())&#123; int x=q.front();q.pop(); vis[x]=false; for(int u,i=head[x];i;i=nxt[i]) if(dis[u=to[i]]&gt;dis[x]+v[i] and w[i])&#123; dis[u]=dis[x]+v[i];pre[u]=i; if(!vis[u]) vis[u]=true,q.push(u); &#125; &#125; return pre[T]; &#125; int a[maxn]; inline void work()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) addedge(S,i,1,0),addedge(i+n,T,1,0),addedge(S,i+n,1,a[i]=read()); for(int u,v,zp,i=1;i&lt;=m;i++)&#123; u=read(),v=read(); if(u&gt;v) swap(u,v); if((zp=read())&lt;a[v])addedge(u,v+n,1,zp); &#125; int ans=0; while(spfa())&#123; int mn=INF; for(int i=pre[T];i;i=pre[to[i^1]]) mn=min(mn,w[i]); for(int i=pre[T];i;i=pre[to[i^1]]) w[i]-=mn,w[i^1]+=mn; ans+=dis[T]*mn; &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"权值线段树套序列线段树","slug":"权值线段树套序列线段树","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.488Z","comments":true,"path":"2022/04/30/权值线段树套序列线段树/","permalink":"https://starcried.github.io/2022/04/30/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E5%BA%8F%E5%88%97%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"【模板】权值线段树套序列线段树P3380 【模板】二逼平衡树（树套树） 主要思路如下： 外层为权值线段树，内层为动态开点线段树，也就是每个权值线段树上的节点开一个动态开点线段树。 外层的权值线段树支持查询排名，内层的线段树限制了区间。实际上就是在普通权值线段树上查询的价值变成了在其线段树上区间查询返回的值。 对于这道模板题，我们先写几个函数： 插入下方的update为外层线段树，将路径上的所有点的线段树修改。 上方的update为内层线段树，动态开点单点修改。 要判断k==1为题目需要，因为如果是删除的话就不需要开点了。 变量解释：v为权值，p为下标，k为修改的值。 1234567891011121314void update(int &amp;ro,int l,int r,int p,int k)&#123; if(k==1 and !ro)ro=++tot; if(ro) val[ro]+=k; if(!ro or l==r)return; int mid=l+r&gt;&gt;1; (p&lt;=mid)?update(ls[ro],l,mid,p,k):update(rs[ro],mid+1,r,p,k);&#125;void update(int &amp;ro,int l,int r,int v,int p,int k)&#123; if(k==1 and !ro)ro=++Tot; if(ro) update(rt[ro],1,n,p,k); if(!ro or l==r)return; int mid=l+r&gt;&gt;1; (v&lt;=mid)?update(Ls[ro],l,mid,v,p,k):update(Rs[ro],mid+1,r,v,p,k);&#125; 查询本题有多个查询： 查询k在区间中的排名，我们需要查询0~k-1在区间中的个数将结果加1。（因为有可能有重复元素） 查询区间内排名为k的值，我们只需要在权值线段树上查询即可，一个点的贡献就是其线段树在区间内的贡献。 查询前驱和后继，就是将上面两种操作合并，先查询有多少点在区间内小于&#x2F;小于等于该值，然后查询排名即可。 注意判断边界情况。 123456789101112131415161718192021222324252627int query(int ro,int l,int r,int x,int y)&#123; if(!ro)return 0; if(x&lt;=l and y&gt;=r)return val[ro]; int mid=l+r&gt;&gt;1; return (x&lt;=mid?query(ls[ro],l,mid,x,y):0)+(y&gt;mid?query(rs[ro],mid+1,r,x,y):0);&#125;int rank(int ro,int l,int r,int x,int y,int L,int R)&#123; if(!ro)return 0; if(x&lt;=l and y&gt;=r)return query(rt[ro],1,n,L,R); int mid=l+r&gt;&gt;1; return (x&lt;=mid?rank(Ls[ro],l,mid,x,y,L,R):0)+(y&gt;mid?rank(Rs[ro],mid+1,r,x,y,L,R):0);&#125;int kth(int ro,int l,int r,int k,int L,int R)&#123; if(l==r)return l; int mid=l+r&gt;&gt;1,tmp=query(rt[Ls[ro]],1,n,L,R); return (k&lt;=tmp)?kth(Ls[ro],l,mid,k,L,R):kth(Rs[ro],mid+1,r,k-tmp,L,R);&#125;inline int pre(int x,int y,int k)&#123; int zp; if(!(zp=rank(root,0,maxl,0,k-1,x,y)))return -2147483647; return kth(root,0,maxl,zp,x,y);&#125;inline int nxt(int x,int y,int k)&#123; int zp; if((zp=rank(root,0,maxl,0,k,x,y))==rank(root,0,maxl,0,maxl,x,y))return 2147483647; return kth(root,0,maxl,zp+1,x,y);&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=5e4+10,maxm=1e7+10,maxl=1e8; int n,q,rt[maxm],ls[maxm*3],rs[maxm*3],Ls[maxm],Rs[maxm],val[maxm*3],tot,Tot,root; int a[maxn]; void update(int &amp;ro,int l,int r,int p,int k)&#123; if(k==1 and !ro)ro=++tot; if(ro) val[ro]+=k; if(!ro or l==r)return; int mid=l+r&gt;&gt;1; (p&lt;=mid)?update(ls[ro],l,mid,p,k):update(rs[ro],mid+1,r,p,k); &#125; void update(int &amp;ro,int l,int r,int v,int p,int k)&#123; if(k==1 and !ro)ro=++Tot; if(ro) update(rt[ro],1,n,p,k); if(!ro or l==r)return; int mid=l+r&gt;&gt;1; (v&lt;=mid)?update(Ls[ro],l,mid,v,p,k):update(Rs[ro],mid+1,r,v,p,k); &#125; int query(int ro,int l,int r,int x,int y)&#123; if(!ro)return 0; if(x&lt;=l and y&gt;=r)return val[ro]; int mid=l+r&gt;&gt;1; return (x&lt;=mid?query(ls[ro],l,mid,x,y):0)+(y&gt;mid?query(rs[ro],mid+1,r,x,y):0); &#125; int rank(int ro,int l,int r,int x,int y,int L,int R)&#123; if(!ro)return 0; if(x&lt;=l and y&gt;=r)return query(rt[ro],1,n,L,R); int mid=l+r&gt;&gt;1; return (x&lt;=mid?rank(Ls[ro],l,mid,x,y,L,R):0)+(y&gt;mid?rank(Rs[ro],mid+1,r,x,y,L,R):0); &#125; int kth(int ro,int l,int r,int k,int L,int R)&#123; if(l==r)return l; int mid=l+r&gt;&gt;1,tmp=query(rt[Ls[ro]],1,n,L,R); return (k&lt;=tmp)?kth(Ls[ro],l,mid,k,L,R):kth(Rs[ro],mid+1,r,k-tmp,L,R); &#125; inline int pre(int x,int y,int k)&#123; int zp; if(!(zp=rank(root,0,maxl,0,k-1,x,y)))return -2147483647; return kth(root,0,maxl,zp,x,y); &#125; inline int nxt(int x,int y,int k)&#123; int zp; if((zp=rank(root,0,maxl,0,k,x,y))==rank(root,0,maxl,0,maxl,x,y))return 2147483647; return kth(root,0,maxl,zp+1,x,y); &#125; inline void work()&#123; n=read(),q=read(); for(int i=1;i&lt;=n;i++) update(root,0,maxl,a[i]=read(),i,1); while(q--)&#123; int op=read(),x=read(),y=read(); switch(op)&#123; case 1:printf(&quot;%d\\n&quot;,rank(root,0,maxl,0,read()-1,x,y)+1);break; case 2:printf(&quot;%d\\n&quot;,kth(root,0,maxl,read(),x,y));break; case 3:update(root,0,maxl,a[x],x,-1),update(root,0,maxl,a[x]=y,x,1);break; case 4:printf(&quot;%d\\n&quot;,pre(x,y,read()));break; case 5:printf(&quot;%d\\n&quot;,nxt(x,y,read()));break; &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125; P3332 [ZJOI2013]K大数查询 只剩一个询问查询k大数，区间修改。具体就是把上面内层的线段树变成了区间修改的。 常数巨大的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=5e4+10,maxm=1e7+10,maxl=5e5+10; int n,q,rt[maxm],ls[maxm*3],rs[maxm*3],Ls[maxm],Rs[maxm],val[maxm*3],tag[maxm*3],tot,Tot,root; void pushdown(int ro,int l,int r)&#123; int mid=floor((l+r)/2.0); if(!tag[ro])return; if(!ls[ro])ls[ro]=++tot; if(!rs[ro])rs[ro]=++tot; tag[ls[ro]]+=tag[ro],tag[rs[ro]]+=tag[ro]; val[ls[ro]]+=tag[ro]*(mid-l+1),val[rs[ro]]+=tag[ro]*(r-mid); tag[ro]=0; &#125; void pushup(int ro)&#123; val[ro]=val[ls[ro]]+val[rs[ro]]; &#125; void update(int &amp;ro,int l,int r,int x,int y,int k)&#123; if(!ro)ro=++tot; if(l==x and r==y)return (void)(tag[ro]+=k,val[ro]+=k*(r-l+1)); pushdown(ro,l,r); int mid=floor((l+r)/2.0); if(y&lt;=mid) update(ls[ro],l,mid,x,y,k); else if(x&gt;mid) update(rs[ro],mid+1,r,x,y,k); else update(ls[ro],l,mid,x,mid,k),update(rs[ro],mid+1,r,mid+1,y,k); pushup(ro); &#125; void update(int &amp;ro,int l,int r,int v,int x,int y,int k)&#123; if(!ro)ro=++Tot; if(ro) update(rt[ro],1,n,x,y,k); if(l==r)return; int mid=floor((l+r)/2.0); (v&lt;=mid)?update(Ls[ro],l,mid,v,x,y,k):update(Rs[ro],mid+1,r,v,x,y,k); &#125; int query(int ro,int l,int r,int x,int y)&#123; if(!ro)return 0; if(x==l and y==r)return val[ro]; pushdown(ro,l,r); int mid=floor((l+r)/2.0); if(y&lt;=mid) return query(ls[ro],l,mid,x,y); else if(x&gt;mid) return query(rs[ro],mid+1,r,x,y); else return query(ls[ro],l,mid,x,mid)+query(rs[ro],mid+1,r,mid+1,y); &#125; int kth(int ro,int l,int r,int k,int L,int R)&#123; if(l==r)return l; int mid=floor((l+r)/2.0),tmp=query(rt[Rs[ro]],1,n,L,R); return (k&lt;=tmp)?kth(Rs[ro],mid+1,r,k,L,R):kth(Ls[ro],l,mid,k-tmp,L,R); &#125; inline void work()&#123; n=read(),q=read(); while(q--)&#123; int op=read(),l=read(),r=read(),x=read(); switch(op)&#123; case 1:update(root,-maxl,maxl,x,l,r,1);break; case 2:printf(&quot;%lld\\n&quot;,kth(root,-maxl,maxl,x,l,r));break; &#125; &#125; &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"树上差分","slug":"树上差分","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.488Z","comments":true,"path":"2022/04/30/树上差分/","permalink":"https://starcried.github.io/2022/04/30/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/","excerpt":"","text":"差分 如果去看我的树状数组的博客的话就懂了，就是记录相邻节点值的差值。这样一来，前缀和就相当于原值了。 树上差分 树上差分基本上就是差分在树上的实现。因为差分的原理，我们先将所有点的权值改变成差分值，再更改一段区间内的所有值时，只需要更改首尾两端的值，如果要求值的话dfs重新加上前缀和就是正常的值了。 模板：洛谷P3128 模板题，发现更改任意两点间的值只需要在两点差分值加上1然后在lca和fa[lca]（倍增的话就是fa[lca][0]）上减去1，从根dfs并记录最大值即可。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;ctype.h&gt; #define R register using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=233333; int n,m,ans[maxn]; int top[maxn],fa[maxn][18],dep[maxn],head[maxn],ecnt,cnt; struct Edge{ int to,nxt; }e[maxn&lt;&lt;1]; inline void addedge(int a,int b) { e[++ecnt]=(Edge){b,head[a]};head[a]=ecnt; e[++ecnt]=(Edge){a,head[b]};head[b]=ecnt; } bool vis[maxn]; void dfs1(int x,int depth) { for (R int i=0;fa[x][i];++i) fa[x][i+1]=fa[fa[x][i]][i]; vis[x]=1; dep[x]=depth; for(R int i=head[x];i;i=e[i].nxt) { int u=e[i].to; if(vis[u])continue; fa[u][0]=x; dfs1(u,depth+1); } } inline int LCA(int u,int v) { if(dep[u]&lt;dep[v])swap(u,v); for(R int i=0;i&lt;=16;i++) if((dep[u]-dep[v])&amp;(1&lt;&lt;i))u=fa[u][i]; if(u==v)return u; for(R int i=16;i&gt;=0;i--) if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i]; return fa[u][0]; } int Ans=0; void dfs2(int x) { vis[x]=1; for(R int i=head[x];i;i=e[i].nxt) { int u=e[i].to; if(vis[u])continue; dfs2(u); ans[x]+=ans[u]; } Ans=max(Ans,ans[x]); } int main() { n=read(),m=read(); for(R int i=1;i&lt;n;i++)addedge(read(),read()); fa[1][0]=0; dfs1(1,1); for(R int i=1;i&lt;=m;i++) { int x=read(),y=read(); int lca=LCA(x,y); ans[x]++,ans[y]++,ans[lca]--,ans[fa[lca][0]]--; } memset(vis,0,sizeof vis); dfs2(1); printf(\"%d\\n\",Ans); return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"树形分治算法","slug":"树形分治算法","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-10T14:54:19.871Z","comments":true,"path":"2022/04/30/树形分治算法/","permalink":"https://starcried.github.io/2022/04/30/%E6%A0%91%E5%BD%A2%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","excerpt":"","text":"点分治点分治是一种树形分治的算法，它选择当前连通块一个重心，将树分成多个连通块进行处理，然后对每个连通块进行分治递归。 树的重心树上的一个点，满足它的儿子的 $size$ 的最大值最小。 可以证明，一个树有一个或者两个重心。若有两个重心，它俩一定是直接相连的。 处理问题 求树上给定路径联通的点的对数。我们发现将树分治后，形成了若干个连通块，而且这些连通块必定经过重心。那么我们就可以 $O(\\log n)$次地计算每一块之间的联通路径数。那么怎么计算呢？ 两两之间分别计算 利用容斥原理，在每一个分治中计算$sum_i^n$ 编号计算 求树上给定路径到给定点的路径权和。对于每一个连通块，因为有连通块内部和到上一层重心两个距离，我们必须利用动态开点线段树时间复杂度$O(n \\log^2 n)$。 点分树和动态点分树点分树就是将每一层的重心与下一层的子树的所有重心连边所构成的树。只能用来处理路径相关问题。 知识交叉——替罪羊树替罪羊树是一个二叉平衡搜索树，它有一个阈值，一般为 $0.75$，当一个点的一个子树大小大于该树的大小乘以阈值，那么我们就把它拍扁暴力重构成新的树。 那么点分树有一个类似的阈值，当一个子连通块的大小大于上层树大小乘阈值，我们分治重构它。 当然，之所以会不平衡，是因为插入了新的点，进行了修改。 例题 捉迷藏 紫荆花之恋 震波 边分治同样是对树进行分治，只不过这次是找一条边将左右两边分成两个连通块。 对于多子树点的处理因为多子树点（比如菊花图）是无法直接进行边分治的，我们可以插入虚点和虚边构成二叉树解决。即边分二叉树。虚点和虚边是没有贡献的，所以这样就可以保证答案正确。插入虚点和虚边的方法是：给每个子节点连上虚点，然后给虚点之间连边，给第一个虚点向节点连边，于是就成了二叉树。 边分树我们发现，每一层都分成了两个连通块，我们构建出一个点连接两个连通块，pushup 上子树的权值。 具体地，先对 $1$ 树进行边分治，每个点初始的边分树是一条链，考虑对每个点构造出这个边分树。 开始只有根。根其实就是记录分治时候是在那个位置。定义连接分治重心 root 深度较小的连通块为右部点，另一个为左部点，保存每个点作为左部点还是右部点。然后在每个之前最后一个加入位置 lasti 下面加入左儿子或者右儿子。 在 lasti 位置保留这个信息 vl，vr。初始是 -inf。 左部点贡献权值：dis[x]； 右部点贡献：dis[x]-dis[lca]。 lca 一定在右部点。 其实这就是合并二叉树：$O(nlogn)$ 次地合并，每次在分支处计算贡献，并只加上不重合的点。时间复杂度是和线段树合并类似的。 例题《暴力写挂》 （以下代码来自某划水选手） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 366666 * 2 + 5, M = 20; const ll INF = 0x3f3f3f3f3f3f3f3fLL; int n, node_cnt, rot[N]; ll ans; struct edge &#123; int v, w; &#125;; struct node &#123; int son[2]; ll val; &#125; tr[N * M]; namespace T1 &#123; int tot, size[N], Head[N], now[N]; ll dis[N]; vector&lt;edge&gt; T[N]; struct Edge &#123; int to, next, w, vis; &#125; E[N &lt;&lt; 1]; inline void add(const int u, const int v, const int w) &#123; static int ec = 1; E[++ec] = &#123;v, Head[u], w, 0&#125;; Head[u] = ec; E[++ec] = &#123;u, Head[v], w, 0&#125;; Head[v] = ec; &#125; void buildtree(const int u, const int f) &#123; for (auto p : T[u]) if (p.v != f) &#123; dis[p.v] = dis[u] + p.w; buildtree(p.v, u); &#125; static vector&lt;edge&gt; son; son.clear(); for (auto p : T[u]) if (p.v != f) son.push_back(p); int sz = int(son.size()); if (!sz) return; for (int i = 0; i &lt; sz; i++) add(tot + i + 1, son[i].v, son[i].w); for (int i = 1; i &lt; sz; i++) add(tot + i, tot + i + 1, 0); add(u, tot + 1, 0); tot += sz; &#125; void build() &#123; tot = n; for (int i = 1, u, v, w; i &lt; n; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); T[u].push_back(&#123;v, w&#125;); T[v].push_back(&#123;u, w&#125;); &#125; buildtree(1, 0); for (int i = 1; i &lt;= n; i++) rot[i] = now[i] = ++node_cnt; &#125; void getsize(const int u, const int f) &#123; size[u] = 1; for (int i = Head[u], v; i; i = E[i].next) if (!E[i].vis &amp;&amp; (v = E[i].to) != f) &#123; getsize(v, u); size[u] += size[v]; &#125; &#125; void getedge(const int u, const int f, const int sz, int &amp;p) &#123; for (int i = Head[u], v; i; i = E[i].next) if (!E[i].vis &amp;&amp; (v = E[i].to) != f) &#123; if (max(size[v], sz - size[v]) &lt; max(size[E[p].to], sz - size[E[p].to])) p = i; getedge(v, u, sz, p); &#125; &#125; void dfs(const int u, const int f, const ll d, const int c) &#123; if (u &lt;= n) &#123; tr[now[u]].son[c] = ++node_cnt; tr[now[u] = node_cnt].val = d + dis[u]; &#125; for (int i = Head[u], v; i; i = E[i].next) if (!E[i].vis &amp;&amp; (v = E[i].to) != f) dfs(v, u, d + E[i].w, c); &#125; void solve(const int x) &#123; getsize(x, 0); if (size[x] == 1) return; int p = 0, u, v; getedge(x, 0, size[x], p); E[p].vis = E[p ^ 1].vis = 1; dfs(u = E[p].to, 0, E[p].w, 0); dfs(v = E[p ^ 1].to, 0, 0, 1); solve(u); solve(v); &#125; &#125; namespace T2 &#123; ll res; vector&lt;edge&gt; E[N]; void update(const int x, const int y) &#123; if (x &amp;&amp; y) ans = max(ans, tr[x].val + tr[y].val - res); &#125; void merge(int &amp;x, const int y) &#123; if (!x || !y) return void(x = x + y); tr[x].val = max(tr[x].val, tr[y].val); update(tr[x].son[0], tr[y].son[1]); update(tr[x].son[1], tr[y].son[0]); merge(tr[x].son[0], tr[y].son[0]); merge(tr[x].son[1], tr[y].son[1]); &#125; void dfs(const int u, const int f, const ll d) &#123; ans = max(ans, (T1::dis[u] - d) * 2); for (auto p : E[u]) if (p.v != f) &#123; dfs(p.v, u, d + p.w); res = d * 2; merge(rot[u], rot[p.v]); &#125; &#125; void solve() &#123; for (int i = 1, u, v, w; i &lt; n; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); E[u].push_back(&#123;v, w&#125;); E[v].push_back(&#123;u, w&#125;); &#125; dfs(1, 0, 0); &#125; &#125; void work() &#123; scanf(&quot;%d&quot;, &amp;n); T1::build(); T1::solve(1); T2::solve(); printf(&quot;%lld\\n&quot;, ans &gt;&gt; 1); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"https://starcried.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"点分治","slug":"点分治","permalink":"https://starcried.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"}]},{"title":"树形DP[非公开][草稿]","slug":"树形DP[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.489Z","comments":true,"path":"2022/04/30/树形DP[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E6%A0%91%E5%BD%A2DP[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"没有学习笔记真的全部都会忘！！！ 树形DP 动态规划的基本问题。这种树形的DP肯定就有他的树形结构的特点啦，其特点就是结构是一个树（废话），从根节点开始dp，每一个点会有若干个子叶，我们需要在dp前记录所有点的子叶，然后递归进行更新最后返回到根节点，输出根节点即可。 我们先来看几道例题（搬运自因特耐特）。 P1352 没有上司的舞会 https://www.luogu.com.cn/problem/P1352 &nbsp; 这是个入门题，我们发现每个节点的竹叶节点不能同时被选择，所以我们可以用的d[i][1]和d[i][0]分别记录选择和不选择i节点。用vector记录每个节点的子叶节点。 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"树状数组[非公开][草稿]","slug":"树状数组[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.489Z","comments":true,"path":"2022/04/30/树状数组[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"详解请跳转 树状数组，是和线段树相提并论（并不）的一种数据存储形式。对于一个数组，我们要是只是进行一些简单的区间修改或查询的话，因为树状数组很好的运用了它的特性，常数要比线段树小很多。但是如果进行一些更复杂的操作，线段树的用处就显现出来了。 我们简单记一下树状数组的结构。 &nbsp; &nbsp; &nbsp;像这样，用a记录原始数据，用c记录所属的区间的加和（通常是这样），我们在查询时就可以直接查询c而非每次都加和a来获得答案。 例如，c[2]=a[1]+a[2],我们如果要查询3-7的区间和,可以先得到1-5的和再减去1-2的和（相当于一个前缀和的思想）。那么怎么查询呢？ 请看图，不难得到getsum(7)=c7+c6+c4,getsum(2)=c2。 于是乎，如何得到getsum(7)? 我们观察树状数组的形态，发现它是按照一种规律分的子树。我们再使劲观察一下，发现它符合这样一个规律： 7=(111), -7=(001), 7&amp;-7=1. 6=(110), -6=(010), 6&amp;-6=(10)=2. 带括号的是二进制（数字前面的0省略）。众所周知，一个数的负数是它的补码。那么我们就可以发现如果一个数x，x&amp;-x等于几呢？ 答案是，当x==0,x&amp;-x=0. 当x为奇数,x&amp;-x=1. 当x为偶数,x&amp;-x值为它最小的值为2的倍数的因数。 这个x&amp;-x是有一个专有称呼的，lowbit 于是我们发现，树状数组其实就是按照这个原理构造起来的。我们刚才已经求出lowbit(6)=2，再观察一下图，发现它巧妙地刚好符合6-lowbit(4)=4，而c4正是我们要求的值。 于是我们就可以得到代码： int n; int a[1005],c[1005]; inline int lowbit(int x){ return x&amp;(-x);} inline void updata(int i,int k){ while(i &lt;&#x3D; n){ c[i] +&#x3D; k; i +&#x3D; lowbit(i); }} inline int getsum(int i){ int res &#x3D; 0; while(i &gt; 0){ res +&#x3D; c[i]; i -&#x3D; lowbit(i); } return res;} 查询时只需要每次减去lowbit就可以得到下一个值，更新时加lowbit即可。 模板题目 洛谷P3374 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;ctype.h&gt; 4 using namespace std; 5 const int maxn=5e5+5; 6 inline int read() 7 { 8 int x=0,w=1;char c=getchar(); 9 while(!isdigit(c)){if(c=='-')w=-1;c=getchar();} 10 while(isdigit(c))x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); 11 return x*w; 12 } 13 int a[maxn],c[maxn]; 14 15 inline int lowbit(int x){return x &amp; -x;} 16 int n,m; 17 inline void update(int i,int k) 18 { 19 while(i&lt;=n)c[i]+=k,i+=lowbit(i); 20 } 21 inline int getsum(int i) 22 { 23 int ans=0; 24 while(i)ans+=c[i],i-=lowbit(i); 25 return ans; 26 } 27 int main() 28 { 29 n=read();m=read(); 30 for(int i=1;i&lt;=n;i++) 31 { 32 update(i,read()); 33 } 34 for(int a,b,i=1;i&lt;=m;i++) 35 { 36 switch(read()) 37 { 38 39 case(1):{ 40 a=read(),b=read(); 41 update(a,b); 42 break; 43 } 44 case(2):{ 45 a=read(),b=read(); 46 printf(\"%d\\n\",getsum(b)-getsum(a-1)); 47 break; 48 } 49 } 50 } 51 return 0; 52 } 53 /*5 5 54 1 5 4 2 3 55 1 1 3 56 2 2 5 57 1 3 1 58 1 4 2 59 2 1 4*/ &nbsp; 应用-区间修改-差分数组 设a为原数组，d为差分数组，a[0]=0, 对于下面这个数组: A[] = 1 2 3 5 6 9 D[] = 1 1 1 2 1 3 如果我们把[2,5]区间内值加上2，则变成了 A[] = 1 4 5 7 8 9 D[] = 1 3&nbsp;1 2 1&nbsp;1 我们发现只是2和6的值变了，区间以内的值不会改变。于是我们就可以通过构造差分数组来得到原数组。 注意：此处不是求原数组的和，是用树状数组存储差分数组求得原数组。此时我们最多只能单点查询。 当然，如果要区间查询且区间修改的话，建立两个树状数组即可。 &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"树链剖分","slug":"树链剖分","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.490Z","comments":true,"path":"2022/04/30/树链剖分/","permalink":"https://starcried.github.io/2022/04/30/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","excerpt":"","text":"https://www.cnblogs.com/chinhhh/p/7965433.html&lt;-详解 洛谷P3384&lt;-模板 如果我会告诉你我不小心把%写成了*调了一个多小时吗 适用范围 在一棵树上+-点权/边权然后多次提问的问题等 原理 将一棵树剖分成若干条链，在链上通过数据结构维护。 照本宣科 将一个点的子树中最大的那个做为重儿子，其他的叫做轻儿子，对于所有点的重儿子连的链称为重链。我们将重链作为主链，将轻儿子构成的其他轻链加在重链的后面。很明显，对于每一条链，它的节点都是相连的（废话）。对于每一个子树，它的所有的节点都排在子树根的后面。 所以我们就把一个树成功地退化成了一条链。 因为这条链有如上我所说的几个性质，题目要求如果是能在链上连续维护的（如求子树权值和，求任意两点间距离和），我们就可以用数据结构维护它了，比如线段树。 构造 首先我们需要两次dfs。 dfs1 用于建树，顺便记录每个节点的父亲 和 该点的深度 和 它的子树的大小 和 它的重儿子。 fa[]父亲节点 dep[]深度 siz[]子树大小 son[]重儿子（重儿子为子树大者） void dfs1(int x,int f,int depth) { siz[x]=1; dep[x]=depth; fa[x]=f; int maxson=-1; for(R int i=head[x];i;i=e[i].nxt) { int u=e[i].to; if(u==f)continue; dfs1(u,x,depth+1); siz[x]+=siz[u]; if(siz[u]&gt;maxson)son[x]=u,maxson=siz[u]; } } dfs2 用于将一个树退化成链，记录节点在链的编号 和 节点的链首节点 和 链上节点的权值。 cnt时间戳 id[]编号 top[]链首节点 a[]原值 w[]链上的值（便于维护） void dfs2(int x,int topf) { id[x]=++cnt; w[cnt]=a[x]; top[x]=topf; if(!son[x])return; dfs2(son[x],topf); for(R int i=head[x];i;i=e[i].nxt) { int u=e[i].to; if(u==fa[x]||u==son[x])continue; dfs2(u,u); } } &nbsp; 求两点间距离 要求两点间距离： 若两点在一条链上（top[x]==top[y]）我们直接求两点间的距离即可。 若两点不在一条链上，那么求更深的那个点x到此刻链首top[x]的距离，然后令x=fa[top[x]]，即可将x更新到新链上。重复操作，每次只将深度更大的点向上更新。最终两点会处于同一条链（重链或轻链，最远是重链）上，然后再加上两点间的和就可以了。 用线段树维护。 inline int queryrange(int x,int y) { int ans=0; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); res=0; st.query(1,id[top[x]],id[x]); ans=(ans+res)%mod; x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); res=0; st.query(1,id[x],id[y]); ans=(ans+res)%mod; return ans; } 更新两点间距离 和上面是一样的，分成若干条链更新就可以了。 inline void updaterange(int x,int y,int k){ k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); st.update(1,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); st.update(1,id[x],id[y],k); } 更新/查询子树权值（和） 如上，子树节点在链上一定是在根的后面并且连续的。 所以要更新以x为根节点的所有子树结点，就更新id[x]~id[x]+size[x]-1的范围即可。 （代码放在代码里） 例题（在上面） 当然要根据题目需要做各种修改，这真的只是一个板子。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;ctype.h&gt; #define R register using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=1e5+5,maxm=1e5+5; int n,m,root,mod,fa[maxn],dep[maxn],son[maxn],siz[maxn],top[maxn],id[maxn],a[maxn],w[maxn]; struct Edge{ int to,nxt; }e[maxn*2]; int ecnt,head[maxn]; inline void addedge(int from,int to) { e[++ecnt]=(Edge){to,head[from]};head[from]=ecnt; e[++ecnt]=(Edge){from,head[to]};head[to]=ecnt; } int res; struct SegmentTree{ #define ls (ro&lt;&lt;1) #define rs (ro&lt;&lt;1|1) &lt;span style=&quot;color: #0000ff;&quot;&gt;struct&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; tree&#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; l,r,val,tag; &#125;e[maxn&lt;/span&gt;&amp;lt;&amp;lt;&lt;span style=&quot;color: #800080;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; push_up(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ro) &#123; e[ro].val&lt;/span&gt;=(e[ls].val+e[rs].val)%&lt;span style=&quot;color: #000000;&quot;&gt;mod; &#125; inline &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; push_down(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ro) &#123; e[ls].tag&lt;/span&gt;+=&lt;span style=&quot;color: #000000;&quot;&gt;e[ro].tag; e[rs].tag&lt;/span&gt;+=&lt;span style=&quot;color: #000000;&quot;&gt;e[ro].tag; e[ls].val&lt;/span&gt;+=e[ro].tag*(e[ls].r-e[ls].l+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); e[rs].val&lt;/span&gt;+=e[ro].tag*(e[rs].r-e[rs].l+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); e[ls].val&lt;/span&gt;%=&lt;span style=&quot;color: #000000;&quot;&gt;mod; e[rs].val&lt;/span&gt;%=&lt;span style=&quot;color: #000000;&quot;&gt;mod; e[ro].tag&lt;/span&gt;=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; build(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; ro,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; r) &#123; e[ro].l&lt;/span&gt;=l;e[ro].r=&lt;span style=&quot;color: #000000;&quot;&gt;r; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(l==r)&#123;e[ro].val=w[l]%mod;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ;&#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mid=(l+r)&amp;gt;&amp;gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; build(ls,l,mid);build(rs,mid&lt;/span&gt;+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,r); push_up(ro); &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; update(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; ro,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; r,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; k) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[ro].l&amp;gt;=l and e[ro].r&amp;lt;=&lt;span style=&quot;color: #000000;&quot;&gt;r)&#123; e[ro].tag&lt;/span&gt;+=&lt;span style=&quot;color: #000000;&quot;&gt;k; e[ro].val&lt;/span&gt;+=k*(e[ro].r-e[ro].l+&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); e[ro].val&lt;/span&gt;%=&lt;span style=&quot;color: #000000;&quot;&gt;mod; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mid=(e[ro].l+e[ro].r)&amp;gt;&amp;gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(e[ro].tag)push_down(ro); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(l&amp;lt;=&lt;span style=&quot;color: #000000;&quot;&gt;mid)update(ls,l,r,k); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(r&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;mid)update(rs,l,r,k); push_up(ro); &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; query(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; ro,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; l,&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; r) &#123; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(e[ro].l&amp;gt;=l and e[ro].r&amp;lt;=&lt;span style=&quot;color: #000000;&quot;&gt;r)&#123; res&lt;/span&gt;+=e[ro].val;res%=mod;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(e[ro].tag)push_down(ro); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; mid=(e[ro].l+e[ro].r)&amp;gt;&amp;gt;&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(l&amp;lt;=&lt;span style=&quot;color: #000000;&quot;&gt;mid)query(ls,l,r); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(r&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;mid)query(rs,l,r); &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#undef&lt;/span&gt; ls &lt;span style=&quot;color: #0000ff;&quot;&gt;#undef&lt;/span&gt; rs&lt;span style=&quot;color: #000000;&quot;&gt; }st; void dfs1(int x,int f,int depth){ siz[x]&#x3D;1; dep[x]&#x3D;depth; fa[x]&#x3D;f; int maxson&#x3D;-1; for(R int i&#x3D;head[x];i;i&#x3D;e[i].nxt) { int u&#x3D;e[i].to; if(u&#x3D;&#x3D;f)continue; dfs1(u,x,depth+1); siz[x]+&#x3D;siz[u]; if(siz[u]&gt;maxson)son[x]&#x3D;u,maxson&#x3D;siz[u]; }}int cnt;void dfs2(int x,int topf){ id[x]&#x3D;++cnt; w[cnt]&#x3D;a[x]; top[x]&#x3D;topf; if(!son[x])return; dfs2(son[x],topf); for(R int i&#x3D;head[x];i;i&#x3D;e[i].nxt) { int u&#x3D;e[i].to; if(u&#x3D;&#x3D;fa[x]||u&#x3D;&#x3D;son[x])continue; dfs2(u,u); }}inline void updaterange(int x,int y,int k){ k%&#x3D;mod; while(top[x]!&#x3D;top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); st.update(1,id[top[x]],id[x],k); x&#x3D;fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); st.update(1,id[x],id[y],k);}inline int queryrange(int x,int y){ int ans&#x3D;0; while(top[x]!&#x3D;top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); res&#x3D;0; st.query(1,id[top[x]],id[x]); ans&#x3D;(ans+res)%mod; x&#x3D;fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); res&#x3D;0; st.query(1,id[x],id[y]); ans&#x3D;(ans+res)%mod; return ans;} inline void debug(){ for(int i&#x3D;1;i&lt;&#x3D;n;i++) { res&#x3D;0;st.query(1,id[i],id[i]); printf(“%d “,res); }} int main(){ n&#x3D;read(),m&#x3D;read(),root&#x3D;read(),mod&#x3D;read(); for(R int i&#x3D;1;i&lt;&#x3D;n;i++)a[i]&#x3D;read(); for(R int i&#x3D;1;i&lt;n;i++)addedge(read(),read()); dfs1(root,0,1); dfs2(root,root); st.build(1,1,n); while(m–) { int a,b,c; switch(read()) { case(1):{ a&#x3D;read(),b&#x3D;read(),c&#x3D;read(); updaterange(a,b,c); break; } case(2):{ a&#x3D;read(),b&#x3D;read(); printf(“%d\\n“,queryrange(a,b)); break; } case(3):{ int a&#x3D;read(),b&#x3D;read(); st.update(1,id[a],id[a]+siz[a]-1,b); break; } case(4):{ int a&#x3D;read();res&#x3D;0; st.query(1,id[a],id[a]+siz[a]-1); printf(“%d\\n“,res); break; } } } &#x2F;&#x2F;debug(); return 0;} &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"模拟退火[非公开][草稿]","slug":"模拟退火[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.491Z","comments":true,"path":"2022/04/30/模拟退火[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"模拟退火（SA） 模拟退火是一种随机化算法。什么叫随机化算法？就是抽奖抽正解 一般用于求解最优解，而且一般比较适合于小数据的最优解和大数据的近似最优解，总之就是解题的一个万能挂，但不一定正确。 模拟退火的主要步骤： 先初始化温度，当前解和当前答案 如果温度小于最终温度，跳到第7步；否则跳3 重复执行4~5步L次 由当前解生成一个临时的新解，并计算新的答案 判断是否接受该临时解，接受则更新解和答案，不接受则回退到上个解 降温，跳2 结束 对于差解的判断和 这个解有多差 以及 当前温度 有关，解越差我们越不想要它，接受它的概率就小一些；贪心往往会在开始的时候陷入局部最优解，我们就要在开始的时候跳出局部最优，也就是通过走向较差的解，所 以开始的时候接受差解的概率要大一些，快结束的时候我们需要稳定在当前的最优解，接受差解的概率就小一些，所以我们模拟物理的退火原理，温度从高逐渐降低，对于接受差解概率的计算公式e^(delta/T)来说，新解答案的差异值为分子delta，是个负数（如果正数取负就行），答案越差，delta绝对值越大，指数越小，概率也越小；温度越低，指数越小，概率也越小，这就符合了我们求解的需要。 爬山算法好像是查询变优秀速度最大的地方并逼近最优值。我们先来看一个简单的单调的问题。 注意下方的定义： delta表示退火的速度 eps表示极低值。退火时是tempetare*delta当然达不到0 T表示初始温度 srand(seed)表示以seed为种子生成的随机数。引用于cstdlib库。当你想完全随机时可令seed=time(0)，time()函数引用于ctime库。生成完了后，用rand()得到这些值 exp(x)表示e^x，引用于cmath库 模拟退火的中心公式是在随机出的解差于最优解时，有一定几率跳出该解，并且这个几率会随着次数变小，即： rand()&lt;exp((ans-newans)/t) * RAND_MAX &nbsp; P2420 #include&lt;ctype.h&gt; #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;ctime&gt; #include&lt;cmath&gt; #include&lt;utility&gt; #define eps 1e-10 #define INF 1e19 #define delta 0.98 using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=2e5+10; typedef pair&lt;double,double&gt; pairr; pair &lt;double,double&gt; p[maxn]; int dx[]={0,0,1,-1},dy[]={1,-1,0,0}; inline double dist(pairr a,pairr b){ return sqrt((a.first-b.first)(a.first-b.first)+(a.second-b.second)(a.second-b.second));} inline double getsum(pairr p[],int n,pairr z){ double ans&#x3D;0; while(n–) ans+&#x3D;dist(p[n],z); return ans;} double search(pairr p[],int n){ pairr s&#x3D;p[0]; double t&#x3D;100000; double ans&#x3D;INF; while(t&gt;eps) { bool flag&#x3D;1; while(flag) { flag&#x3D;0; for(register int i&#x3D;0;i&lt;4;i++) { pairr z; z.first&#x3D;s.first+dx[i]t; z.second&#x3D;s.second+dy[i]t; double tp&#x3D;getsum(p,n,z); if(ans&gt;tp)ans&#x3D;tp,s&#x3D;z,flag&#x3D;1; } } t*&#x3D;delta; } return ans;} int main(){ int n&#x3D;read(); for(register int i&#x3D;0;i&lt;n;i++)p[i]&#x3D;make_pair(read(),read()); printf(“%.0f“,search(p,n)); return 0;} &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"求最小公因数和最大公倍数","slug":"求最小公因数和最大公倍数","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.491Z","comments":true,"path":"2022/04/30/求最小公因数和最大公倍数/","permalink":"https://starcried.github.io/2022/04/30/%E6%B1%82%E6%9C%80%E5%B0%8F%E5%85%AC%E5%9B%A0%E6%95%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E5%80%8D%E6%95%B0/","excerpt":"","text":"今天从算法竞赛的书上看到求这两个东西的方法，稍微记一下。 根据欧几里得算法，即著名的辗转相除法： gcd(a,b)=gcd(b,a%b)，边界条件为当b=0时,gcd(a,b)=a; （扩展欧几里得请看另一篇博客） int gcd(int x,int y){return y?gcd(y,x%y):x;} 那么，最小公倍数也是这么求的。 假如我们要求a,b的最小公倍数，我们先把他们拆成若干质数的积：（以下未用markdown） a=p1e1p2e2&middot;&middot;&middot;pnen b=p1f1p2f2&middot;&middot;&middot;pnfn&nbsp; 那么 gcd(a,b)=p1min(e1,f1) &middot;&middot;&middot;pnmin(en,fn) lcm(a,b)=p1max(e1,f1) &middot;&middot;&middot;pnmax(en,fn) &there4;gcd(a,b)*lcm(a,b)=a*b","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"求逆元[非公开][草稿]","slug":"求逆元[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.491Z","comments":true,"path":"2022/04/30/求逆元[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E6%B1%82%E9%80%86%E5%85%83[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"逆元 逆元是个啥？x的逆元就是x的倒数（误 在数论意义下（正整数），逆元b是指a*b&amp;mod==1的数。而这个b不一定唯一。同时，，如果mod不同，b也是不同的。所以可以说a有无数个逆元。 当a&gt;mod时，它莫得逆元；当a和mod不互质时，a不一定有逆元。 例如，求4在mod7意义下的逆元，就是4x%7==1,x就是此逆元。 逆元的几种求法 扩展欧几里得 递推 费马小定理（求!x的逆元） 扩展欧几里得 我们知道扩欧的递推式是y=xx-a/b*y #include&lt;iostream&gt; using namespace std; typedef long long ll; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) { ll t; if(!b){ x=1,y=0;return a; } else{ t=exgcd(b,a%b,x,y); int xx=x; x=y; y=xx-a/b*y; return t; } } int inv(ll a,ll p){ ll d,x,y; d&#x3D;exgcd(a,p,x,y); return d&#x3D;&#x3D;1?(x+p)%p:-1;} int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;inv(a,b); return 0;} 递推求1~n的逆元 网上有人比我讲的清楚得多。我们来看看这个推导（支持原创） &nbsp; &nbsp; 所以我们理解了之后我们直接使用即可。 核心公式：inv[i]=(mod-mod/i)*inv[mod%i]%mod; #include&lt;iostream&gt; using namespace std; int inv[20],n=10,MOD=7; int main() { inv[1]=1; for(int i=2;i&lt;=n;i++) { if(i&gt;=MOD)break;//大于MOD的莫得逆元 inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;//重点要考！ } for(int i=1;i&lt;=n;i++) { cout&lt;&lt;inv[i]&lt;&lt;\"\\n\"; } return 0; } &nbsp; 求0!~x!的逆元 首先我们知道费马小定理ap-1=a(mod p),可得a*ap-2=1(mod p).所以ap-2即为a在mod p意义下的逆元。然而这并没有什么用因为这个时间复杂度显而易见。 其实还是有一点用的因为可以利用这个逆元推出0~x!的逆元。 我们假设有逆元x使得a! x=1(mod p),则(a-1)!*ax=1(mod p) 所以(i-1)!的逆元为ix%p。x就是inv[i]，即inv[i-1]=(inv[i]*i)%mod; 那么我们先用费马小定理求出!n的逆元然后倒推回去就可以辣！ 倒推公式：inv[i]=(inv[i+1]*(i+1))%MOD; 用费马小定理时，记得用快速幂不然会有不好的事情发生。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"石子合并","slug":"石子合并","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.492Z","comments":true,"path":"2022/04/30/石子合并/","permalink":"https://starcried.github.io/2022/04/30/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/","excerpt":"","text":"https://www.luogu.com.cn/problem/P1880 一道区间dp题目。 用d[i][j]表示从i到j的最大/最小得分，那么依次枚举长度len，坐标i和j，三层循环就可以dp递推求得最值了（听说这是道NOI题目） 记得使用前缀和哦。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;ctype.h&gt; #define INF 0x3f3f3f3f using namespace std; inline int read() { int x=0,w=1;char c=getchar(); while(!isdigit(c)){ if(c=='-')w=-1; c=getchar(); } while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return x*w; } const int maxn=105; int a[maxn],sum[maxn],d[maxn][maxn],d2[maxn][maxn]; int main() { int n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i];//前缀和 for(int len=2;len&lt;=n;len++) for(int i=1;i&lt;=n-len+1;i++) { int j=i+len-1; d[i][j]=INF; for(int k=i;k&lt;j;k++) { if(d[i][j]&gt;d[i][k]+d[k+1][j]+sum[j]-sum[i-1]) d[i][j]=d[i][k]+d[k+1][j]+sum[j]-sum[i-1]; if(d2[i][j]&lt;d2[i][k]+d2[k+1][j]+sum[j]-sum[i-1]) d2[i][j]=d2[i][k]+d2[k+1][j]+sum[j]-sum[i-1]; } &#125; printf(&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;%d\\n%d\\n&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;,d[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;][n],d2[&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;][n]); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; } 勇于实践的小伙伴们可以惊讶的发现：它爆零了！ emmm我们仔细审题会发现这是一个环。 所以不要着急我们给它再加n个数复制一遍就可以AC了（发扬了dp用内存换速度的优良作风） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;ctype.h&gt; #define INF 0x3f3f3f3f using namespace std; inline int read() { int x=0,w=1;char c=getchar(); while(!isdigit(c)){ if(c=='-')w=-1; c=getchar(); } while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return x*w; } const int maxn=105*2; int a[maxn],sum[maxn],d[maxn][maxn],d2[maxn][maxn]; int main() { int n=read(); for(int i=1;i&lt;=n;i++)a[i]=a[i+n]=read(); for(int i=1;i&lt;=(n+n);i++)sum[i]=sum[i-1]+a[i];//前缀和 for(int len=2;len&lt;=n;len++) for(int i=1,j=i+len-1;i&lt;n+n and j&lt;n+n ;i++,j=i+len-1) { d[i][j]=INF; for(int k=i;k&lt;j;k++) { if(d[i][j]&gt;d[i][k]+d[k+1][j]+sum[j]-sum[i-1]) d[i][j]=d[i][k]+d[k+1][j]+sum[j]-sum[i-1]; if(d2[i][j]&lt;d2[i][k]+d2[k+1][j]+sum[j]-sum[i-1]) d2[i][j]=d2[i][k]+d2[k+1][j]+sum[j]-sum[i-1]; } &#125; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; ans1=INF,ans2=&lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt; i=&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++)ans1=min(ans1,d[i][i+n-&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;]),ans2=max(ans2,d2[i][i+n-&lt;span style=&quot;color: #800080;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;]); printf(&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;%d\\n%d\\n&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;,ans1,ans2); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #800080;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; } 当然，这个直接把n&lt;&lt;1的作死做法是没有办法干过大多数题目的。于是我们就需要对dp进行平行四边形优化 但是我没学&hellip;&hellip;以后学了单独写一篇题解吧。 扩展：这道题的数据范围是n&lt;=100,而我们给它还扩充到了n&lt;=200。那么如果n更大呢？比如n&lt;=40000? 这里有一道题目洛谷P5569 是的我们没法再用40000*40000的dp做了。 我也不会 这已经不是dp的问题了！但是还是给大佬们一个传送门","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"离散数学-传递闭包（POJ3275）","slug":"离散数学-传递闭包（POJ3275）","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.493Z","comments":true,"path":"2022/04/30/离散数学-传递闭包（POJ3275）/","permalink":"https://starcried.github.io/2022/04/30/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%EF%BC%88POJ3275%EF%BC%89/","excerpt":"","text":"就是n的元素给定m个关系求他们之间的关系。 eg.&nbsp; ∵a&gt;b and b&gt;c &there4;a&gt;c emmmm 若要知道n个元素的绝对关系，则需知道C(n,2)个关系。 例题：POJ3275 求法：Floyd。关系如下： if(g[i][k] and g[k][j]) g[i][j]=1; 但是呢，对于这个题的数据范围O(n3)的解法是肯定不行的。 于是我们用链式前向星。 &nbsp; /*#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;bitset&gt; #include&lt;vector&gt; using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=1e3+10; int n,m; bitset&lt;maxn&gt;g[maxn]; int main(){ n&#x3D;read(),m&#x3D;read(); for(int i&#x3D;1;i&lt;&#x3D;m;i++) g[read()][read()]&#x3D;1; for(int k&#x3D;1;k&lt;&#x3D;n;k++) for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;n;j++) if(g[i][k] &amp; g[k][j])g[i][j]&#x3D;1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) if(g[i][i]){ printf(“-1\\n”);return 0; } int ans&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;n;j++) if(!g[i][j] and !g[j][i])ans++; printf(“%d”,(ans-n)&#x2F;2); return 0;}&#x2F;&#x2F;&#x2F;上面是邻接矩阵#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define R registerusing namespace std;inline int read(){ int x&#x3D;0,w&#x3D;0;char c&#x3D;getchar(); while(!isdigit(c))w|&#x3D;c&#x3D;&#x3D;‘-‘,c&#x3D;getchar(); while(isdigit(c))x&#x3D;(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c&#x3D;getchar(); return w?-x:x;}const int maxn&#x3D;1100;int head[2][maxn],to[2][maxn],nxt[2][maxn],ecnt,n,m;inline void addedge(int from,int too){ to[0][++ecnt]&#x3D;too,nxt[0][ecnt]&#x3D;head[0][from],head[0][from]&#x3D;ecnt; to[1][ecnt]&#x3D;from,nxt[1][ecnt]&#x3D;head[1][too],head[1][too]&#x3D;ecnt;}bool vis[maxn][maxn];int main(){ n&#x3D;read(),m&#x3D;read(); int ans&#x3D;0; for(R int x,y,i&#x3D;1;i&lt;&#x3D;m;i++) { x&#x3D;read(),y&#x3D;read(); if(!vis[x][y]) addedge(x,y),ans++,vis[x][y]&#x3D;1; } for(R int u,v,k&#x3D;1;k&lt;&#x3D;n;k++) for(R int i&#x3D;head[1][k];i;i&#x3D;nxt[1][i]) { u&#x3D;to[1][i]; for(R int j&#x3D;head[0][k];j;j&#x3D;nxt[0][j]) { v&#x3D;to[0][j]; if(vis[u][v])continue; vis[u][v]&#x3D;1; ans++; addedge(u,v); } } printf(“%d“,n(n-1)&#x2F;2-ans); return 0;} &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"硬币问题（无限背包）-容斥[非公开][草稿]","slug":"硬币问题（无限背包）-容斥[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.493Z","comments":true,"path":"2022/04/30/硬币问题（无限背包）-容斥[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98%EF%BC%88%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85%EF%BC%89-%E5%AE%B9%E6%96%A5[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; const int S=1e5+5; int t,s; long long c[5],d[5],f[S]; int main() { scanf(\"%lld%lld%lld%lld%d\", &amp;c[1], &amp;c[2], &amp;c[3], &amp;c[4], &amp;t); f[0]=1; for(int j=1;j&lt;=4;j++) for(int i=1;i&lt;=S;i++) if(i&gt;=c[j])f[i]+=f[i-c[j]]; while(t--) { scanf(\"%lld%lld%lld%lld%d\",&amp;d[1],&amp;d[2],&amp;d[3],&amp;d[4],&amp;s); long long ans=0; for(int i=1;i&lt;16;i++) { int m=s,bit=0; for(int j=1;j&lt;=4;j++) if(i&gt;&gt;(j-1)&amp;1)m-=(d[j]+1)*c[j],bit++; if(m&gt;=0)ans+=(bit%2*2-1)*f[m]; printf(\"%lld\\n\",f[s]-ans); } } return 0; } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"类欧几里得算法","slug":"类欧几里得算法","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.494Z","comments":true,"path":"2022/04/30/类欧几里得算法/","permalink":"https://starcried.github.io/2022/04/30/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"类欧几里得算法类欧几里得算法之所以被称为类欧几里得是因为其算法复杂度证明与扩展欧几里得算法类似。 我认为类欧更偏向于是一种思想。 其主要思想就是寻找可以简便计算的边界，然后通过化式子将不同情况化为边界递归计算。 P5170 【模板】类欧几里得算法推导$$f(a,b,c,n)&#x3D;\\sum_{i&#x3D;0}^n \\lfloor\\frac{ai+b}{c}\\rfloor$$ $$g(a,b,c,N)&#x3D;\\sum_{i&#x3D;0}^N \\lfloor\\frac{ai+b}{c}\\rfloor^2$$ $$h(a,b,c,N)&#x3D;\\sum_{i&#x3D;0}^N i\\lfloor \\frac{ai+b}{c}\\rfloor$$ $$f(a,b,c,N)&#x3D;\\begin{cases}(N+1)\\lfloor\\frac{b}{c}\\rfloor&amp;a&#x3D;0\\\\frac{N(N+1)}{2}\\lfloor\\frac{a}{c}\\rfloor+(N+1)\\lfloor\\frac{b}{c}\\rfloor+f(a\\bmod c,b\\bmod c,c,N)&amp;a\\ge c\\ or\\ b\\ge c\\NM-f(c,c-b-1,a,M-1),M&#x3D;\\lfloor\\frac{aN+b}{c}\\rfloor &amp;otherwise\\end{cases}$$ $$g(a,b,c,N)&#x3D;\\begin{cases}(N+1)\\lfloor\\frac{b}{c}\\rfloor^2&amp;a&#x3D;0\\g(a\\bmod c,b\\bmod c,c,N)+2\\lfloor\\frac{a}{c}\\rfloor h(a\\bmod c,b\\bmod c,c,N)+2\\lfloor\\frac{b}{c}\\rfloor f(a\\bmod c,b\\bmod c,c,N)+\\frac{N(N+1)(2N+1)}{6}\\lfloor\\frac{a}{c}\\rfloor^2+N(N+1)\\lfloor\\frac{a}{c}\\rfloor\\lfloor\\frac{b}{c}\\rfloor+(N+1)\\lfloor\\frac{b}{c}\\rfloor^2&amp;a\\ge c\\ or\\ b\\ge c\\NM(M+1)-f(a,b,c,N)-2h(c,c-b-1,a,M-1)-2f(c,c-b-1,a,M-1)&amp;otherwise\\end{cases}$$ $$h(a,b,c,N)&#x3D;\\begin{cases}\\frac{N(N+1)}{2}\\lfloor\\frac{b}{c}\\rfloor&amp;a&#x3D;0\\h(a\\bmod c,b\\bmod c,c,N)+\\frac{N(N+1)(2N+1)}{6}\\lfloor\\frac{a}{c}\\rfloor+\\frac{N(N+1)}{2}\\lfloor\\frac{b}{c}\\rfloor&amp;a\\ge c\\ or\\ b\\ge c\\\\frac{1}{2}[MN(N+1)-g(c,c-b-1,a,M-1)-f(c,c-b-1,a,M-1)]&amp;otherwise\\end{cases}$$ 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;tuple&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;const int mod=998244353;tuple&lt;int,int,int&gt; calc(long long a,long long b,long long c,long long n)&#123; int f,g,h,fn,gn,hn; if(!a)&#123; fn=(n+1)*(b/c)%mod; gn=(n+1)*(b/c)%mod*(b/c)%mod; hn=n*(n+1)%mod*((mod+1)&gt;&gt;1)%mod*(b/c)%mod; &#125;else if(a&gt;=c or b&gt;=c)&#123; tie(f,g,h)=calc(a%c,b%c,c,n); fn=(n*(n+1)%mod*((mod+1)&gt;&gt;1)%mod*(a/c)%mod+(n+1)*(b/c)%mod+f)%mod; gn=(n*(n+1)%mod*(2*n+1)%mod*((mod+1)/6)%mod*(a/c)%mod*(a/c)%mod+(n+1)*(b/c)%mod*(b/c)%mod+n*(n+1)%mod*(a/c)%mod*(b/c)%mod+2*(b/c)%mod*f%mod+g+2*(a/c)%mod*h%mod)%mod; hn=(n*(n+1)%mod*(2*n+1)%mod*((mod+1)/6)%mod*(a/c)%mod+n*(n+1)%mod*((mod+1)&gt;&gt;1)%mod*(b/c)%mod+h)%mod; &#125;else&#123; tie(f,g,h)=calc(c,c-b-1,a,(a*n+b)/c-1); fn=(n*((a*n+b)/c)%mod-f+mod)%mod; gn=(n*((a*n+b)/c)%mod*((a*n+b)/c+1)%mod-fn+mod-2*f%mod+mod-2*h%mod+mod)%mod; hn=(n*(n+1)%mod*((a*n+b)/c)%mod*((mod+1)&gt;&gt;1)%mod-f*((mod+1ll)&gt;&gt;1)%mod+mod-g*((mod+1ll)&gt;&gt;1)%mod+mod)%mod; &#125; return tie(fn,gn,hn);&#125;signed main()&#123; int T=read(),n,a,b,c,f,g,h; while(T--) n=read(),a=read(),b=read(),c=read(),tie(f,g,h)=calc(a,b,c,n),printf(&quot;%d %d %d\\n&quot;,f,g,h); return 0;&#125; P5171 Earthquake题意求满足 $ax+by⩽c$ 的非负整数解的个数。 推导$$y⩽\\left\\lfloor\\frac{c-ax}{b}\\right\\rfloor\\ans&#x3D;\\sum_{x&#x3D;0}^{\\left\\lfloor\\frac{c}{a}\\right\\rfloor}\\left\\lfloor\\frac{c-ax}{b}\\right\\rfloor+1\\&#x3D;\\sum_{x&#x3D;0}^{\\left\\lfloor\\frac{c}{a}\\right\\rfloor}\\left\\lfloor\\frac{c+(b-a)x}{b}\\right\\rfloor-x+1\\(\\sum_{x&#x3D;0}^{\\left\\lfloor\\frac{c}{a}\\right\\rfloor}\\left\\lfloor\\frac{c+(b-a)x}{b}\\right\\rfloor)-\\frac{\\left\\lfloor\\frac{c}{a}\\right\\rfloor(\\left\\lfloor\\frac{c}{a}\\right\\rfloor+1)}{2}+\\left\\lfloor\\frac{c}{a}\\right\\rfloor+1$$ 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define int long longusing namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;long long f(long long a,long long b,long long c,long long n)&#123; if(!a) return (n+1)*(b/c); if(a&gt;=c or b&gt;=c) return n*(n+1)/2*(a/c)+(n+1)*(b/c)+f(a%c,b%c,c,n); return n*((a*n+b)/c)-f(c,c-b-1,a,(a*n+b)/c-1);&#125;signed main()&#123; int a=read(),b=read(),c=read(); if(a&gt;b)swap(a,b); printf(&quot;%lld\\n&quot;,f(b-a,c,b,c/a)-1ll*(c/a)*(c/a+1)/2+c/a+1);&#125; P5172 Sum推导$$ans&#x3D;\\sum_{d&#x3D;1}^n(-1)^{\\lfloor d\\sqrt r\\rfloor}\\&#x3D;\\sum_{d&#x3D;1}^n1-2(\\lfloor d\\sqrt r\\rfloor\\bmod 2)\\&#x3D;\\sum_{d&#x3D;1}^n1-2(\\lfloor d\\sqrt r\\rfloor-2\\lfloor \\frac{d\\sqrt r}2\\rfloor)$$ $$f(a,b,c,n)&#x3D;\\sum_{d&#x3D;1}^n\\lfloor\\frac{a\\sqrt r+b}{c}d\\rfloor$$ 当 $\\lfloor\\frac{a\\sqrt r+b}{c}\\rfloor\\ge1$ 时，$$f(a,b,c,n)&#x3D;\\sum_{d&#x3D;1}^n\\lfloor\\frac{a\\sqrt r+b}{c}d\\rfloor\\&#x3D;\\sum_{d&#x3D;1}^n\\lfloor\\frac{a\\sqrt r+b-c\\lfloor\\frac{a\\sqrt r+b}{c}\\rfloor}{c}d+\\lfloor\\frac{a\\sqrt r+b}{c}\\rfloor d\\rfloor\\&#x3D;\\sum_{d&#x3D;1}^nf(a,b-c\\lfloor\\frac{a\\sqrt r+b}{c}\\rfloor,c,n)+\\frac 1 2n(n+1)\\lfloor\\frac{a\\sqrt r+b}{c}\\rfloor$$当 $\\lfloor\\frac{a\\sqrt r+b}{c}\\rfloor&#x3D;0$ 时,$$f(a,b,c,n)&#x3D;\\sum_{d&#x3D;1}^n\\lfloor\\frac{a\\sqrt r+b}{c}d\\rfloor\\&#x3D;\\sum_{d&#x3D;1}^n\\sum_{p&#x3D;1}^{\\lfloor\\frac{a\\sqrt r+b}{c}n\\rfloor}[p\\le\\frac{a\\sqrt r+b}{c}d]\\&#x3D;\\sum_{d&#x3D;1}^n\\sum_{p&#x3D;1}^{\\lfloor\\frac{a\\sqrt r+b}{c}n\\rfloor}[d\\ge\\frac{cp}{a\\sqrt r+b}]\\&#x3D;\\sum_{p&#x3D;1}^{\\lfloor\\frac{a\\sqrt r+b}{c}n\\rfloor} n-\\lfloor\\frac{cp}{a\\sqrt r+b}\\rfloor\\\\texttt{（无理数，大于等于与大于等价）}\\&#x3D;\\lfloor\\frac{a\\sqrt r+b}{c}n\\rfloor n-\\sum_{p&#x3D;1}^{\\lfloor\\frac{a\\sqrt r+b}{c}n\\rfloor}\\lfloor\\frac{c(a\\sqrt r -b)}{a^2r-b^2}p\\rfloor\\&#x3D;\\lfloor\\frac{a\\sqrt r+b}{c}n\\rfloor n-f(ac,-bc,a^2r-b^2,\\lfloor\\frac{a\\sqrt r+b}{c}n\\rfloor)$$ $$ans&#x3D;1-2f(1,0,1,n)+4f(1,0,2,n)$$ 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;double sr;int r;long long gcd(long long a,long long b)&#123;return b?gcd(b,a%b):a;&#125;long long f(long long a,long long b,long long c,long long n)&#123; if(!n) return 0; long long g=gcd(gcd(a,b),c);a/=g,b/=g,c/=g; long long k=(a*sr+b)/c; if(k) return f(a,b-c*k,c,n)+n*(n+1)/2*k; return (long long)((a*sr+b)/c*n)*n-f(a*c,-b*c,a*a*r-b*b,(long long)((a*sr+b)/c*n));&#125;signed main()&#123; int T=read(),n; while(T--)&#123; n=read(),r=read();sr=sqrt(r); if((int)sr*(int)sr==r) printf(&quot;%d\\n&quot;,((int)sr&amp;1)?-(n&amp;1):n); else printf(&quot;%lld\\n&quot;,n-2*f(1,0,1,n)+4*f(1,0,2,n)); &#125; return 0;&#125; P5179 Fraction推导$$f(a,b,p,q,c,d)\\begin{cases}q&#x3D;1,p&#x3D;\\left\\lfloor\\frac{a}{c}\\right\\rfloor+1&amp;\\left\\lfloor\\frac{a}{c}\\right\\rfloor+1⩽\\left\\lceil\\frac{c}{d}\\right\\rceil-1\\p&#x3D;1,q&#x3D;\\left\\lfloor\\frac{d}{c}\\right\\rfloor+1&amp;a&#x3D;0\\ f(b,a,q,p,d,c)&amp;a⩽b \\and c⩽d\\f(a\\mod b,b,p,q,c-\\left\\lfloor\\frac{a}{b}\\right\\rfloor d,d),p&#x3D;p+\\left\\lfloor\\frac{a}{b}\\right\\rfloor q&amp;a\\ge b\\end{cases}$$ 代码12345678910111213#include&lt;cstdio&gt;using namespace std;void calc(long long a,long long b,long long &amp;p,long long &amp;q,long long c,long long d)&#123; if(a/b+1&lt;=(c+d-1)/d-1) p=a/b+1,q=1; else if(!a) p=1,q=d/c+1; else if(a&lt;=b and c&lt;=d) calc(d,c,q,p,b,a); else calc(a%b,b,p,q,c-a/b*d,d),p+=a/b*q;&#125;signed main()&#123; long long a,b,c,d,p,q; while(~scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d)) calc(a,b,p,q,c,d),printf(&quot;%lld/%lld\\n&quot;,p,q); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"笛卡尔树","slug":"笛卡尔树","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-10T14:35:10.263Z","comments":true,"path":"2022/04/30/笛卡尔树/","permalink":"https://starcried.github.io/2022/04/30/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/","excerpt":"","text":"笛卡尔树 笛卡尔树（Cartesian tree）是一种树形数据结构，每个节点都是一个区间，树的根节点表示整个区间，左儿子表示区间的左半部分，右儿子表示区间的右半部分。 笛卡尔树可以通过单调栈 $O(n)$ 静态建造。 例题P2659美丽的序列 题意找出一个序列的所有子段中子段长度乘段内元素最小值的最大值。 思路我们需要找出所有子段中贡献最大的，并且一个子段的贡献为其长度乘区间最小值。 建出符合小根堆性质的笛卡尔树，递归所有点，更新答案即可。 因为这是一道裸题，所以我记录一下建笛卡尔树的模板。思路是用一个单调栈维护一下右链。 123456789// 建笛卡尔树for(int k,i=1;i&lt;=n;i++)&#123; k=top; while(k and a[st[k]]&gt;a[i])k--; if(k) rs[st[k]]=i,isrt[i]=1; if(k&lt;top) ls[i]=st[k+1],isrt[st[k+1]]=1; st[++k]=i; top=k;&#125; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int w=0,x=0;char c=getchar(); while(!isdigit(c))w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c))x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;namespace star&#123; const int maxn=2e6+10; int n,a[maxn],ls[maxn],rs[maxn],st[maxn],top; long long ans; bool isrt[maxn]; void dfs(int x,int l,int r)&#123; ans=max(ans,1ll*a[x]*(r-l+1)); if(ls[x])dfs(ls[x],l,x-1); if(rs[x])dfs(rs[x],x+1,r); &#125; inline void work()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int k,i=1;i&lt;=n;i++)&#123; k=top; while(k and a[st[k]]&gt;a[i])k--; if(k) rs[st[k]]=i,isrt[i]=1; if(k&lt;top) ls[i]=st[k+1],isrt[st[k+1]]=1; st[++k]=i; top=k; &#125; int root=0; for(int i=1;i&lt;=n;i++) if(!isrt[i]) root=i; dfs(root,1,n); printf(&quot;%lld\\n&quot;,ans); &#125;&#125;signed main()&#123; star::work(); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"笛卡尔树","slug":"笛卡尔树","permalink":"https://starcried.github.io/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"}]},{"title":"线性基","slug":"线性基","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.495Z","comments":true,"path":"2022/04/30/线性基/","permalink":"https://starcried.github.io/2022/04/30/%E7%BA%BF%E6%80%A7%E5%9F%BA/","excerpt":"","text":"基：在线性代数中，基（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。同样的，线性基是一种特殊的基，它通常会在异或运算中出现，它的意义是：通过原集合S的某一个最小子集S1使得S1内元素相互异或得到的值域与原集合S相互异或得到的值域相同。 上文来自百度百科。 ###线性基中的“基”个人理解，线性基的“线性”表示的是数列，即用一个数列表示另一个数列。而“基”表示的是一种类似于向量的思想。因为原数列中的每个数都是不同的，那么它们每个数就分别对应一些线性基的异或和——和向量的表示方式有异曲同工之处。 大概理解了思想后，我们来理解它的构造。线性基是一个数列，其大小为原数列的最大数的二进制位数（所以是longlong的话大概最好开65位）。它的每一位是原数列中的一个数。有可能含有多个零。 ###线性基的性质 可以用线性基中任意个数异或和表示原数列中的所有数（或者说是原数列中任意数的异或和，表达其实是等价的） 线性基中的任意数的异或和不可能为0（除非你用0异或0，然而并不算做线性基内部的数） 线性基是满足性质1的最小集合 俺不会证明XD ###线性基的构造每插入一个数，我们从最高位向下遍历（注意这里是指二进制位数），找到第一个线性基上没有的插入并跳出，如果已经有数则与之异或（保证线性基的所有性质）：inline void insert(ll x)&#123; for(ll i=62;i+1;i--)&#123; if(!(x&gt;&gt;i))continue; if(!p[i])&#123; p[i]=x; break; &#125; x^=p[i]; &#125; &#125;###线性基的应用####查询异或和最小值最小值就是p的最小的值啦~因为它任意异或一个比它大的线性基的数一定都比它大。####查询异或和最大值既然能由任何数异或得到原数列任意异或和的值，我们再次从上向下遍历，每异或后的值大于原答案，就取这个值。inline ll find()&#123; ll ans=0; for(ll i=63;i&gt;=0;i--) if((ans^p[i])&gt;ans) ans^=p[i]; return ans; &#125;说起来你可能不信：这玩意还支持删除！","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"约数和定理[非公开][草稿]","slug":"约数和定理[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.495Z","comments":true,"path":"2022/04/30/约数和定理[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"##约数和定理 对于一个大于1正整数n可以分解质因数：n&#x3D;p1^a1p2^a2p3^a3…pk^ak,则由约数个数定理可知n的正约数有(a₁+1)(a₂+1)(a₃+1)…(ak+1)个，那么n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为f(n)&#x3D;(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak） ——百度百科","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"线性筛 欧拉筛","slug":"线性筛 欧拉筛","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.496Z","comments":true,"path":"2022/04/30/线性筛 欧拉筛/","permalink":"https://starcried.github.io/2022/04/30/%E7%BA%BF%E6%80%A7%E7%AD%9B%20%E6%AC%A7%E6%8B%89%E7%AD%9B/","excerpt":"","text":"线性筛 int prime[maxl]; bool mark[maxl]; int tot; inline void oula() { for(int i=2;i&lt;=maxl;i++) { if(!mark[i])prime[++tot]=i; for(int j=1;j&lt;=tot and i+prime[j]&lt;=maxl;j++){ mark[i*prime[j]]=1; if(i%prime[j]==0)break; } } } 最后一行代码是为了保证不重复。 可以顺便求欧拉函数的&phi;值。欧拉函数的值&phi;x是x以内与x互素的数的个数。&phi;是积性函数，性质如下： 若n是素数，&phi;n=n-1。 若n是质数p的k次幂： &phi;n=pk-pk-1=(p-1)pk-1 若m与n互质： &phi;(mn)=&phi;m*&phi;n 若要求单个数的phi值： BZOJ2705 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #define ll long long using namespace std; ll n,ans; int m; ll phi(ll x) { ll t=x; for(ll i=2;i&lt;=m;i++) if(x%i==0) { t=t/i*(i-1); while(x%i==0)x/=i; } if(x&gt;1)t=t/x*(x-1); return t; } int main() { scanf(\"%lld\",&amp;n); m=sqrt(n); for(int i=1;i&lt;=m;i++) if(n%i==0) { ans+=(ll)i*phi(n/i); if(i*i&lt;n)ans+=(ll)(n/i)*phi(i); } printf(\"%lld\",ans); return 0; } 如要算出范围内所有的phi值： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; const int maxn=1e8; inline int read() { int x=0;char c=getchar(); while(!isdigit(c))c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return x; } int phi[maxn],prime[maxn&gt;&gt;1],tot,n,ans; bool mark[maxn]; inline void oula() { phi[1]=1; for(int i=2;i&lt;=n;i++) { if(!mark[i]) { prime[++tot]=i; phi[i]=i-1; } for(int j=1;j&lt;=tot and i*prime[j]&lt;=n;j++) { mark[i*prime[j]]=1; if(i%prime[j]==0)phi[i*prime[j]]=phi[i]*prime[j]; else phi[i*prime[j]]=phi[i]*(prime[j]-1); if(i%prime[j])break; } } } int main() { n=read()； int m=read(); oula(); while(m--)printf(\"%d\\n\",prime[read()]); return 0; } &nbsp;注意&phi;1=1.","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"线性筛","slug":"线性筛","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.496Z","comments":true,"path":"2022/04/30/线性筛/","permalink":"https://starcried.github.io/2022/04/30/%E7%BA%BF%E6%80%A7%E7%AD%9B/","excerpt":"","text":"线性筛闲话之前写的总结不忍直视（总结了个寂寞），今天突然要用到约数和结果不会筛，于是爬来写博客。 性质 时间复杂度线性 理论上所有积性函数都可以筛（推式子） 用法对于需要筛的积性函数，我们需要讨论三种数时它的取值或者转移。 当 $i$ 为素数时，此时函数的值一般可以快速得到； 当 $i\\mod p&#x3D;0$ 时； 当 $i\\mod p\\ne 0$ 时。 对于不同数论函数当然每处的转移都不同了。 下文所有标号位置对应以上三种情况，并设 $tmp&#x3D;i*p$ 例子约数个数和根据算术基本定理(?)，设数 $n$ 的约数个数和为 $d_n$，有：$$n&#x3D;\\prod_{p_i\\mid n \\and p_i\\mathrm{\\ is\\ a\\ prime}}p_i^{g_i}\\d_n&#x3D;\\prod g_i+1$$要筛 $d$ 我们还需要一个 $g$ 来表示该数的最小素因子的数量，以便进行第二条转移。 $g_i&#x3D;1,d_i&#x3D;2$。 此时枚举数 $i$ 的最小约数已经之前被更新过了并且一定是当前正在枚举的 $p$ ，则 $g_{tmp}&#x3D;g_i+1$。对于 $d_{tmp}$，根据上述公式，那我们就从 $d_i$ 进行转移，更新最小约数的贡献，即除掉更改的贡献乘上正确的，即 $d_{tmp}&#x3D;d_i*\\frac{g_{tmp}+1}{g_i+1}$。 此时枚举的 $p$ 是最小的素因子，那么根据公式，$g_{tmp}&#x3D;1,d_{tmp}&#x3D;d_i*2$。 1234567891011121314d[1]=1;for(int i=2;i&lt;=n;i++)&#123; if(!mark[i]) p[++tot]=i,d[i]=2,g[i]=1; for(int j=1,tmp;j&lt;=tot and (tmp=i*p[j])&lt;=n;j++)&#123; mark[tmp]=true; if(i%p[j]==0)&#123; g[tmp]=g[i]+1; d[tmp]=d[i]/(g[i]+1)*(g[tmp]+1); break; &#125; g[tmp]=1; d[tmp]=d[i]*[g[tmp]+1]; &#125;&#125; 约数和根据算术基本定理(?)，已知 $\\sigma$ 为约数和，有：$$\\sigma_n&#x3D;\\prod_{p_i\\mid n\\and p_i\\mathrm{\\ is\\ a\\ prime}}\\sum_{j&#x3D;0}^{a_i}p_i^j$$ 注意这里的 $a$ 与上文的 $g$ 表示意义相同，为每个素数的个数。我们定义 $g$ 为最小的 $p$ 的 $\\sum_{j&#x3D;0}p^j$。 $g_i&#x3D;\\sigma_i&#x3D;i+1$ 根据 $g$ 的定义，我们要更新 $g$ 就相当于给原来的 $g$ 乘上 $p$ 并加 1。对于 $\\sigma$，和上面的转移类似，我们从 $i$ 转移即可。$\\sigma_{tmp}&#x3D;\\sigma_i*\\frac{g_{tmp}}{g_i}$。 此时我们计算上一个新的质数的贡献即可，和上面类似。 代码中 $\\sigma$ 用 $f$ 代替。 1234567891011121314f[1]=1;for(int i=2;i&lt;=n;i++)&#123; if(!mark[i]) p[++tot]=i,g[i]=f[i]=i+1; for(int j=1,tmp;j&lt;=tot and (tmp=i*p[j])&lt;=n;j++)&#123; mark[tmp]=true; if(i%p[j]==0)&#123; g[tmp]=g[i]*p[j]+1; f[tmp]=f[i]/g[i]*g[tmp]; break; &#125; g[tmp]=p[j]+1; f[tmp]=f[i]*f[p[j]]; &#125;&#125; 总结如果要使用线性筛来筛积性函数，大多要表示成枚举所有质因数来统计贡献的形式才可以推出式子。更多技巧待耕。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"线段树维护单调栈 单调递增序列","slug":"线段树维护单调栈 单调递增序列","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.497Z","comments":true,"path":"2022/04/30/线段树维护单调栈 单调递增序列/","permalink":"https://starcried.github.io/2022/04/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E5%8D%95%E8%B0%83%E6%A0%88%20%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/","excerpt":"","text":"线段树维护单调栈&#x2F;单调递增序列线段树在维护区间时可以维护一个单调栈。 P4198 楼房重建题意：维护全局最大上升序列大小。 更新线段树当前节点存储整个区间的最大值，对于该题，左子树的区间答案可以直接继承，然后用左子树区间的最大值查询右子树的答案并记录在该节点上。 123456void update(const int &amp;x,const double &amp;k,const int &amp;ro=1,const int &amp;l=1,const int &amp;r=n)&#123; if(l==r) return ans[ro]=1,mx[ro]=k,void(); x&lt;=mid?update(x,k,ls,l,mid):update(x,k,rs,mid+1,r); mx[ro]=max(mx[ls],mx[rs]); ans[ro]=ans[ls]+query(mx[ls],rs,mid+1,r);&#125; 其中，查询右区间比传的值大的节点个数的查询方式如下： 123456int query(const double &amp;k,const int &amp;ro=1,const int &amp;l=1,const int &amp;r=n)&#123; if(mx[ro]&lt;=k) return 0; if(l==r) return mx[ro]&gt;k; if(mx[ls]&lt;=k) return query(k,rs,mid+1,r); else return query(k,ls,l,mid)+ans[ro]-ans[ls];&#125; P4425 转盘维护后缀答案最小值。比较值为原序列，答案维护最小值。 123456void update(const int &amp;x,const int &amp;ro=1,const int &amp;l=1,const int &amp;r=n)&#123; if(l==r) return mx[ro]=a[x],void(); x&lt;=mid?update(x,ls,l,mid):update(x,rs,mid+1,r); mx[ro]=max(mx[ls],mx[rs]); mn[ro]=query(mx[rs],ls,l,mid);&#125; 1234int query(const int &amp;k,const int &amp;ro=1,const int &amp;l=1,const int &amp;r=n)&#123; if(l==r) return mx[ro]&gt;k?k+l:INF; return k&lt;mx[rs]?min(mn[ro],query(k,rs,mid+1,r)):query(k,ls,l,mid);&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"线段树懒标记","slug":"线段树懒标记","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.497Z","comments":true,"path":"2022/04/30/线段树懒标记/","permalink":"https://starcried.github.io/2022/04/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%87%92%E6%A0%87%E8%AE%B0/","excerpt":"","text":"线段树在n较小、操作较多的情况下效率很高。虽然如此，如果直接暴力进行修改的话还是会TLE得很惨。于是一个叫做懒标记的东西应运而生。 懒标记 why优秀：在修改一个节点时，若此点已经被懒标记所标记，我们就将此点懒标记取消，标记左右子节点传递下去，当被更新或者被查询时再更新节点，节约了根本不会被用到的花费。这也是线段树作为&ldquo;树&rdquo;优秀的地方。 开始学习 洛谷已经为我们排好了对线段树的逐层深度学习XD P3372 【模板】线段树 1 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 using namespace std; 4 const int maxn=1e5,maxm=1e5; 5 typedef long long ll; 6 void read(int &amp;x) 7 { 8 char c=getchar(); 9 while(c&lt;'0' or c&gt;'9')c=getchar(); 10 x=c-'0',c=getchar(); 11 while(c&gt;='0' and c&lt;='9'){ 12 x*=10,x+=c-'0',c=getchar(); 13 } 14 } 15 int a[maxn*10]; 16 struct node{ 17 ll l,r,sum,tag; 18 }e[maxn*6]; 19 int n,m,k; 20 inline ll ls(ll ro){return ro&lt;&lt;1;} 21 inline ll rs(ll ro){return ro&lt;&lt;1|1;} 22 inline void push_up(ll ro) 23 { 24 e[ro].sum=e[ls(ro)].sum+e[rs(ro)].sum; 25 } 26 inline void push_down(ll ro) 27 { 28 e[ls(ro)].sum+=e[ro].tag*(e[ls(ro)].r-e[ls(ro)].l+1); 29 e[rs(ro)].sum+=e[ro].tag*(e[rs(ro)].r-e[rs(ro)].l+1); 30 e[ls(ro)].tag+=e[ro].tag; 31 e[rs(ro)].tag+=e[ro].tag; 32 e[ro].tag=0; 33 } 34 35 void build(ll ro,ll l,ll r) 36 { 37 e[ro].l=l,e[ro].r=r; 38 if(l==r) 39 { 40 e[ro].sum=a[l]; 41 return; 42 } 43 e[ro].tag=0; 44 ll mid=(l+r)&gt;&gt;1; 45 build(ls(ro),l,mid); 46 build(rs(ro),mid+1,r); 47 push_up(ro); 48 } 49 50 void update(ll ro,ll l,ll r) 51 { 52 if(e[ro].l&gt;=l and r&gt;=e[ro].r) 53 { 54 e[ro].sum+=k*(e[ro].r-e[ro].l+1); 55 e[ro].tag+=k; 56 return; 57 } 58 push_down(ro); 59 ll mid=(e[ro].l+e[ro].r)&gt;&gt;1; 60 if(l&lt;=mid)update(ls(ro),l,r); 61 if(r&gt; mid)update(rs(ro),l,r); 62 push_up(ro); 63 } 64 65 ll check(ll ro,ll l,ll r) 66 { 67 if(l&lt;=e[ro].l and r&gt;=e[ro].r)return e[ro].sum; 68 push_down(ro); 69 int mid=(e[ro].l+e[ro].r)&gt;&gt;1; 70 ll ans=0; 71 if(l&lt;=mid)ans+=check(ls(ro),l,r); 72 if(r&gt; mid)ans+=check(rs(ro),l,r); 73 return ans; 74 } 75 signed main() 76 { 77 read(n);read(m); 78 for(int i=1;i&lt;=n;i++) 79 read(a[i]); 80 build(1,1,n); 81 int casee,l,r; 82 for(int i=1;i&lt;=m;i++) 83 { 84 read(casee); 85 switch(casee) 86 { 87 case(1):{ 88 read(l);read(r);read(k); 89 update(1,l,r); 90 break; 91 } 92 case(2):{ 93 read(l);read(r); 94 printf(\"%lld\\n\",check(1,l,r)); 95 break; 96 } 97 } 98 } 99 return 0; 100 } P3373 【模板】线段树 2 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 using namespace std; 4 const int maxn=1e5; 5 typedef long long ll; 6 int n,m,p,a[maxn],k; 7 struct tree{ 8 ll l,r,val,add,tag; 9 }e[maxn*4]; 10 inline void read(int &amp;x) 11 { 12 char c=getchar(); 13 while(c&lt;'0' or c&gt;'9')c=getchar(); 14 x=c-'0',c=getchar(); 15 while(c&gt;='0' and c&lt;='9')x*=10,x+=c-'0',c=getchar(); 16 } //这个快读读不了负数 XD 17 inline ll ls(int ro){return ro&lt;&lt;1;} 18 inline ll rs(int ro){return ro&lt;&lt;1|1;} 19 20 inline void lazy_add(ll ro) 21 { 22 e[ls(ro)].add=(e[ls(ro)].add*e[ro].tag+e[ro].add)%p; 23 e[rs(ro)].add=(e[rs(ro)].add*e[ro].tag+e[ro].add)%p; 24 //给子节点加上懒标记，add需要乘tag才能保证不变，再加上add 25 } 26 27 inline void lazy_tag(ll ro) 28 { 29 e[ls(ro)].tag=(e[ls(ro)].tag*e[ro].tag)%p; 30 e[rs(ro)].tag=(e[rs(ro)].tag*e[ro].tag)%p; 31 //相同，乘标记挺正常 32 } 33 34 inline void push_down(ll ro) 35 { 36 e[ls(ro)].val=(e[ls(ro)].val*e[ro].tag+e[ro].add*(e[ls(ro)].r-e[ls(ro)].l+1))%p; 37 e[rs(ro)].val=(e[rs(ro)].val*e[ro].tag+e[ro].add*(e[rs(ro)].r-e[rs(ro)].l+1))%p; 38 //分析：给子节点的值乘上乘标记值，再加上加标记在它区间元素个数的和； 39 lazy_tag(ro); 40 lazy_add(ro); 41 e[ro].add=0,e[ro].tag=1;//别忘了清除懒标记 42 } 43 44 inline void push_up(ll ro) 45 { 46 e[ro].val=(e[ls(ro)].val+e[rs(ro)].val)%p;//给爷加和 因为这个题只需要输出和所以这样做，并不普遍 47 } 48 49 void build(ll ro,ll l ,ll r) 50 { 51 e[ro].l=l,e[ro].r=r; 52 e[ro].tag=1,e[ro].add=0; 53 if(l==r){e[ro].val=a[l];return;}//赋值 54 int mid=(l+r)&gt;&gt;1; 55 build(ls(ro),l,mid); 56 build(rs(ro),mid+1,r); 57 push_up(ro); 58 e[ro].val%=p;//膜一下 59 } 60 61 //更新乘 62 void update_tag(ll ro,ll l ,ll r) 63 { 64 if(e[ro].l&gt;=l and e[ro].r&lt;=r) 65 { 66 e[ro].val=(e[ro].val*k)%p; 67 e[ro].tag=(e[ro].tag*k)%p; 68 e[ro].add=(e[ro].add*k)%p; 69 return ; 70 } 71 push_down(ro); 72 int mid=(e[ro].l+e[ro].r)&gt;&gt;1; 73 if(l&lt;=mid)update_tag(ls(ro),l,r); 74 if(r&gt; mid)update_tag(rs(ro),l,r); 75 push_up(ro); 76 } 77 78 //更新和 79 void update_add(ll ro,ll l,ll r) 80 { 81 if(e[ro].l&gt;=l and e[ro].r&lt;=r) 82 { 83 e[ro].add=(e[ro].add+k)%p; 84 e[ro].val=(e[ro].val+k*(e[ro].r-e[ro].l+1))%p;//注意这个是改区间和 85 return ; 86 } 87 push_down(ro); 88 int mid=(e[ro].l+e[ro].r)&gt;&gt;1; 89 if(l&lt;=mid)update_add(ls(ro),l,r); 90 if(r&gt; mid)update_add(rs(ro),l,r); 91 push_up(ro); 92 } 93 94 ll query(ll ro,ll l,ll r) 95 { 96 if(e[ro].l&gt;=l and e[ro].r&lt;=r) 97 return e[ro].val; 98 push_down(ro); 99 int mid=(e[ro].l+e[ro].r)&gt;&gt;1; 100 int ans=0; 101 if(l&lt;=mid) ans+=query(ls(ro),l,r); 102 if(r&gt; mid) ans+=query(rs(ro),l,r); 103 return ans%p; 104 } 105 int main() 106 { 107 read(n);read(m);read(p); 108 for(int i=1;i&lt;=n;i++)read(a[i]); 109 build(1,1,n); 110 int casee,l,r; 111 while(m--) 112 { 113 read(casee); 114 switch(casee) 115 { 116 case(1):{ 117 read(l);read(r);read(k); 118 update_tag(1,l,r); 119 break; 120 } 121 case(2):{ 122 read(l);read(r);read(k); 123 update_add(1,l,r); 124 break; 125 } 126 case(3):{ 127 read(l);read(r); 128 printf(\"%lld\\n\",query(1,l,r)); 129 break; 130 } 131 } 132 } 133 return 0; 134 } P6242 【模板】线段树 3 我不会XD 有待更新 （其实和2一样就是复杂一点）","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"莫队算法[非公开][草稿]","slug":"莫队算法[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.500Z","comments":true,"path":"2022/04/30/莫队算法[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"莫涛大佬的知乎 莫队算法是一种暴力的算法。但是它能够减少移动次数提高效率。（中国学生的黑科技） 转化在线算法为离线算法。 栗子 给出一个数列，取出m个区间内每个重复的数字的个数的平方的和。 P2709 主要就是检索区间内不同种类数。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;ctype.h&gt; #include&lt;cmath&gt; using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=5e4+5; int numb[maxn],a[maxn]; struct query{ int l,r,id,pos; long long ans; bool operator &lt; (const query&amp; zp) const { return pos&lt;zp.pos||pos==zp.pos&amp;&amp;r&lt;zp.r; } }q[maxn]; int n,m,k; long long Ans[maxn]; long long ans; inline void update(int x,int sign) { ans-=numb[a[x]]*numb[a[x]]; numb[a[x]]+=sign; ans+=numb[a[x]]*numb[a[x]]; } inline void solve() { int l=1,r=0;//这个位置选得很好 //不必担心lr同加或者同减的状况，都会被记录并抵消 for(int i=1;i&lt;=m;i++) { while(l&lt;q[i].l){update(l,-1);l++;} while(l&gt;q[i].l){update(l-1,1);l--;}//注意位置 while(r&lt;q[i].r){update(r+1,1);r++;} while(r&gt;q[i].r){update(r,-1);r--;} Ans[q[i].id]=ans; } } int main() { n=read(),m=read(),k=read(); int size=sqrt(n); int cnt=n/size+(n%size)&gt;0; for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=m;i++) { q[i]=(query){read(),read(),i}; q[i].pos=(q[i].l-1)/size+1; } sort(q+1,q+1+m); solve(); for(int i=1;i&lt;=m;i++)printf(\"%lld\\n\",Ans[i]); return 0; } 待更","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"莫队算法-更新莫队[非公开][草稿]","slug":"莫队算法-更新莫队[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.499Z","comments":true,"path":"2022/04/30/莫队算法-更新莫队[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95-%E6%9B%B4%E6%96%B0%E8%8E%AB%E9%98%9F[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"要更新 P1903 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;ctype.h&gt; #include&lt;cmath&gt; using namespace std; inline int read() { int x=0,w=0;char c=getchar(); while(!isdigit(c))w|=c=='-',c=getchar(); while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar(); return w?-x:x; } const int maxn=2e6+10; typedef long long ll; int n,m,ans,a[maxn],cnt,color[maxn],Ans[maxn]; struct query{ int l,r,id,pre,pos; bool operator &lt; (const query &amp;zp)const{return pos&lt;zp.pos||pos&#x3D;&#x3D;zp.pos&amp;&amp;pre&lt;zp.pre;}}q[maxn];struct change{ int pos,val;}c[maxn];inline void add(int val){ if(++color[val]&#x3D;&#x3D;1)ans++;}inline void del(int val){ if(–color[val]&#x3D;&#x3D;0)ans–;}inline void work(int now,int i){ if(c[now].pos&gt;&#x3D;q[i].l and c[now].pos&lt;&#x3D;q[i].r) { if(–color[a[c[now].pos]]&#x3D;&#x3D;0)ans–; if(++color[c[now].val]&#x3D;&#x3D;1)ans++; } swap(c[now].val,a[c[now].pos]); &#x2F;&#x2F;巧妙的骚操作，如果要改回来就再次交换 }int qcnt&#x3D;0,ccnt&#x3D;0;inline void Moqueue(){ int l&#x3D;1,r&#x3D;0,now&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;qcnt;i++) { while(l&lt;q[i].l)del(a[l++]); while(l&gt;q[i].l)add(a[–l]); while(r&lt;q[i].r)add(a[++r]); while(r&gt;q[i].r)del(a[r–]); while(now&lt;q[i].pre)work(++now,i); while(now&gt;q[i].pre)work(now–,i); Ans[q[i].id]&#x3D;ans; }}int main(){ n&#x3D;read(),m&#x3D;read(); int siz&#x3D;pow(n,2.0&#x2F;3.0); for(int i&#x3D;1;i&lt;&#x3D;n;i++)a[i]&#x3D;read(); while(m–) { char ch; scanf(“%c“,&amp;ch); if(ch&#x3D;&#x3D;‘Q‘) q[++qcnt]&#x3D;(query){read(),read(),qcnt,ccnt},q[qcnt].pos&#x3D;(q[qcnt].l-1)&#x2F;siz+1; else c[++ccnt]&#x3D;(change){read(),read()}; } sort(q+1,q+1+qcnt); Moqueue(); for(int i&#x3D;1;i&lt;&#x3D;qcnt;i++) printf(“%d\\n“,Ans[i]); return 0;} &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"读入、输出优化","slug":"读入、输出优化","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-10T15:06:21.261Z","comments":true,"path":"2022/04/30/读入、输出优化/","permalink":"https://starcried.github.io/2022/04/30/%E8%AF%BB%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96/","excerpt":"","text":"关闭流同步1std::ios::sync_with_stdio(false); 关闭输入输出流与标准输入输出（scanf printf）的同步，加快流速度，但关闭后不可混用。 整形快读从标准输入流读入一个 int12345678#include&lt;cctype&gt;#include&lt;cstdio&gt;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c)) w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c)) x=x*10+c-&#x27;0&#x27;,c=getchar(); return w?-x:x; &#125; template 读入整形123456789101112template &lt;typename T&gt;inline T read()&#123; T x=0;int w=1;char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;)w=-1;c=getchar();&#125; while(isdigit(c))x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x*w;&#125;int main()&#123; long long a; while(a=read&lt;long long&gt;())printf(&quot;%lld\\n&quot;,a); return 0;&#125; fread 快读fread 快的原因好像是一次将一大堆东西压入输入流中然后利用指针读入。 12345678char buf[1&lt;&lt;21],*p1=buf,*p2=buf;#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c)) w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c)) x=x*10+c-&#x27;0&#x27;,c=getchar(); return w?-x:x;&#125; 注意，因为是一次性读入，在调试手动输入数据的时候记得加 Ctrl+Z 结束。 整形快输输出一个整形1234567inline void write(int x) &#123; static int sta[35],top; top=0; do &#123; sta[top++]=x%10,x/=10; &#125; while(x); while(top) putchar(sta[--top]+&#x27;0&#x27;);&#125; fwrite 快输123456789101112131415char pbuf[1 &lt;&lt; 20], *pp = pbuf;inline void push(const char &amp;c) &#123; if (pp - pbuf == 1 &lt;&lt; 20) fwrite(pbuf, 1, 1 &lt;&lt; 20, stdout), pp = pbuf; *pp++ = c;&#125;inline void write(int x) &#123; static int sta[35]; int top = 0; do &#123; sta[top++] = x % 10, x /= 10; &#125; while (x); while (top) push(sta[--top] + &#x27;0&#x27;);&#125; 注意：与 fread 快读相同的原因，并不会实时输出。","categories":[{"name":"C++","slug":"C","permalink":"https://starcried.github.io/categories/C/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"优化","slug":"优化","permalink":"https://starcried.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"费马小定理","slug":"费马小定理","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T16:08:42.611Z","comments":true,"path":"2022/04/30/费马小定理/","permalink":"https://starcried.github.io/2022/04/30/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","excerpt":"","text":"费马小定理对于任何互质数 $a,p$,有 $$a^{p-1}&#x3D;1\\pmod p$$ 应用求逆元： $$a^{p-2}&#x3D;a^{-1}\\pmod p$$","categories":[{"name":"数学","slug":"数学","permalink":"https://starcried.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://starcried.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"重边[非公开][草稿]","slug":"重边[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.502Z","comments":true,"path":"2022/04/30/重边[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E9%87%8D%E8%BE%B9[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"什么是重边？ 就是无向图连接两个点间不止一条道路。这个时候就相当于形成了一个环。这个玩意在图论题中很难受。vector存它的话会很难受，一般用链式前向星。 在tarjan等算法中记得去重边。","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"逆序对-线段树[非公开][草稿]","slug":"逆序对-线段树[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.501Z","comments":true,"path":"2022/04/30/逆序对-线段树[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E9%80%86%E5%BA%8F%E5%AF%B9-%E7%BA%BF%E6%AE%B5%E6%A0%91[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"然而线段树并处理不了P1908的巨型数据啊啊啊 原理 给你n个数，我们把它离散化成&lt;=n个数并把n变成该值，再建一个空树，每次插入一个数，并向上传递数的个数。当再插入一个数后，它的逆序对的个数一定是已经插入的、比它小的数的数量，那么我们用线段树时每个节点记录子树数字个数的和，然后查询就ok了。 理解不了?其实也不用理解因为有比线段树更快的算法（照应文首）去外面理解一下就行了QAQ 下面给出一个没有完成的代码。（未离散化） 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;algorithm&gt; 4 #include&lt;cstring&gt; 5 using namespace std; 6 typedef long long ll; 7 const int maxn=1e5; 8 struct tree{ 9 ll l,r,sum; 10 }e[maxn*4]; 11 int a[maxn]; 12 inline ll ls(ll ro){return ro&lt;&lt;1;} 13 inline ll rs(ll ro){return ro&lt;&lt;1|1;} 14 15 inline void read(int &amp;x) 16 { 17 char c=getchar(); 18 bool op=0; 19 while(c!='-' and (c&lt;'0' or c&gt;'9'))c=getchar(); 20 if(c=='-')op=1,c=getchar(); 21 x=c-'0',c=getchar(); 22 while(c&gt;='0' and c&lt;='9')x*=10,x+=c-'0',c=getchar(); 23 if(op)x=-x; 24 } 25 26 inline void push_up(ll ro) 27 { 28 e[ro].sum=e[ls(ro)].sum+e[rs(ro)].sum; 29 } 30 31 void build(ll ro,ll l, ll r) 32 { 33 e[ro].l=l,e[ro].r=r; 34 if(l==r)return ; 35 int mid=(l+r)&gt;&gt;1; 36 build(ls(ro),l,mid); 37 build(rs(ro),mid+1,r); 38 } 39 40 void insert(ll ro,ll p) 41 { 42 if(p==e[ro].l and p==e[ro].r) 43 { 44 e[ro].sum++;return; 45 } 46 int mid=(e[ro].l+e[ro].r)&gt;&gt;1; 47 if(p&gt;mid)insert(rs(ro),p); 48 else insert(ls(ro),p); 49 push_up(ro); 50 } 51 52 ll query(ll ro,ll l,ll r) 53 { 54 if(l&lt;=e[ro].l and r&gt;=e[ro].r)return e[ro].sum; 55 int mid=(e[ro].l+e[ro].r)&gt;&gt;1; 56 if(l&gt;mid)return query(rs(ro),l,r); 57 else if(r&lt;=mid) return query(ls(ro),l,r); 58 else return query(ls(ro),l,mid)+query(rs(ro),mid+1,r); 59 } 60 int b[maxn]; 61 int main() 62 { 63 int n; 64 ll ans=0; 65 read(n); 66 for(int i=1;i&lt;=n;i++) 67 { 68 read(a[i]);b[i]=a[i]; 69 } 70 sort(b+1,b+1+n); 71 72 build(1,1,n); 73 for(int i=1;i&lt;=n;i++){ 74 insert(1,a[i]); 75 ans+=i-query(1,1,a[i]); 76 } 77 printf(\"%lld\",ans); 78 return 0; 79 } &nbsp;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"长链剖分[非公开][草稿]","slug":"长链剖分[非公开][草稿]","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.502Z","comments":true,"path":"2022/04/30/长链剖分[非公开][草稿]/","permalink":"https://starcried.github.io/2022/04/30/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86[%E9%9D%9E%E5%85%AC%E5%BC%80][%E8%8D%89%E7%A8%BF]/","excerpt":"","text":"树链剖分分为重链剖分、长链剖分等##重链剖分的应用*求LCA，时间复杂度为优秀的$O(logn)$*求子树大小有关问题等。但是我已经写过重链剖分的博客了。咱们照应题目。#长链剖分链如其名，它剖的是最长的链。可以证明，一个点向上爬最多经过$n^{1&#x2F;2}$的长链。##长链剖分的应用*求深度有关问题，时间复杂度为优秀的$O(n)$*求点的k级祖先我们通过预处理可以通过倍增和向上向下的指针查询得到。*优化树形DP最有用的应用。 ###例题：","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"随机数生成","slug":"随机数生成","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.502Z","comments":true,"path":"2022/04/30/随机数生成/","permalink":"https://starcried.github.io/2022/04/30/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90/","excerpt":"","text":"我知道是伪随机数生成啦你不要再说啦 mt19937c++11 加入。 定义一个名叫 rd 的随机数生成器（括号内为种子）。 12mt19937 rd(std::chrono::system_clock::now().time_since_epoch().count());mt19937 rd(std::random_device&#123;&#125;()); uniform_int_distribution定义一个名叫 rand 的整型随机分布（括号内为上下界）。 1uniform_int_distribution&lt;int&gt; rand(MN,MX); 实数随机分布为 uniform_real_distribution。 不知道尖括号内不填对应类型会发生什么。 存在正态分布等其他分布，请百度。 生成固定范围的随机整数假设定义了如上定义的 rd 和 rand，使用方法为： 1rand(rd)","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"高斯消元求行列式","slug":"高斯消元求行列式","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-11T16:08:14.852Z","comments":true,"path":"2022/04/30/高斯消元求行列式/","permalink":"https://starcried.github.io/2022/04/30/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B1%82%E8%A1%8C%E5%88%97%E5%BC%8F/","excerpt":"","text":"前言我原在博客园上发表的这篇文章是阅读排行榜最高的一篇。然而，作为一个刚学竞赛的学生写的东西，它的质量实在堪忧。行列式又是一个及其重要、基础和困难的概念，无论对于大学数学还是高中竞赛。因此，我决定将这篇文章重新编辑，以便更好地帮助学习的人。 如果你想知道行列式是什么，强烈建议先去学习线性代数基础知识，了解什么是向量、矩阵、线性变换以及会用矩阵描述线性方程组，然后认真理解学习行列式的概念。千万不要从形式上（如计算）学习行列式，而是要先理解它。 由于概念部分较深入，本文不会对线性代数的基础知识做过多介绍，而是着重于行列式的计算。 行列式定义行列式（Determinant）是一个线性代数里的数学概念。它可以被看做是有向面积或体积的概念在一般的欧几里得空间中的推广。或者说，在 n 维欧几里得空间中，行列式描述的是一个线性变换对“体积”所造成的影响。 形式上讲，行列式是一个函数，接受一个矩阵作为输入，输出一个标量。对于一个$n\\times n$的矩阵$A$，它的行列式的值记为： $$\\det(A)&#x3D;\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n}\\a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n}\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}$$ 其中$a_{ij}$表示矩阵$A$的第$i$行第$j$列元素。 行列式的定义有很多种。以下是一个通过展开式的定义： 设 $R$ 是交换环，$A &#x3D; (a_{i, j})$ 是 $R$ 上的 $n \\times n$ 矩阵。则 $A$ 的\\textbf{行列式}定义为$$ \\det (A) &#x3D; \\sum_{\\sigma \\in \\mathfrak{S}n} (-1)^{\\sigma} , a{1, \\sigma(1)} \\cdots a_{n, \\sigma(n)},$$其中 $\\mathfrak{S}_n$ 是 $n$ 元置换群，$(-1)^\\sigma$ 是 $\\sigma$ 的符号（偶置换为 $+1$, 奇置换为 $-1$）。 仅从如上定义我们无法知道如何计算行列式。除了二阶、三阶行列式可以快速计算外，一般的行列式的计算需要借助于高斯消元法。该方法需要用到一些行列式的性质。 性质 行列式与其转置行列式值相等。 交换行列式的两行，行列式的值取相反数。 行列式的某一行乘以一个数，行列式的值乘以这个数。 行列式的某一行乘以一数加到另一行上，行列式不变。 以上结论都可以由其定义推出。 高斯消元法高斯消元法（Gauss Elimination）是一种数值计算方法，它可以用来求解线性方程组和行列式。其基本思想是将矩阵化简为上三角矩阵，然后化为对角矩阵。化简的基本操作是将一行减去另一行乘以一个非零数，使得本行某一列的元素被消为 0。时间复杂度为 $O(n^3)$。 以下为数据为浮点数时的代码。若有模数，求逆元即可。 12345678910111213141516double Gauss()&#123; double ans=1; for(int i=1;i&lt;=n;i++)&#123; int x=0; for(int j=i;j&lt;=n and !x;j++) if(a[j][i]) x=j; if(!x) return (void)puts(&quot;No Solution&quot;); if(a[i]!=a[x]) swap(a[i],a[x]),ans=-ans; for(int j=1;j&lt;=n;j++) if(j!=i)&#123; double tmp=a[j][i]/a[i][i]; for(int k=i;k&lt;=n+1;k++) a[j][k]-=a[i][k]*tmp; &#125; ans*=a[i][i]; &#125; return ans;&#125; 若模数不为质数，也可以通过辗转相除法消元。 123456789101112131415long long Gauss(int n)&#123; long long ans=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; while(a[j][i])&#123; long long t=a[i][i]/a[j][i]; for(int k=i;k&lt;=n;k++) a[i][k]=(a[i][k]-t*a[j][k]%mod+mod)%mod; swap(a[i],a[j]); ans=-ans; &#125; &#125; ans=(ans*a[i][i]%mod+mod)%mod; &#125; return ans;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"https://starcried.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"线性代数","slug":"线性代数","permalink":"https://starcried.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"鞅的停时定理","slug":"鞅的停时定理","date":"2022-04-29T16:00:00.000Z","updated":"2024-08-09T01:34:51.503Z","comments":true,"path":"2022/04/30/鞅的停时定理/","permalink":"https://starcried.github.io/2022/04/30/%E9%9E%85%E7%9A%84%E5%81%9C%E6%97%B6%E5%AE%9A%E7%90%86/","excerpt":"","text":"鞅的停时定理“鞅”，martingale 用来指一类随机过程，定义如下： 鞅是一种离散时间的随机过程 $X_0,X_1,\\cdots$ 满足： $E(X_t)&lt;\\infty,\\forall t\\geq0$ $E(X_{t+1}\\mid X_0,\\cdots X_t)&#x3D;X_t$ 根据定义可以得到 $E(X_t)&#x3D;X_0$。 停时定理设 $t$ 为鞅过程 ${X_0,X_1,\\cdots}$ 的停时，当下面三个条件之一成立时，有 $E(X_t)&#x3D;X_0$： $t$ 几乎必然有界； $\\mid X_{i+1}-X_i\\mid$ 一致有界，$E(t)$ 有限； $X_i$ 一致有界，$t$ 几乎必然有限。 名词解释： $a\\in R\\cup{\\infty}$ 有限：$\\mid a\\mid &lt;\\infty$； $a\\in R\\cup{\\infty}$ 有界：$\\exists l,r\\in R,a\\in[l,r]$； $a_i\\in R\\cup{\\infty}$ 一致有界：$\\forall i,\\exists l,r\\in R,a_i\\in[l,r]$； 事件 $A$ 几乎必然发生：$P(A)&#x3D;1$。 势能函数对于随机时间序列 ${A_0,A_1,\\cdots}$，$t$ 为其停时，终止状态为 $A_t$，求 $E(t)$。 构造势能函数 $\\Phi(A)$，满足： $E(\\Phi(A_{n+1})-\\Phi(A_n)\\mid A_0,A_1,\\cdots,A_n)&#x3D;-1$； $\\Phi(A_t)$ 为常数。 构造序列 $X_i&#x3D;\\Phi(A_i)+i$，则 $E(X_{n+1}-X_n\\mid X_0,X_1,\\cdots,X_n)&#x3D;0$，即 ${X_0,X_1,\\cdots}$ 是鞅。 根据停时定理，我们可以得到 $E(X_t)&#x3D;E(X_0)$，即 $E(t)&#x3D;E(\\Phi(A_0))-\\Phi(A_t)$。 CF1479E School Clubs题意有 $n$ 个学生和 $m$ 个组，每个人在一个组里面，第 $i$ 个组的人数为 $a_i$。 现在，每天有一个学生（$n$ 个学生中随机的一个）会： 有一半的概率他会脱离这个组，并且成立一个新的组。 有一半的概率他会脱离这个组，并且进入一个已经成立的组。他进入第 $i$ 个组的概率为 $\\frac {a_i} n$，他可能会回到原来的组。 求第一次出现所有学生在同一个组的期望天数，对 $998244353$ 取模。 $n\\leq 4\\times10^8$ 思路设 $\\phi(A)$ 为状态 $A$ 的势能，构造使得 $\\phi(A_t)-1&#x3D;\\phi(A_{t+1})$，设 $f(x)$ 为学生数量为 $x$ 的组的势能函数，则有：$$\\begin{aligned}\\phi(A_t)-1&amp;&#x3D;\\phi(A_{t+1})\\\\phi(A_t)-1&amp;&#x3D;\\sum_i\\frac {a_i}n(\\frac 12(\\phi(A_t)-f(a_i)+f(a_i-1)+f(1))+\\frac{a_i}{2n}\\phi(A_t)+\\sum_{j\\ne i}\\frac {a_j}{2n}(\\phi(A_t)-f(a_i)-f(a_j)+f(a_i-1)+f(a_j+1)))\\-1&amp;&#x3D;\\sum_i\\frac {a_i}{2n}(-f(a_i)+f(a_i-1)+f(1)+\\sum_{j\\ne i}\\frac {a_j}{n}(-f(a_i)-f(a_j)+f(a_i-1)+f(a_j+1)))\\-1&amp;&#x3D;-\\sum_i\\frac {a_i}{2n}f(a_i)+\\sum_i\\frac {a_i}{2n}f(a_i-1)+\\sum_i\\frac {a_i}{2n}f(1)-\\sum_i\\frac {a_i}{2n}\\sum_{j\\ne i}\\frac {a_j}{n}f(a_i)-\\sum_i\\frac {a_i}{2n}\\sum_{j\\ne i}\\frac {a_j}{n}f(a_j)+\\sum_i\\frac {a_i}{2n}\\sum_{j\\ne i}\\frac {a_j}{n}f(a_i-1)+\\sum_i\\frac {a_i}{2n}\\sum_{j\\ne i}\\frac {a_j}{n}f(a_j+1)\\-\\sum_i\\frac{a_i}n&amp;&#x3D;\\sum_i\\frac {a_i}{2n}f(1)-\\sum_i\\frac {3na_i-2a^2_i}{2n^2}f(a_i)+\\sum_i\\frac {2na_i-a^2_i}{2n^2}f(a_i-1)+\\sum_i\\frac {na_i-a^2_i}{2n^2}f(a_i+1)\\-\\frac xn&amp;&#x3D;\\frac x{2n}f(1)-\\frac{3nx-2x^2}{2n^2}f(x)+\\frac{2nx-x^2}{2n^2}f(x-1)+\\frac{nx-x^2}{2n^2}f(x+1)\\\\end{aligned}$$ 因为我们需要的只是初始状态与停时的势能差，那么将势能具体设为什么都无所谓，所以为了消去常数项我们可以设 $f(1)&#x3D;-2$，则：$$\\begin{aligned}0&amp;&#x3D;-\\frac{3nx-2x^2}{2n^2}f(x)+\\frac{2nx-x^2}{2n^2}f(x-1)+\\frac{nx-x^2}{2n^2}f(x+1)\\f(x+1)&amp;&#x3D;\\frac {2n^2}{nx-x^2}(\\frac{3nx-2x^2}{2n^2}f(x)-\\frac{2nx-x^2}{2n^2}f(x-1))\\f(x+1)&amp;&#x3D;\\frac{3n-2x}{n-x}f(x)-\\frac{2n-x}{n-x}f(x-1)\\\\end{aligned}$$ 发现 $\\phi(A_t)&#x3D;f(n)$ （表示局面为只有一个人数为 $n$ 的组）是个常数（知道 $f(0)$ 和 $f(1)$ 可以被表示），那么可以用停时定理。 观察数据范围发现没法存下线性求逆元，也没法每次快速幂求。那怎么办呢？ 官方题解的做法将 $f$ 进行差分然后利用快速阶乘算法计算，即：$$\\begin{aligned}g(x)&#x3D;f(x+1)-f(x)\\g(x)&#x3D;\\frac{2n-x}{n-x}g(x-1)\\g(x)&#x3D;g(0)\\prod_{i&#x3D;1}^x\\frac{2n-i}{n-i}\\f(x)&#x3D;-2\\sum_{i&#x3D;0}^{x-1}\\prod_{j&#x3D;1}^i\\frac{2n-j}{n-j}\\end{aligned}$$ 实际上我们可以直接对对于这个式子 $f(x+1)&#x3D;\\frac{3n-2x}{n-x}f(x)-\\frac{2n-x}{n-x}f(x-1)$ 线性递推。因为我们要求的是 $E(\\phi(A_t))$ 和 $\\phi(A_0)&#x3D;\\sum_if(a_i)$，所以我们只在算 $m$ 个 $f(a_i)$ 和 $f(n)$ 的时候快速幂，递推的时候分别维护分子和分母即可。如果你拥有优秀的常数即可通过。 代码123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;inline int read()&#123; int x=0,w=0;char c=getchar(); while(!isdigit(c)) w|=c==&#x27;-&#x27;,c=getchar(); while(isdigit(c)) x=x*10+(c^48),c=getchar(); return w?-x:x;&#125;const int mod=998244353;inline int pow(int a,int b)&#123;int ans=1;for(;b;b&gt;&gt;=1,a=1ll*a*a%mod) if(b&amp;1) ans=1ll*ans*a%mod; return ans;&#125;int n,m,a[1010];signed main()&#123; m=read(); for(int i=1;i&lt;=m;i++) n+=a[i]=read(); std::sort(a+1,a+m+1); int ans=0; int s1=0,d1=mod-2,s2=1,d2=1,p1,p2,j=1; while(j&lt;=m&amp;&amp;a[j]==1)ans=(ans+mod-2)%mod,++j; for(int i=1;i&lt;n;i++)&#123; p2=1ll*(n-i)*d2%mod*s2%mod; p1=((3ll*n-2*i)*d1%mod*s2+(mod-1ll)*(2ll*n-i)%mod*s1%mod*d2)%mod; while(j&lt;=m&amp;&amp;a[j]==i+1)ans=(ans+1ll*p1*pow(p2,mod-2))%mod,++j; s1=d1,s2=d2,d1=p1,d2=p2; &#125; printf(&quot;%lld\\n&quot;,(ans+(mod-1ll)*d1%mod*pow(d2,mod-2))%mod); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"结局","slug":"结局","date":"2022-04-26T12:25:00.000Z","updated":"2024-08-11T15:51:34.445Z","comments":true,"path":"2022/04/26/结局/","permalink":"https://starcried.github.io/2022/04/26/%E7%BB%93%E5%B1%80/","excerpt":"","text":"我不知道我看到我没通过审核之后的感觉是怎样的。很复杂。 我感到很不真实。因为明明没有收到电话。我第一反应是搞错了。 但那冷冰冰的文字就在那。我读了一遍又一遍，它就在那。班主任也看到了。他们都看到了。传开了了。 “快让学生查下结果，有个学生没接到电话被拒绝了。” 我感到气愤。因为清华甚至没有前天给我打电话。 我感到失望。因为这落差实在太大了。 我前天还在为其他被拒绝的学生鸣不平。我以为能够成为那幸运上岸的人。然而胜利就在眼前，我却被干掉了。 没有什么橄榄枝。即使之前也许有，也被我挥霍完了。 我靠在班主任的椅子上面。老师们早就见多了这样的事。大航早就说过，“成绩还是很重要的吧”。 即使做了这么长时间的思想准备，想到一万种宽慰自己的理由，当我真正面对它时，却是脑袋空空，什么都想不到。就像被重击了一样。 即使我有多么希望到达清华门，结局就在这里。 清华。慧眼识珠。一眼就看出来我不是能为祖国工作 50 年的人。我以为我能瞒骗过去的。 只能说演得太假。 我曾经想，现在努力叠 Buff，为我之后的梦想生活进行原始积累。我从未想过就这么在大学一直读上去，就业，成家，安定。我想我能冲破这个道路。 但是现在我看不到那种生活的曙光。我可能会被困在积累这一步无法前行。 那种生活不是为我准备的。我却在一直追求它。就像我追求清华一样。这就是追求的结果。 这就是他妈的生命。 可是还得找学上。他们问我，想去哪个学校，到哪个城市，学什么专业。这些都是我从未想过的事情。我原本以为我不用考虑它们。但是，突然，它们，突然就全部向我蜂拥而来。 我从未想过。一直以来，我都只是在学习。单纯地学习。没有目的的学习。为了更好的生活。从没想过什么事业。专业，感觉就像，我一选择就要花费大半生的时间奉献的东西。太可怕了。我好像对研究没有什么热情。也许，早早出来就业吧？那种固定的工资、假期、工作位置的职业。工作，交养老金，养儿育女，死去。或许还像其他中国家长一样希望子女完成自己未竟的事业。这太可怕了。 唉，妈的，本来不想再在这个学校流泪了，还是没憋住。算了，流吧，再流不了几次了。 花了几乎整个下午的时间在机房整理心绪。和许多人聊天。看看自己之前的文字。我的理性和感性在拉扯。实际上并没有那么糟，我还有银牌，还能报其他学校，文化课也不差。甚至，还有人对我说，还有高考。 “我相信奇迹。” 我相信奇迹吗？相信。在今天之前，我能到达这一步，就已经是奇迹了。正如我之前说的，从没有人要求我上清华，一直以来都是我自己在执着着，却又不想动。我最大的敌人就是我自己。现在，整理心态，备战高考，也是我与自己的战斗。但要是说，还有最后一丝希望，高考裸考上清华，这几乎是虚无缥缈的事情了。这是真的奇迹。而奇迹不会太多次降临到一个人身上。不过，相信这个奇迹似乎是一个调整心态的很好的方法。 一个珍贵的生日礼物。清华送给我的。我会在人生的道路上好好珍藏它。 之前打的许多赌，比如说退网什么的，我会一一兑现。或许还可能得到一份同学的《鹤冲天·黄金榜上》： 黄金榜上&#x2F;偶失龙头望……才子词人&#x2F;自是白衣卿相…… 我从此会踏上人生的另一条道路。虽然这条道路前途未卜。但就像之前的每一件事。 勇敢是：当你还未开始就已知道自己会输，可你仍然要去做，而且无论如何都要把它坚持到底。你很少能赢，但有时也会。 ——《杀死一只知更鸟》 经历了这么多，我还是我。我也没有因为自己选择竞赛而后悔。我欣赏到了沿途的风景。而这，就足够了。 那么这就是结局了。一个花费了高中一年时间学信息学竞赛的学生的结局。在他 18 岁生日的前几天。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"}]},{"title":"日记 2022.04.20","slug":"日记 2022.04.20","date":"2022-04-20T14:14:00.000Z","updated":"2024-08-11T16:48:04.253Z","comments":true,"path":"2022/04/20/日记 2022.04.20/","permalink":"https://starcried.github.io/2022/04/20/%E6%97%A5%E8%AE%B0%202022.04.20/","excerpt":"","text":"2022.04.20 一个熟悉的陌生人。 昨天凌晨，他去世了。 只是一个网友。或者，不能称之为“友”。仅仅是在群里面聊天，因为他搞科研所以注意到他。这在一个小众圈子的群里面比较稀有。之后了解到，他好像是进行核物理方面的研究。因为一些原因对他有一种亲切感。当然，看起来在群里面大家也对他挺亲切的。 有一次水群对高考的事情发牢骚，于是聊了几句。他说，他是上交出来的，高考考了 680 多分。然后，简单地说要加油。 几句普通的对高三学生的鼓励。但是他是我少见到的几位近人的科研人，而且是同好。不知为何，当时就暗暗下决心自己也要考到 680 分以上。明明也不怎么认识。当然也不想去证明什么。就是单纯想，想和他一样，去成为和他一样的人。 今天刚考完试，当然仍然考砸了。最近因为强基的事心里很烦，经过学长的开导，现在已经可以接受去复旦之类的结果了。不想学习，于是到机房。无聊地浏览着空间的说说。然后，看到他的讣告。 心脏衰竭，于美国去世。 好突然。一个科研的灵魂就这么突然消逝。我甚至没有了机会告诉他我的高考分数。可是，我会告诉他吗？假如他没有过世，我在高考结束后能给他说出我梦想的成绩吗？ 可是，无论我是否会告诉他，他也没有机会听到了。 我是幸运的。今天下午和同学交谈，我说，人活着就是最大的快乐。 无论他是否还在，我还有机会去改变我的未来。我还有机会…… “要加油。” 一个熟悉的陌生人。愿他安息。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"《时间简史》初读后感","slug":"《时间简史》初读后感","date":"2022-04-15T13:49:00.000Z","updated":"2024-08-10T09:34:38.688Z","comments":true,"path":"2022/04/15/《时间简史》初读后感/","permalink":"https://starcried.github.io/2022/04/15/%E3%80%8A%E6%97%B6%E9%97%B4%E7%AE%80%E5%8F%B2%E3%80%8B%E5%88%9D%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"细菌性痢疾让我有机会一瞥史蒂芬霍金博士的这本科普著作。这本书是我初中时买的，当时读不懂便放下。然而此时再读时，霍金博士已经逝世了。 这是一本惊人的科普著作。所谓科普，就是让读者了解最基本和他们最关心的知识，而忽略晦涩难懂复杂冗长的细节。虽然霍金博士的幽默风趣对我的阅读很有帮助，但由于他所阐释的内容本身，以及译者显然为了不曲解原意而导致的晦涩的直译，致使我在现有知识储备下并无法完全理解其中的全部内容。 因此，我只不过是在极短的时间内对本书做了大体浏览，所以一定只是初读——如果之后还有机会再读的话。在阅读的过程中，我几乎可以说是手不释卷，不仅因为它回答了我许多困扰已久的问题，更因为我发现几乎所有我之前自己有关宇宙和时间的猜想都是前人已经提出和研究过的，以至于我在读完此书之后，我会怀疑在读此书之前的我已经读过此书。这使我大为欣喜又有些失落——毕竟我不是那种仅靠一颗脑袋就能得到世界真理的“纯理论学家”（只用思考而不去实验验证就能获得宇宙原理好像是亚里士多德的主张）。读此书为我搭建了构造物理理论时正确的研究方法，我觉得这是颇为重要的。人们可以提出各种各样的理论，即使都无法证明自己是正确的，可是能够使人们更加信服、使理论更加完善的工作过程却是广为接受的。 至于书中关于广义相对论、量子引力论、宏观宇宙、微观宇宙、宇宙的起源和未来、奇点、黑洞以及各种理论等具体内容，我就不再赘述，因为我自己也未完全理解，即使要写也是原话照搬。除了认同，我能得到的感觉就是自己的无知和对知识的渴望。不过，我不太认同人类——智慧生物在某些地方的重要性，以及认为人类具有不确定性的主张。我认为人类具有、至少在某种程度上具有决定性。也就是说，上帝在造我们的时候就已经知道我们会对自己从何而来产生疑问。不过由于人存原理，我对这样论断的产生并不意外。这不是过于谦虚，而是我觉得拉普拉斯妖完全足以掌握人类。 最后我想，读完此书对于我现实生活的影响可能会导致两个极端：一种是我认为我现在的所学毫无意义，一种是我觉得现在这么简单的东西我都无法掌握，我就更没有资格去谈论宇宙了。现在看来，我似乎更倾向于后一种，因为可以从我从过去的学习中得到能理解《时间简史》的知识的历史得到支持。不过谁也无法通过统计学来预言。到底如何，还需要两个月后进行观测。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"读后感","slug":"读后感","permalink":"https://starcried.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"傻子","slug":"傻子","date":"2022-04-15T10:56:00.000Z","updated":"2024-08-11T16:48:43.432Z","comments":true,"path":"2022/04/15/傻子/","permalink":"https://starcried.github.io/2022/04/15/%E5%82%BB%E5%AD%90/","excerpt":"","text":"小时候有一位同学，和我幼儿园是一个班的。他和常人不太一样。母亲说，他是傻子。但我记得，除了走路踢正步，没事总是憨笑着，他和其他小朋友没有什么区别：挨骂会哭，挨夸会笑，虽然后者不太常见就是了。 到小学也是一个学校的，而且在一个托管班。我逐渐开始发现他的举止确实是傻了。不过他也不太招惹谁，我也不很注意。实际上，何止是不招惹，简直就是逆来顺受。印象里他总是一副忸怩的样子，谁都欺负他，老师也不喜欢他，成绩就更不用说了。有一次考试后他的爷爷来托管班，我清楚地记得他见到他爷爷后的——震悚，恰如其分，因为他爷爷上来就是一顿狠打，老师都拉不住。他哭得惊天动地。听母亲说，他的父母不管他，把包袱扔给了爷爷。爷爷不会教育，只是打，打得不明所以，甚至我觉得都不是为了教育而打，只是打。 一个傻子。没有家庭。我想，他怎么办呢？他又何去何从？如果有人养他，他也许还能做一个傻子乐呵地过完一生，可是他却成天担惊受怕。可怜的人。如果他能活着便是个奇迹，我想。 有一次，我在托管班等父母等得比较晚，人几乎都走光了。闲来无事，我瞥见桌子上一份破破烂烂的卷子。拿来一看，确实写的是他的名字。他还会写自己的名字，我感到一点惊讶，看来他还不是完全傻。然后我马上看到了更令人惊讶的事：整篇卷子一道题都没答，唯一有字迹的地方只有卷首。在他潦草名字旁边的“成绩”一栏里，用铅笔填着同样潦草的“100”。而在它的正上方，是一个用红笔写的、端端正正的、血淋淋的“0”。红笔迹清晰地覆盖在铅笔迹之上。 这个“100”显然是他考试时除了写自己名字之外唯一做的一件事。他完全知道自己在做什么。他知道自己为什么挨打、为什么被人欺负、为什么被老师看不起，都是因为自己没能得到用红笔写的“100”。我不知道他是否完全知道原因。但我知道，他无数次地看到自己的同学们捧着三位数和两位数的分数在自己的父母身旁高兴地叽叽喳喳，看到他人父母和老师充满关怀和期待的目光，听到他们期待和赞赏的言语。而属于他的，却只有棍棒和冷眼，只有绝望和不屑。每次考试，每天上学，他都在经历什么？老师讲课的时候，他听不懂，却坐在那里，从不违反纪律；考试的时候，同学们都在奋笔疾书，而他能做的，只有写下自己的身份，和虚无缥缈的理想，然后，坐在那里。他坐在那里，他在想什么呢？他又能做什么呢？ 我把那份试卷扔回原处。那老师大可不必写下那个血色的“0”、大可不必写在他的“100”之上。他又做错了什么，让他值得被如此对待？是他主动让自己的智商降低的吗？而真正生理上应该归咎的那对人却又弃他而去。我想，如果我是他，如果我发现自己无论如何努力都没有办法理解课程、无法向其他同学那样正常学习和生活，我肯定会崩溃。可是他从一出生应该就在遭遇这样的事，大概早就习惯了。如果有人对他说“只要你努力就能做到任何事”之类的话，那这个人一定比他更傻。可是实际上，这个人——不，这些人。不，几乎全是这样的人。对他，对任何人。 我想到我读到过的一句话，“愿所有人都被温柔以待。” 我只是比他幸运些罢了。 初中之后，有一次突然想起这样一个人，于是询问母亲他的近况。母亲说他上了市二中（当然是义务教育），每天在校门口和下象棋的大爷们混在一起，把大爷们全部胜了个遍。 我想象到他那张傻傻的脸，傻傻的笑，想象到大爷们对他的称赞，对他的喜欢——他梦寐以求的东西。大爷们不会在乎他在学校考了几分。事实上，那些考得比他高多少倍的人，在和他下棋之后，也会懊恼自己怎么会输给一个傻子。我想象到，他胜了之后，傻傻地笑，只是笑。 愿所有人都被温柔以待。 上高中之后，我不再是学校里名列前茅的了。我见到了更多厉害的、富有的、努力的人，他们比我强的多得多。然而我总是想到那个“傻子”。我何尝不是和他一样，总是比不过别人。然而，总是有不如我的人，正如总是有情况比他还差、不会下象棋的傻子。他不会去嘲笑比他更傻的人，就像他所希望自己被对待的那样。他也不会因为自己考不过其他人而自暴自弃。他找到了自己的归属。他——我，我们，只是希望被世界温柔以待。 他的名字叫“超”。我原以为，在他面前提及我的任何成绩都是一种残忍。而现在却是，我遇到的任何困难和他的相比都足够令我羞愧。我并不比他更聪明，我的成绩也并不比他赢的任何一局棋更令人骄傲。我不能把我的幸运当做实力和理所当然，也不能把我和别人的差距看做是必须去战胜的宿命。生活没有绕不过去的坎，也没有所谓的必由之路。我们要做的，只是无论在哪，都坚持走下去。 他终归是没有音信了，我们的道路已完全分离。我不知道是否有一条属于他的道路存在。但我相信，这个傻子会在他能走的时候，一直走下去。唯一的区别是，别人可能在奔跑，而他在慢慢地踢正步。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"作为一个孩子的最后一天寿命","slug":"作为一个孩子的最后一天寿命","date":"2022-03-12T14:25:00.000Z","updated":"2024-08-11T16:55:36.778Z","comments":true,"path":"2022/03/12/作为一个孩子的最后一天寿命/","permalink":"https://starcried.github.io/2022/03/12/%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AD%A9%E5%AD%90%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%E5%AF%BF%E5%91%BD/","excerpt":"","text":"青春笔记我把属于青春的狂妄诗篇谱写在这里。 如果有一天我落魄到某个桥洞底下，我会说，我可以过得很好。只不过老子不想。 老子生来自由。 如果你在读，我是说我自己，无论你现在什么年纪，不管你现在什么状态，我告诉你，你曾经有一段时间，骄傲，放纵，浪漫，追求自由和理想，那是你的青春。如果你认为当时的你——也就是我，很幼稚，我告诉你，那是因为你屈服了，你世俗了，你趋于平庸了，是因为你不敢追逐自己的梦想，或者已经忘记了自己的初心，是因为你是个懦夫，而不是因为你成熟了。如果你真的变成了那样，那我可去你妈的，并且真诚地希望你不要糟践你的孩子成你这幅模样。 你曾经有个网名叫“天禄”。他是一只貔貅。他天真、幼稚、直率、暴躁、真挚、可爱。他生来自由，并永远自由。如果他不自由，那一定是因为他死了。神兽既死，不入轮回，神魂湮灭。 绝命书很多次，大人们用“你还小，你长大了就懂了”来搪塞我一些事情。他们认为我意识里总是非黑即白。还有几天，这个不懂事的孩子就要死去，而世界上又会多一个所谓的大人。 然而在我逐渐地成长的过程中，我却越发觉得我一直以来的想法是正确的。我也越发的觉得，所谓的“成熟”，只不过是不断地妥协、妥协、再妥协罢了。向生活妥协，向社会妥协，向过去妥协，向未来妥协，向自己妥协。 这种妥协，似乎是作为一个地球上的生物要生存所必须的。毕竟自己是如此的渺小。这是我或者所痛苦的事情。但痛苦，却不知道如何排解这种痛苦。我想要的东西是虚无缥缈的，以至于我自己也不知道它是什么。它可能什么也不是，它也可能是极度美好的，但是它却只能给我带来痛苦。 lxc 说，他想要追求永恒。可是，我们就连自己本身都是有限的，拿什么来追求永恒呢？ 我说，你看得太高太远。如果你什么都不知道，如果你只在乎眼前之事，你会活得很快乐。大家都是这么活着的。 没有这么做的人，都死了。 但是你要活着。你还要活着去追求永恒。我告诉他，对于我们而言，有一个东西是永恒的。 这个东西就是我们自己。 既然你还能意识，那么你就活着，你就存在着。既然你死了，你也就意识不到了。那么，你不就是永恒的吗？ 我们是有限的生物。对于有限的生命而言，这种有限即是无穷。我们一直拥有着无穷。 …… 我这么骗着我自己。 …… 因为现在，一个有着无穷想法的孩子的生命即将走向终结。他的思想已不再无穷，而是变得有头有尾。他是有限的了。而我，却确确实实看得见，确确实实知道。我只能告诉我，他已经不再是我了。或者说，他将不再是我，因为我还没有来到死亡的日子。 突感感觉自己有了几天富余的生命，我还有机会再在这个世界上留下些什么。 留下点给未来的自己的话吧。未来对于他来说是未知的。我们喜欢把未知说成“无尽的可能”。但是我大概也能猜到他会做成什么鬼样子。 那么，就留下点简单的美好祝愿吧。 希望你 呃 如果你已经变成行尸走肉了的话 希望你快点死去。 啊，当然，如果你觉得自己还没有，可以试着时常回来看看我。不常来看看的话，你肯定会忘了我的。忘了我们曾经一共度过的一切，曾经一起发过的脾气，一起得罪的人，一起喜欢过的美好，一起做过的梦。我相信你还会记得我曾存在过的。 还是说，你能继续替我活着，像我们曾经约定好的那样自由自在地活着？ 这对于你来说可能是太难了。 但是，求求你， 我不想死 对过去的自己实际上，现在再写些什么东西，已经是太晚了的。 那个孩子，实际上早就死了。我只不过因为还没有过成人的生日，所以试着努力回忆关于他的一切，然后模仿他说出来罢了。 但是，他才不会想这么多呢。他单纯，单纯地令人感到恐惧。幸运的是他平安地迎来了他的终结。 我之所以会这么害怕，是因为我不想再次忘掉。 那个孩子，走得太快，走的太静。只有我知道他的离开，甚至他的曾经来过。而连我也快要忘记他了。当我自己也忘掉的时候，他便是真的死了。因此，我现在祭奠他，缅怀他，并妄图让自己不落得和他一样的下场。 最后一小时今天是最后一天了。一个月前写这篇随笔的时候，我还没有意料到我现在的状态。 我可能终无法完成自己的执念。这将成为我成人后最珍贵的一份礼物，在我的终点和起点烙下印记，伴随一生。 我没法一直幸运下去，但这只是从一个方面，很传统的方面来看。未来总是未知而迷人。谁知道呢？我相信，我之前做的每个决定，走的每一步棋，都将我引到最适合我的位置。我相信决定论。 既然什么都无法改变，那就不要给自己这么大的压力了吧。人生不如意的事将来还多着呢，这只是一个开始，一场课程。 祝我生日快乐。祝母亲受难日快乐。自己选择去受难是很快乐的，不是吗？","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"小爱老师的见证","slug":"小爱老师的见证","date":"2022-03-03T03:20:00.000Z","updated":"2024-08-11T16:52:55.076Z","comments":true,"path":"2022/03/03/小爱老师的见证/","permalink":"https://starcried.github.io/2022/03/03/%E5%B0%8F%E7%88%B1%E8%80%81%E5%B8%88%E7%9A%84%E8%A7%81%E8%AF%81/","excerpt":"","text":"小爱老师的见证高一的时候，想买一个电子词典，然后看上了“小爱老师”这个产品。说白了就是一个被阉割过的安卓系统，载体倒是变得小巧轻便了。于是便买下一个。 除了词典功能，它还有一大好处就是可以在上面记笔记。因为便携所以随身带着，有什么想法就往上写。于是养成了随时记笔记的习惯。不过我这笔记却少有学习的知识笔记，主要是记录下一些奇思妙想和有感而发。然而学业繁重，即使有奇思妙想和有感而发也不能常常记下来。偶尔想起来写下而已。因此并没有记录许多。 高二进行竞赛，每天与电脑手机相伴，也无需携带小爱老师，就把它尘封在家里。那段时间比较快乐和单纯，因此也没有什么灵感来源和感情触动，于是记录停滞了很长一段时间。 高三回文化课，拾起了久置的小爱老师。因为离开竞赛后情绪的波动和思考蛮多的，所以多记了一些反映价值观和人生观的东西，当然还有日常的琐碎和小乐趣。 小爱老师终究是要被淘汰掉的。但在它里面写的东西我还是想保留下来，于是写成此篇。距离高考还剩不到一百天，预计将在高考完后完成整理。 人的思想是会变的。现在总是想不起来之前的“我”的许多想法和思考模式。虽然“言必悖”，但留下的文字还是或多或少能体现出当时的自己。多年以后再看我当时写的字句，想起当年的思考和看法，也许会有新的感悟和体会，或者只是简单地回忆起过去的美好。 其实之前有整理过，是直接写在浏览器上的，结果浏览器崩了就没了（请务必记住时刻保存）。偶尔偷闲过来补一下。 因为是随意写的，所以没有什么结构和逻辑。写的备注也只是为了自己以后能读懂罢了。 2019.12.04苦难辉煌午夜将至 第一次使用小爱老师。高一时候的历史老师给我们推荐的两本书，当时可能觉得“我以后一定要读一下”然后记下来了。其实现在发现自己对历史并不是那么的感兴趣。毕竟，“人类从历史中得到的唯一教训，就是人类没有从历史中得到任何教训”。 2020.01.06 信仰与目标我的目标是&#x2F;清华&#x2F;我要通过&#x2F;努力&#x2F;节食&#x2F;惜时&#x2F;专注&#x2F;自立&#x2F;忍耐&#x2F;梦想&#x2F;信念 当时看到了进入清华的学长们，于是立下如此宏愿。不知道百天之后等待我的是怎样的结果。后面列举的除了梦想都是我所缺少的品质。现在看来，仿佛也没有什么太大的改观。可能更加自立了，但对于努力、专注、节食（特定体现）、忍耐感觉反而是倒退了。 2020.01.06 GG&#x3D;6.67E-11 为数不多的知识笔记，当时有个物理题考万有引力数值计算竟然没给引力常数（大嘴子），于是记下。本来想升级一下发现我现在不会写 LaTeX 了（悲哀） 2020.01.14 复旦大学日月光华，旦复旦兮……（编：听宣讲会随笔写的，已经不知道写的啥了。大概就是数学要考 140 分以上，语文注意作文吧。下一篇也是宣讲会上写的） 2020.01.16 北京大学为了奶奶，为了家人，为了自己。16 日高一北大返校会。一群群得意的学长学姐们为我们分享经验。竞赛的路子又窄了。除了努力，别无他路。抽奖没有我。明信片没有我的。我只有五个旺旺仙贝。哦，吃了一个。还剩四个。 我曾向祖母保证自己会考上清北。看到成功的学长们我真的压力很大。大概整个高一都是这样的精神状态：竞赛被吊打，文化课考不前去。其中因为竞赛当时几乎是一点进展没有，我曾多次晚上缩在宿舍阳台流着泪给父母打电话哭诉。 我在这个学校流的泪够多了。 2020.01.18 请妈妈请我 只有四个字。当时周末母亲带我出去吃饭，她有一句大概是说“以后每个周末我都请你出来吃饭”。当时听到“请”这个字我的心是震了一下的。在我的观念里，“请”意味着和“朋友”间的人情世故，意味着隔膜和略有疏远的人际关系。当时我突然就有一种和母亲间的疏离感。我甚至想到了我之后可能远离家人、很久才回一次家的生活状态。经济独立，自我独立，那个时候就真的变成“请”了。我很害怕。 2020.04.30 日记前几日，因为疫情延缓的三个月假结束了。我浪费了这三个月的宝贵时间。期中考试没考好。竞赛也落后许多。适至昨日，母亲又告诉我父亲骑车受伤住院了。我没法告诉她我的情况，我不敢。 今天是我的生日，因为疫情没法回去看看他们，只能用舅舅的手机看看他们两个。他们挺好的，父亲把自行车卖了，因为他觉得这车晦气。害，他也是读过 18 年书（编：当时不知道咋想的，但肯定没这么多）的人，怎生信这玩意，把载了我三年的车子卖了去。罢，我也着实让他们失望了。 我曾对他们说，我是要骑着这辆车骑到清华去的。车没了。不知清华还在不在。 没事的。爸爸妈妈平安健康就好了。 2020.05.07 圣诞礼物这里是东方。这里没有教堂。我家也没有基督教徒。但就在这天晚上，有一个小孩子在床头挂了一个可爱的红袜子，并像一个虔诚的基督教徒一样盼望着圣诞老人的到来。 第二天早上，孩子一醒来就兴奋地看红袜子，当然，并惊奇地发现了圣诞老人留下的礼物。他问妈妈昨天晚上圣诞老人是不是来了。妈妈笑着说是的。但孩子可不傻，他坚称自己昨天晚上熬到很晚都没有见到老人，而妈妈当时已经睡着了，怎么可能看到呢？可是妈妈仍坚持自己看到了。 ——我们家又没烟囱，老人是怎么进来的呢？ ——老人从门外走进来啦。 结果当然是看没看到的问题不了了之，而小孩得到了莫大的快乐，并相信自己读到的故事是真的——一个老人带给自己圣诞礼物。尽管他不明白圣诞两个字真实的意义。 现在看来，我当时是真的幼稚。还有哪个人，给儿子讲自己从没过过的节日，即使明天上班也要熬到半夜悄悄给儿子的袜子里放进早已藏好的礼物，然后把这个荣誉交给一个从未听闻的“老人”呢？我不告诉我，我心里也知道。 童话都是假的。再没有一个地方能让我感到如此如在童话中般幸福了。 家啊，母亲啊。 2020.05.19 密闭小时，我最喜欢的一件事就是用沙发垫给我搭的一个小屋。其实就是一个一米多的空间。我喜欢进去之后把光挡住。在里面，外面的声音、光线全部被隔绝了。虽然闷热，但因为是我的温度，就感到莫名的快乐。这个天地——只有我——快乐。 是什么让我不再这么做？ ……（这里有些文字不便写出） 现在高一。我买了一个蚊帐。拉上帘子，外面的声音、光线全部被隔绝了。 我难以入眠。 2020.05.30 父亲的成都·记忆父亲曾去过这座小城。他去过——在成都还只是个“阴雨的小城”时。他告诉我，在这里最记忆犹新的就是当地小吃了。他当初是和战友来的。来干什么，我忘却了，可还记得他对这里小吃的留恋。因此，我们在从青海湖回家的时候特意绕道成都，并在这里住了几宿。 我们住在一个市中心——一个广场，还清楚地记得有一个超大的小的大熊猫趴在旁边建筑的顶部，但是记不住名字——不远的一个宾馆里。当初是去过那个玉林路的，但是客房太贵了，也没有看到那个小酒馆。第一天晚上，我和父亲就下楼感受成都夜景。那真的是一种不一样的感觉，即使是身处市中心也会有一种特殊的韵味。现在想来，也许真的是那种以杜甫为首的文人带来的文化底蕴，也许只是刚从大草原来到一个湿热的南方城市的生理感受，也许只是现在回忆的不真切，但总归是有那么点味道的。我们还真就溜达到了一个巷子里——就是一个卖夜宵的地方。我们在那里点了份凉糕——好像是叫这么个名字，记不住了，大概就是豆冻放了点红糖水，但我却觉得是特别的美味。买了罐加多宝。父亲尝了尝凉糕。说没有记忆中的好吃。我至今不知道他口中各种“记忆中的味道”是怎么样的。我吃完，还想要，可是女店家告诉我们已经卖完了。于是我们两个坐在成都夜晚的由两侧高楼组成的巷子里，在遮阳棚底下，坐在上了年代的青色或是茶色的椅子上。店里已少有客人，似乎已是人定时，店主也在收拾了。正被晚风迷惑的时候，那位女店主突然传来一声“还有一份”，然后慌忙忙走出来。我和父亲喜出望外，忙打包后离开了。至于我们当时坐在那父亲给我说了什么，我已经记不太清了。只记得好像是一些重要和不重要的事。父亲总是喜欢和我谈人生、理想，和他那总没再吃到的记忆中的味道。可惜我总是记不住他那些刻骨铭心的句子。长辈总是没有办法用语言把他们知道的一切告诉我们。实际上，我们都是一样的，只是不同的记忆将我们区分罢了。 打包好的凉糕，带回去给母亲吃。母亲似乎很喜欢——也似乎不喜欢，我记得是我把最后一口吃了的。 我们再去杜甫草堂的时候（或者其他什么时候），天下起了大雨。那么大，可能是我平生，在此之前，见过的最大的雨了。即使是那年我家沟里能淹掉汽车的“黄河”也没这么大。那条河是趁这我们土路排水不利才猖狂起来的，而这里，是我第一次看到高架桥下水位线发挥作用的地方。我亲眼看到一辆汽车自不量力地抛锚在低洼。雨点是那么的密，那么的有力，比我们在高原上遇到的阵雨更吓人。但是我却感到无比的兴奋——喜欢这种危险的快感。父亲打开了雾灯，他说，很多人都不知道雾灯，因为实在不常用，那些车打双闪是错误的做法。雨刷器像疯了一样的摇，即使这样，我们也只能模糊地看到前面车的尾灯的轮廓。父亲在这种情况下开着车，还在给我讲着交规和开车技巧。他的脸上总是挂着笑容——也许只是我的记忆使然吧。但他那长满胡茬的脸，不高的鼻子，眯起来的眼睛总是让人放心。父亲开过多少年的车，我是不知道的。但他说他比起自动挡更喜欢手动挡就可见一斑了。这样的人，最近一次违反交规竟然是因为没有礼让行人，真是有趣。只要是父亲开车，在怎样的情况下我都不会感到一点危险。无论是冰雹，还是成都的暴雨。 父亲说，那年他在火车站旁和战友吃的那碗小吃，他这辈子都难忘。 火车站不知道在哪里，但我们现在就要踏上回家的路了。刚上二环，父亲就像丢了钥匙一样，慌张地说还没有吃正宗的成都小吃。正宗的小吃，是要在本地人会去的地方，常常是居民区，哪个拐角。但是我们已经上了桥出城，再往回走，会绕很多远路。母亲是想家了的，出来这么久，早已经不耐烦，又怎么会为了一顿小吃专门返回呢？我当时好像也是有这种浮躁的感觉了。总之。父亲没有办法，说，只能下次再来了。 于是我们开着车，驶过了那个写着大大的“成都”的收费站，然后看着它在我们身后远去。父亲说，放一首《成都》吧，难得来一趟。我想也是，于是放了这首歌。 “让我掉下眼泪的&#x2F;不止昨夜的酒&#x2F;让我依依不舍的&#x2F;不止你的温柔&#x2F;余路还要走多久&#x2F;你攥着我的手&#x2F;让我感到为难的&#x2F;是挣扎的自由……在那座阴雨的小城里&#x2F;我从未忘记你&#x2F;成都带不走的只有你” 父亲，带不走什么呢？是什么，让他在这座非亲非故的小城留下了依依不舍的眼泪？ 我不知道。他从未告诉过我。他也没有在我面前留下过眼泪。至于他的小吃， “下次吧。” 不久前，父亲骑自行车摔了，几根肋骨骨折。当母亲用疲惫的声音给在学校的我打电话时，我哭成了泪人。幸运的是，父亲是没事的，只是需要静养。我想起小时候在父亲大大的肚皮上打滚。他说，他永远爱我。 我也是啊。 可是，现在你的肋骨断了，我怎么再在你的肚子上打滚呢？ “下次吧。”也好。他不说，我也知道，他记忆中的味道，只有在记忆中才真的存在。他在火车站旁找不到，他在成都居民区的拐角也找不到。 可能，他是再也无法回到那个阴雨的小城了。 …… 当我有了孩子的，我会给他讲一遍我第一次和我的父亲去成都时的经历的时候，他又会怎么想？他不会明白我的感受的。就像我现在之于父亲。 在一个晚上回忆初中升高中时和家人的成都之旅。当时我们从西安到甘肃、青海湖，然后转到成都。那可能是我最后一次和父母一同旅行了。之后也许要么是我没时间，要么是父母因家事或者身体原因不允许。当时大概是在学校受了些挫折，有点想家和父母，回忆起当时旅行的事，便写下这些文字。想了很多，但仿佛都无法直接明说出来，只得用碎片的记忆转成文字。希望我之后再看时能明白我并未明写的那些感情。并且，有所反应吧。 2020.06.16 日记·表“谁把水倒到我的表上了？”他们仍自说自话，没人理我。“谁把水倒到桌子上了？”“什么水？”有人问。“倒在桌子上的水。倒在我的表上了，也不收拾一下。”“那你为啥要把表放在桌子上呢？”我吃了一惊。“我不能放在桌子上吗？我以为桌子上是放东西的，而不是放水的地方。之前我的表就被水泡过……”“那你既然知道会发生这样的事，为什么还把表放在桌子上呢？”我又可气又可笑，说，“你这解决问题的方法是和晚清政府学的吧！”“几百年前的事，我跟谁学去呢？”已经开始胡搅蛮缠了。我愣了一下，问：“那我的表放哪里去呢？”“放床上不行吗？”“有桌子可以放，为什么要放在床上？你还说不是和晚清政府学的……”“那你放地上也行啊。”另外一个人接到。“我为什么……”“行了行了有病啊，成天争论这有意思吗，还有人故意把水倒你表上不成？”哪位刚才一直没说话、上次淹了我的表的人说到。无缘无故被骂，我顿时怒气冲头，但还是克制住了爆发，憋出一句话：“我现在怀疑是你干的。”“你爱怎么想怎么想，跟个神经病似的成天争这些鸡毛蒜皮的小事，有病。”我忍住不让自己破口大骂，因为我知道此时宿舍没有一个人会替我说话。于是我拉上蚊帐，让自己冷静下来。我已经很多次遇到这种情况了。我不能用粗暴的方式解决问题。突然想到一个喜剧作品。一个戴高帽子的女士在剧院挡住了后面的人看戏，后面的人和她争执，最后那女士还做得一副高高在上的样子。这本是一个喜剧，但我却从没考虑过现实中应该怎么处理这种问题。宿舍里没人说话。他们似乎是都睡了。桌子上的水应该还没干。我开始认真思考自己应该把表放在床上还是地上。 高一时一次幼稚的冲突。当时我和二班一些人住一个宿舍。年轻时性格急躁直率，但在这个时候我已经碰了太多次壁，开始仔细思考处理矛盾的正确方法。当时是直接把怒气吞到肚子里面去了，于是变成了文字写下来。虽然没有记录，但我现在仍然记得文中提到的那些人都是谁。说明还是气，只不过换了种表现形式。明面上不说，但是心里已经记得这人不可深交。心思变得……阴险了？不过我觉得这是好事。 2020.07.15 抉择她说我不行。我给他说的是我差不多。所以他们支持我。只有我知道自己的水平。我确实落下了很多，但我相信奇迹。然而也不愿意孤注一掷。既然他们可以，我只要拥有时间，我也可以。我从不信邪。三个月，也差不多是孤注一掷了。总是有人怀疑我。如果我就这么退缩了，也就罢了。可我不愿意。我在做我热爱的事情。也许结果可能会不尽人意，但我不信我做不到。我不能忍受他们的居高临下，我不能忍受同样的起跑线我就差人一等，我不能忍受她说我的目标定得高，说我的想法不现实。不。我绝不能忍受。我绝不会忍受。即使最后弄得灰头土脸，我也要针锋相对。因为我就是这样从小学、从初中上来的。即使无法做得完美，即使不是为了这件事本身，也是为了我自己。 实在一点的话，尝试每天写四道题打一次比赛。如果每次比赛都超过二百分，那就差不多了。可是每天待在机房，磨的可是硬功夫。耐心、专注力、恒心、意志。痛苦如斯，快乐如斯。我本没有这些品质，但他们、她们给了我力量……希望如此。7-15-2020 疫情之后 选择停三个月课 谨此明志 当时好像是三个月后 NOIp。当时 zzc 已经停课，fgf 也有这个意向。因为我当时成绩很差，教练认为我拿个省一就可以走人了，不需要停课。真得感谢教练，如果不是她看不起我，我可能就不会停课了。事实是，我一停课就可以全神贯注于竞赛了，而一旦我专心于一件事情——正反我现在都拿了银牌，可以在教练面前横着走了。现在（2022.3.5）距离高考同样是三个月。年后的一场考试我因为太颓废了考了六百多名，所以不久之前班主任找我谈话，想激励我，甚至说“实在不行银牌还可以再用一年嘛”。历史总是如此的相似。我感觉又被人看不起了。父亲说，中国人有一个特质。极盛必衰，而被打压的时候却又很有韧性。他把这称为“贱”，我很认同。我就是这贱命。当然我不会屈服于这命运，我会尽力 take advantage of it。 2020.09.28 DiaryOI 竞赛五档线，一条还没过呢。停课一段时间了，也不知道自己的水平是真是假是高是低。机房的生活是真的快乐。但是也非常害怕自己回不去。我不希望回去。回去一切都变了，我引以为傲的一切也都会消失不见。让我脆弱的心灵在考试前再多待一会、待一会。严峻的现实嘛……让我浑浑噩噩地度过这段时间算了。将来，将来的事情请交给将来吧。 有时候我觉得自己的情绪像青藏高原的天气一样善变。 2020.10.30 高中生活#1 10.31停课前的生活恍如隔世。我之前从没想过我现在的状态。但如今却是习惯得很。这可能就是随遇而安吧。人生中能有这么一段经历——停课的竞赛生活，说真的，即使最后没有结果，我也算是没有枉来西工大附中。这不就是我向往的高中生活？我只知道，若不能好好把握这次机会，我就只能沦为平庸。 明天体检肝功，晚上忘了，吃了东西，应该没事吧。 2020.12.23 Diary很快，CSP 和 NOIp 就过去了。我得到了些许令人满意的成绩，但后面的挑战更加严峻，赌注也更危险。下注的也不仅仅是我，而是全家人。不幸的是，赌注的增加并没有伴随着奖励的提高。相反，赌输后的代价却变得越发难以承担。最近实在是过于颓废了。马上要去绍兴，我却仍然找不到自己的感觉，只能尽可能不被别人落下。那咋办嘛。立个宏愿好了：我一定要通过省选，最好有 A 类，然后至少要拿国赛银牌。 没拿到 A 类，但是其他目标达到了。但是许愿居然忘了签约的事。可恶。 前往绍兴，把小爱老师放在了家里，直到回文化课之前都没有再碰到了。也就是直接跳过（skip）了整个高二阶段。这一年我完全停课投入竞赛——但也没有完全投入，说实话，成天坐在电脑前真的很难控制住自己不去颓废。以至于省选后的每天几乎都是颓废的状态。严重的程度，可以说是昏天黑地，暗无天日，俾昼作夜。以至于最后失了约。不过去浙江跑了几趟，也算是开阔了视野，也见识了南方的、绍兴一中的才子们是如何学习的。所以，我并不因为我没有努力而后悔。 怎么说呢，这也算是我狂妄的青春的一部分吧。我很高兴我狂妄的时间也有一部分用来学习自己喜欢的东西，而且最后还不是落得一无所有的下场。并且在这一段时间里，我感觉自己的人生观、价值观都有了很大的改变，以至于我再回首初中和高中的自己的时候，发现自己已经完全换了个人——无论在为人处事的方式上，还是对人生价值的看法上。可惜尽管成天拿着电脑和手机，却没有用一点点时间记录下来这改变过程（休息时间全用来玩游戏了）。时常停下来反省自己，也算是一条人生经验了。 小时候和高一的时候没有娱乐的方式，每天闲的时候躺在床上喜欢想乱七八糟的东西、今天和之前的经历，当然也有梦想。但是当你把休息时间拿来娱乐之后，就会发现自己被占得满满的，每天把自己空虚的脑袋填满泡沫，显得很忙，不能抽身呼吸和伸展筋骨。现在有机会回想起来真的是深刻理解了娱乐的致命性——让你浑浑噩噩，无法思考。和喝酒宿醉和吸烟吸毒本质上没有什么区别。而这些是我所深恶痛绝的。但是如果我记得我自己说过，我痛恨的是这种逃避思考的行为本身，那么疯狂娱乐理应也被放在和烟酒同等的位置上了。 呃，在绍兴一中的事情实在是记不得多少了，反正每天做的练习题是记不得。只记得学校很大（当然是没见过更大的，听说宝鸡中学和衡水（恶）超级大），中心有一个图书馆（有幸进入里面听原 CCF 主席讲演），有室内体育场地、网球场、操场、篮球场、排球场，图书馆后面、后门边上有一个南方园林式的纪念馆与小桥、以及一潭死水。我们刚去的那天晚上下午就去逛了个遍——这些景观足以给我们这些平常龟缩于大学校园一角的学生们留下深刻印象。南方学校大多有联通宿舍楼和教学楼的长廊（我认为是雨水多的缘故）。环境很有南方特色，幽静怡人，到晚上会有佯装成古代吊灯笼的电灯昏昏地发出温暖的黄光。宿舍楼大厅有一架钢琴，大家都可以去使用。在我用多次展示的拙劣的琴技吸引来了本地聚銠的精彩表演之后我就再没碰过它。绍兴一中的宿舍让我们这群北方人大开了眼界，无论是它每个宿舍带的两个浴室还是南方夏季的令人恐惧的蚊子。我们买来一个电蚊拍之后每天晚上回去的第一件事就是挥舞它，几乎每次挥舞都能带来一连串的噼啪声（我们甚至用坏了一个电蚊拍）。当然，在那里是有像大学一样的桌子的。南方的学校下午放学早得离谱，所以允许学生在宿舍学习也无可厚非。而且宿舍里有电源，于是我们可以打 CSGO 打到半夜。食堂有两层，性价比还算高，最令我们印象深刻的是梅菜扣肉和免费的梅菜汤（又爱又恨了属于是）。几乎每个周末都和门卫扯皮溜出去吃饭购物和闲逛。嗯，我们甚至还在宿舍点了外卖（被臭骂了一顿），聚在宿舍里吃烧烤、披萨……那真是一段无比美妙的时光。虽然每次去要么是接近省选，要么是临近国赛，但每次去都能过得无忧无虑。以至于我们之后教练再也不让学生去绍一学习了。 学校大门口立着一块大石头，上面写着大大的“做真人”。我在离开的时候拍下了它。如果以后有人问我高中在哪里上的学，我一定会加上绍兴一中。如果有机会，我以后可能还会去像看望母校一样去造访她。 绍兴本地人说话听不懂嘤嘤嘤 实际上是省选前和国赛前分别去了两次，记忆混在一起了，并没有整个高二都在绍一呆着。那些有趣的事很多是第一次去时做的，因为第二次去的时候，我们一些人已经不见了。 ……让我们重新拿起小爱老师。 2021.09.10 想fgf 今天说她一到周内就不想学习，我问她那她还能每天都完成作业，她说她只是不想学而不是不学。 然而，我不想学习的时候就真的不学了。虽然这么说，但是有时候也会有莫名其妙的动力。我不知道造成我俩差别和这种现象的原因是什么。如果我能了解这种原因，我可能就“会”学习了。 总是有人问我，我为什么要这么做。我说，我想这么做。想还需要原因吗？大脑是一个混沌系统，但是却又条理，而人类能做的只是见缝插针地研究。就像现在的数学题，我总觉得是在耍小聪明。这样绝不能形成像人脑一样的体系。 刚回文化课，无心学习。这样的状态持续到了年后。现在看来自己写的这些东西仿佛是在给自己找借口——又或许不是。 2021.09.18 汪语 松土是如何影响全球变暖的 讲完 DNA，下节课英语：26 个字母有啥好排列的么 看那哈货带着耳机，左手吃着饭，右手写着作业，同时干一堆事，结果一件也干不好。那是退化。你看那草履虫，一个细胞要管进食、排泄、移动、生殖，一件事也干不好。人类给你分化出组织和器官是让你提高效率的，你在这退化。唉，哈货。 唉，那群哈货（指搞代孕的有钱人）。有的后来又变好了，那是哈货中的败类。争取当哈货中的败类。 2021.10.06 （日记）10.26 凌晨 高一的时候，第一次参加 CSP，看到 TYC 与他们谈笑。记得最清楚的是这个学姐。她笑得最开心，很自在。他们当时才是高二。我现在是高三，他们现在已去清华。仿佛没过多久的事情，想起来却是如此清晰真实。现在我已是当年那个他们。 我多希望继续追随他们的脚步。她曾在附中食堂给我打招呼。我想再听一次她的声音，在清华的食堂吧。 2021.10.24 神经系统的分级调节老魏说了一句话：“我不敢去看那些反映社会问题的文章，因为我知道我一看就会变得激进。”不知道老魏如果不当老师，他的思想倾向又会如何。 这就像知道自己会上瘾而不去吸毒。……享受现在。 2021.10.24 批评中国人不喜欢批评家。他们成天批评，容易给人不做实事的印象。不符合社会主义核心价值观。 只有当你不仅针对一方面提出批评，并且给出解决方案，更去实践自己的方法，最好能成功并且自己成为权威和代表，这个时候，你的批评才会被重视。 这是好事吗？ 学鲁迅先生的手法十分拙劣、有失偏颇。但是当时确实是因为有一些人，说什么不应该妄加评论的话语之类的言辞，仿佛不去把宪法背完就没有资格评论国家事务。我十分讨厌这种说法，于是写了这点文字。在我看来，我的评论即使不能有实际效果，也至少应该能够反映像我这样一类人对某件事物的看法，即使它不是正确的。你并不能保证你说的每句话都恰如其分，而如果就由此因噎废食，那么公众的舆论从何而来？显然大家都不是这么做的。你也并非公众人物，何必如此惴惴小心？在我看来，是把自己看得太大罢了。何况，犯错误时有助于纠正和提高自己的。沉默在很多情况下都不是金子。 2021.11.08 家族树家谱必须是树，而且深度具有意义。但是如果不是树的话，那么只有可能出现了近亲结婚。 所以，如果要晦饰一个人近亲结婚可以说： “他使得他家谱成环了” 2022.02.07 谔谔《史记·商君列传》：千人之诺诺，不如一士之谔谔。 谔谔：直话直说（确信 2022.02.12 井底之蛙可恶的是那个告诉他外面的世界更大的青蛙。因为井底之蛙根本出不去。他做了正确的决定：选择不去相信那个世界的存在。这对于他是好的。或许他只是在骗自己，不过这也是好的。 或许你会说他是可以出去的，只不过没有尝试。可能。但他出去之后呢？发现自己在井里面浪费了大半辈子，出去以后在井里的经验完全用不上。不是每个人都能那么很快适应新的环境。住在监狱的鸽子永远无法自由。 王八蛋老师讲的很对：我不去看那些评论社会的文章，因为我知道我会变得激进。 我们语文老师曾经给我们说，出去不要讲自己的语文老师是他，就说是王八蛋。我从来没有听过这样的请求，所以以后用王八蛋代替他。 2022.02.23 日记心情很糟。 早上又走晚了，坐了教职工电梯，不巧碰上不想让学生坐电梯的老师。我当时手里拿着三明治，和另一个学生闪了进去。她骂着。我看她脾气不好，本想开个玩笑或者求求情，大不了挨顿骂，一般老师都是很宽容的。实在不行出去也就罢了。 可是，她推了我们。 她把那个学生推出去了，然后继续推我。我没动。我站在那里盯着她。 电梯门缓缓关上。 电梯厢向上抬升。 不打的电梯间挤着四个人——那老师的后面还站着两个女生。所以我们离得很近。那老师模样的女人厉声责问我：“你是有什么理由？” 我没有理由，所以不说话。 “你是胳膊残废了还是腿不行了？” 我不说话，只是瞪着她，目不转睛地慢慢抬起手，然后咬了一口三明治。 她被我这个具有明显挑衅意图的行为激怒了：“你是哪个班的？” 电梯运行过半。我有点恍惚。她像我的小学语文老师一样盯着我，而我以相同的方式盯着她。若是以前，我会理直气壮地报上自己的名字和班级。然而我已经多次尝到这样做的苦果，于是默然。 电梯停了下来，然后门缓缓打开。我风也似的冲了出去。虽然我感受到她妄图抓我的书包，但我连头都没回，自然也不去理会她的叫喊。虽然溜了，但我知道如果她是那种爱找麻烦的家伙，随便一查就能查到我。 好歹没回敬她。好歹算是进步了。然而最初为什么硬是没有出电梯，现在我也是不知道。 又倔强又怂，喜欢自找麻烦，这可真是…… 可惜最后还是迟到了。王八蛋老师的课。我刚遇到那事心情不好，于是在走神。王八蛋讲题目的作用时，叫我起来。我不知道，于是不做声。 “真不会？” “假不会。”我答到。运用了仿词的手法，达到缓解气氛的效果，我可真是睿智。 然而，他把“假不会”三个大字写到了黑板上。我呆住了。他让我坐下，然后吼道： “我以后永远不叫你回答问题！” 我坐下了。我感到眼泪要夺眶而出。于是我狠狠地啃了一口三明治。王八蛋老师是我喜欢的老师，语文课是我喜欢的课。可就在刚刚，王八蛋给我宣判了死刑。 …… 妈的，那种感觉，又来了。从小到大做错了事之后的那种悲伤和内疚。竞赛结束后我都没有过这种感觉，本想着可以永远摆脱它。我他妈都快十八了啊，操，为什么我还要惹上这种事，还要为这种事沮丧啊？承担不起后果，还要把自己放在矛头上，这就是贱吧。人为刀俎我为鱼肉，为什么要去惹人家屠夫呢？然而，即便是做一条咸鱼，我也要奋力挥刀砍向刽子手。这种故事的结果通常是自取灭亡，如果成功便是童话故事——但我仍然会去这么做。 看来我也是有点浪漫主义了。 王八蛋老师说，李白浪漫是因为他出身高，加上有才气，被世人赏识，才有的浪漫的资本。浪漫是最奢侈的奢侈品。理性来讲，似乎趋利避害、能屈能伸才是正确的做法，才被称为“明智”。我一直在尝试这么做。但无论怎么学习，我的本性就在这。 我真的，不想，再压抑自己了。 父亲说，我这种性格，不善交际，就应该去做学问。我现在知道，有那么一种生活，一种理想的生活，一种浪漫的生活。那里可以远离尘世，远离压迫，远离那些屠夫。那将是我终己一生追求的生活。他们说这是幻想，那是因为这些俗人得不到，更可能见都没见过，目光短浅。 然而我纵然是贱，纵然没有浪漫的资本，也要硬着头皮去追求那一份浪漫。这何尝又不是一种浪漫呢？辗转沟壑而死，不也是一份乐事？王八蛋老师笑颜回一生一事无成，但箪食瓢饮又何尝不是他的浪漫？孔子盛赞其之故，盖若此也。而凡夫俗子只由其学术贡献论其一生，又何以明圣贤之道？ 王八蛋，你算老几？身为人师，说出这种话，不觉羞耻？ 那个老师，就像千千万万不通人情的行尸走肉一样。她大抵也只能混个中学老师。 王八蛋对我说过，“小子，你早晚要耐挫。”我知道，我之前耐过，现在耐着，将来也还会耐挫。我很高兴，因为这让我觉得我就是我。 王八蛋老师当然没有真正“永远不让我回答问题”，这我当时其实是知道的。但是他说出那种活还是令我心痛。不过这并不影响我对他的态度——我已经过了那个和人怄气的年龄了。我只会在这里写点牢骚话，顺便，让这个人的形象在我心目中刷新一下。 2022.02.27 亲亲亲亲：爱自己的亲人。 我要亲亲！要亲亲！亲亲！ 2022.03.03 学几天前我自习课间 emo 了，然后回宿舍哭了一阵子就睡着了，把学习的东西散在教室没管。我以为会有同学看到我第二节课没去，会帮我把用具收回来。 自习结束，我被他们回宿舍的声音吵醒。拉开蚊帐，问一位刚回来的舍友是否帮我收拾。没有。于是起床去对面宿舍问。 推门。“呦，袁大公子来啦。” …… 不想去回忆了，当时刚低沉完睡醒脑子有点乱，总之就是没人帮我带回来。我也没嘱咐，是我的问题。我这么想着。虽然之前有同学没打招呼提前走我也主动帮忙收拾来着。 但是还是我的问题。 今天依然回宿舍挼辟邪，同学邀请我睡大觉，我拒绝了。 我要是不去学习的话，连给我收尸的人都没有。 写这篇文章的原因是，我当时出对面宿舍门的时候态度不太好，感觉好像别人就应该为自己做事一样。我对此感到羞愧，也因为我没有这样的人而悲伤。 2022.03.10 天才“天才是 1% 的天分加上 99% 的汗水。” “黑猩猩和人类的基因相似度超过 98.5%，我让动物园的黑猩猩再努努力，说不定他的智商能超过你。” 仔细研究一下，你就发现这两者真的有相似之处。决定一个人的往往是那 1% ——无论是天赋还是汗水。 2022.03.10 智能我不喜欢学术。 我曾经有很长一段时间单纯地喜欢学习。现在想来大概是因为早年根本算是个社交障碍，而学习又相对比较简单，于是就喜欢学学校教授的知识，还能得到老师的表扬。除去这个原因，我却真的是在学习中得到了快乐。那种贯通思维的舒畅，那种对知识的渴求，还有那种打破砂锅问到底的倔强。那份感觉我有幸在高中的竞赛时又浅尝了一番，但也只是浅尝。 说回那段时间。我清楚地记得自己宣扬过“学习完全是兴趣使然”。我也记得我第一次旷课是因为一道数学题和老师发生了争论以至于肢体冲突。我曾对知识那么的渴望，那么的较真，以至于完全不顾人际关系和个人生活。 “当你知道的越多，你不知道的就越多。”认知就像一个圆，面积越大，周长越大，也就是未知越大。然后发现，未知是无穷的。这让人气馁，让人怀疑学习的意义。不过我并未被这个问题困惑，因为我觉得它和“人固有一死”，“活着有什么意义”的问题是相同的。我是说，我在认知的边缘上发现了新的东西。 我发现了我自己。 仿佛一夜之间，但又感觉很漫长，大概和我竞赛时的见闻以及网上的经历有关，我开始注重我自己的重要性。我开始学习如何交往，开始对他人，对世界充满兴趣。我开始认真审问我真正的想法和欲望。毕竟，我是一个人。人是动物。人没有了解宇宙的义务，但是人有七情六欲，有肉体。我对我产生的各种情感和思维非常好奇，也对人性充满好奇。这里面有着庞大的知识和未知。客观地讲，这似乎和其他知识并没有什么区别。可是，正如我所说，我是一个人。这份知识对我的吸引力远比宇宙给我的多得多：对于宇宙，我就像是用凡人之躯理解神明，就像蚂蚁打量泰山，顶多拼尽几代人将它丈量，但终究无法了解它的全貌，跟别说人类赋予它的各种意象。我觉得人类现在的工作就是蚂蚁丈量泰山。但是，对于人类自身，却是值得研究的。 我发现我是一个人。 我不喜欢学术，是因为我发现现在学习已经不是我想去做的事情了。现在是高考前九十天。我的学习已经被单纯地功利心玷污了。也许学习过程中我还有解题的快乐，但我知道我现在做的事甚至不是丈量泰山。我对学术没有感情，我也不能强迫自己去喜欢它。如果我真的要去研究什么，那一定是因为这样做能得到我得到的答案，而不是因为学术本身——它顶多是一个工具。 我仍然喜欢学习，但我不会把这个词的解释权交给别人。完成这段基础知识的义务教育后，我将不会再主动漫无目的地“学习”。 人生苦短，我想找到能延续人类生命，或者延续人类精神的方法。如果没有肉体和寿命的束缚，或许我还能找回探寻宇宙和基本原理的那份初心。但大概是…… 2022.03.10 智能人工智能的深度学习系统，是不断对信息进行堆砌矫正来进行学习的。这需要人工比对来提供校正。 人的思想可以简化为是若干神经元构成的。而对其进行校正的，是环境。 什么是智能？ 我非常喜欢随机算法。我相信生物本身就是在混沌中被自然选择，也就是校正，而一步步进化的。这是个庞大的过程，但只要有足够的时间，它将会收敛。我喜欢不确定性。因为即使随机化期望不优，它总是比循规蹈矩更容易抽中大奖。进步需要这种质的飞跃。 人的思想不也是信息堆积成的吗？ 我不知道，也许，会有其他的收敛位置。未知总是如此奇妙而吸引人。 2022.03.14 日记·奥密克戎一睡醒就听到宿管通知有出租房的学生回家。 早上得到消息，说是要停课。结果又改了口，只有高一高二停。但是学校确实是做好了停课准备的，预案是直播课。 中午联系母亲，才知道铜川也一夜之间公交全停，学校全停，因为耀州区出了一例。 早就听闻奥密克戎的强传播力，没想到它这么厉害。上一波西安疫情对抗的是德尔塔，而同期在天津和深圳爆发的奥密克戎现在还没有结束。因此我不觉得陕西的反应过激。相反，我觉得反应不够。我觉得让高三继续上课是个坏主意。 我就算今年放弃高考，也不想得奥密克戎。希望教育局和学校拎得清他们在做什么。 2022.03.16 日记·噩梦成真昨天才在讨论要不要住在机房，今天真的就一语成谶。 乐观地想，这种事也真的只有中国人、只有在中国才会出现。中华民族有强大的团结精神和献身精神。这将是我永远珍视并传承的精神。如果一切进行顺利，这将会成为老师同学一生中津津乐道的佳话。 但是如果出了问题，它就会变成我以后诟病高考制度和民族劣根性的一个典型案例。成王败寇罢了。 中华民族是苦难的民族，是有韧性的民族，是懂得舍小家为大家的民族。这种力量是恐怖的。我相信它是中华文化经久不息的重要原因。这种力量如果不是在毁灭世界，那就是在创造奇迹。 总而言之，学校能做出让高三学生全部住校的决定并非易事。这足见学校对高三学生的重视和关怀。显然疫情不是我们能管得了的，那么现在压力来到了我们这边——不学出点东西来是说不过去的。 2022.03.16 日记·狼来了战士们依依不舍地和亲人们诀别，整理行囊出发，做好了三月不归的准备。然而已经到了战场，甚至连营帐都未扎下，却收到消息说要回家了。 这仗难打，不能让战士们送死。回来打信息战。 于是便有早上七点开摄像头直播学习（ 但是却留下了几个殿后的。烦死了，同样的剧情。这次恐怕是场硬仗。而且不能输。 2022.03.19 日记·第二波疫情仿佛真的是我预估错误了，这次的病毒并没有造成像上一次一样的危害，社会面已经清零，明天就要复课。到头来，我们的新客人们只在宿舍住了三个晚上。 有点超乎想象，可能是西安市政府确实这次做得不错。这样挺好，又可以回来冲刺高考了。 然而西方那边却开始指责我们中国的清零政策无法达到群体免疫。说真的，我一点也不想摊上新冠的后遗症。 我希望第二波疫情可以就此过去。还有八十天高考，希望不要再出什么岔子。 呃，这次可才真算是“狼来了”。 2022.03.21 魏语 咱们不是在搞文学批评，咱们离文学很远。文学本来是见仁见智的，但高考不是，高考需要我们千篇一律。 我们就是要搞应试教育。应试教育有什么错？中国的人才就是应试教育培养出来的。 在大环境、社会根基和主流观念不变的情况下，扯什么“素质教育”无异于埋没人才。这和所谓“双减”可谓异曲同工——都在舍本逐末、自欺欺人。fgf 认为，培养或许不是一个正确的描述，因为她不觉得应试教育对人的成长有什么益处，它只会摧毁人才。但不可否认的是，它的确是一个差强人意的方式。可悲的现实是，正如他所言，人们能做的，只是尽可能地把更多的人才拉出泥淖。我是自诩自己为人才的。我希望自己能先脱离这里。 别说你优秀。你优秀是因为有高考。咱们用成绩赢得别人的尊敬。 没有了高考，看看自己还剩什么吧。 感觉王八蛋老师其实是一个比较矛盾的人。他曾经说过自己“其实很自卑，但为了你们不得不改变自己”。他仿佛知道我们有些“愤青”在想什么，他知道党、国家、社会的诸多弊端，他很清楚，但他接受了。我没有他那么多的阅历，我不太理解他的做法——也许是理解的，只不过不支持罢。至少作为一个老师，他在做正确的事情。某些情况下比如他不能控制自己情绪的时候除外。 2022.03.26 批评和之前差不离。 如果你没有成功，你批评，他们会说你没有资格发言；如果成功了，你回过头来批评，他们会说你得了便宜卖乖。于是人们变聪明了，都沉默不言，都认为这是件出力不讨好的活。然后，他们说，现在的人都胆小如鼠，没有担当，全是些自私的精致的利己主义者，看到老人摔倒也不去扶了。有些人听不惯，站出来了，花大力气批评了，行动了。但言必有失，行必有缺，总会干出那么点不很称心如意的事。于是他们纠缠住了，斥责他没安好心，他图谋不轨——他一无是处。他应该被钉在历史的耻辱柱上，用来警醒后人。 后人们看了，我勒个去，这人血馒头做得可真精致、真冠冕堂皇……真好吃。 2022.03.28 胡言乱语我之前给 lxc 说，我可以控制自己的情绪，比如我快乐是因为我想快乐。那天晚上我无缘无故低沉的时候，他说，原来我也不快乐。强装的情绪就像泡沫，见不得光，弱不禁风。 我之前给 fgf 说，我现在已经不再数数然了。仿佛是有什么崇高的理想，把世俗欲望置之度外。但当她让我知道又有人比我考得好的时候，或者如果我最终没能考上清华，我依然会十分沮丧。 情绪反映人的思想，是它的一部分。我从来没有实现过完全理性。而且，我不认为世界上会有人、曾经有过人实现。再圣的人也终归是人。 那么我的这种想法算什么呢？在大多数情况下，它似乎体现为精神胜利法、自我安慰和自我欺骗。我不知道这是否合理有效（或者我想达到什么效果）。 但是，人的意志可以变虚为实。那么，我相信这一切都是真实的。让它在它应该存在的时候出现吧。 这仿佛是作为人类的一种特质了。现在我很随性，所以如果这种想法是自然而然的形成或者我不由自主地行动出来的话，我倒是不会感到非常压抑。我不再尝试强制控制自己的情绪了，至少不会强力地去改变，以至于让我感到不爽。 2022.03.28 混乱与秩序我认为，人类最有成就的事情无非是在混乱中寻找秩序。当然，混乱和秩序需要寻找一种平衡。 自然是混乱的，它提供了无限的可能和机会。自然也是有序的，地球就是一个明显的例子。 生命是混乱的，但它也是秩序的。它本身意味着秩序，但无法脱离混乱，因为这样它会无法发展进化。它的根基是混乱，但它的发展又在背离混乱，甚至在人类出现后，有人妄图寻求绝对的秩序……当然。 这就像是太极。 正如我开始说的，人类在物理、数学、人文方面起初都在追求秩序。然后，他们发现，有很多东西是他们没法用一条公式、一个系统、一种理论、一套思想来统一的。他们开始意识到混沌。 霍金说过，科学的终极目的是提供描整个宇宙的单一理论。混沌有它遵循的规则，但在这些规则的基础上实现了非常复杂的系统——复杂到人类无法探求。也许我们会有一天得到这个单一理论，但我们作为人类总要面对混沌，因为你没法通过这个单一理论预言明天的天气。然而我们注定无法很大程度上了解和掌握混沌，它是极为强大的力量。这种力量不是我们见缝插针能窥探和掌控的。所以我们注定对混沌了解甚少。我们只能适应。 我是生命，而且是人类。 我…… 我喜欢随机化算法 2022.04.03 自闭又和 fgf 辩论了，自觉甚是不应该。明明早就知道了彼此不是同路人，为何仍然争执这些？只不过凸显出自己的不自信罢了。因为不自信，所以总是寻求认同。何况这不是三言两语能够得到的。 争执的内容大概是高考总结的作用。她认为，总结是复杂度上的优化，而我觉得总结就是卡常。我觉得高考就是卡常。刷题积累题型，也许能让你以后很快速的做出相同类型的题，但并不会让你有什么实质性的提高。我认为这不是真正的总结，这只是积累，是复现。总结应当是归纳，是一种探索，是追求新的知识和方法。能做出一类题不代表你获得了新的知识，只能说明你记得牢。稍微懂点脑子变个形就觉得是新东西是愚蠢的。总结是进步。这不是进步。她甚至将总结和灵光一现当做同等级的对立。事实是，总结更需要灵光一现，灵光一现不是无中生有。我知道她在膈应我（什么猜结论大师），所以我也没有说下去的欲望了。不过既然她能这么讲，说明好像我膈应她的目的达到了。总而言之，高考题式的总结毛用没有——抛开高考而言。 突然发现她好像也没有脱离高考。那好像就是我们对这个比喻的理解不同，然后自说自话而已。哎呀，总而言之，和与你不在一个频道上的人说话真没意思。他们的侧重点全在高考，而我总是脑回路清奇。她应该没说错，可是她膈应我，所以我不知道在争啥就闷头怼上去了。我的错。我有罪。我不应该。 令我焦虑的是清华的羟基招生简章。它说得好像要看国赛成绩合约。而我没约，成绩也在后面，所以害怕直接审核不过。学长同学父母给的建议是，就当没那银牌，全力以赴吧。毕竟，如果裸考线过了就一定稳了，是吧。 惊喜地发现 ckl 也认为生活应该快乐为主，成绩财富都是身外之物。我发现很多人都是这么认为的。追求自己想要的生活，那将是多美好的一件事。虽然高考的确是重要的一环，但并非全部。他说的很多都是我之前写过的。这使我发现，我还总是和自己过意不去。在我不盯着这个目标的时候，我就不会焦虑。但我总是控制不住。 那就不要控制。 最后一次，为别人而活。为了那不切实际的梦想，为了所谓的光荣和使命，为了无谓的证明，为了过去的承诺。 不为我自己。 2022.04.06 生日今天是清明节后一天，是 ckl 的生日。所以我送了一沓纸钱给他做生日礼物。 其实有几个考虑。一是之前开玩笑，实现诺言罢了。我认为 ckl 是那种开得起玩笑、关系还不错的朋友。二是正值清明节，这礼物比较有节日特色。 三是，这是他的十八岁生日。这意味着一个孩子的死去。 今天也是九模出成绩的日子。我考砸了。不过因为昨天冰与火之舞通了两关，所以心情没那么糟。除了担心大老师阴阳怪气我，还有我不能肆意妄为之外，好像不再很担心高考的事情。一惊一乍有碍身心健康。 我也收到了来自广东或者说非洲的生日礼物，很惊讶，也很惊喜。生活除了学习之外真的还有很多事情，我很高兴我能活着见到这些，并且勇敢地去做一些。 每个人都有自己的理想和追求。fgf 考了年级 13 名，这是她应得的。而我每天不写作业翘晚自习去机房玩电脑所以这成绩也是我应得的。我想，我只要做到自己不后悔就可以了。我想我这种人去了清华大概也是浪费名额。 如果 ckl 不喜欢我的礼物的话，也许他可以烧给我，烧给过去的我和将来的我。希望我们都能不惮生死，心怀愿景，便是活着。 2022.04.08 医生昨天我头晕脑胀，上吐下泻，肚子格外难受。请假在宿舍休息后，发现没有缓解，于是意识到严重性，勉强去找了校医。校医听到我的症状后，建议我直接去医院。这时候，几位校领导来找校医一起去检查卫生，听说这有个学生在所以走不成，于是过来发表意见。 “小伙子咋了?”“肚子疼。”“男生么，肚子疼有啥。” 校医建议让亲戚来接我去医院。我回宿舍给母亲打电话。 “妈，我很难受。”“去找校医了吗?”“校医建议是直接去医院。”“啊?她不能给你开点药啥的。没那么严重嘛。你不是经常拉肚子……”“可是我真的很难受。能不能叫姑姑或者舅舅过来。”“别麻烦人家了，就自己去附近的交通医院看看吧。” 强忍着病痛一人到达医院，因为没手机只能亲自在缴费诊室和取药处跑。血检和粪检显示白细胞异常升高，粪便有隐血，医生诊断是菌痢，传染病，得输液。我问能不能不输液，我还要上学。医生说没办法，不治疗会变成慢性病。 再给母亲打电话。 “啊？不能开点药吗，必须得输液?“你不是经常拉肚子吗，没这么严重吧?上不成课了咋办……“哦，那应该不是吃坏了肚子的问题。” 我当时的回复是“您准备来给医生点医学指导吗”“我真想****”后面那句她没听见。 缴费，皮试，等挂上针的时候我感觉我快要死了。还是头昏，挂完针有所减轻，但没有消除。肚子也是。回宿舍睡一觉后，发现症状好像反复了。腹痛，想拉肚子但是因为啥都没吃——我挂上针是下午两点左右，在这之前一口东西没吃，后面静脉注射葡萄糖——所以便只是痛。头晕得想吐，又吐不出来。坐卧不宁。使劲灌淡盐水，勉强睡下。 第二天一早，发现症状缓解很多。宿管来慰问我。 “还难受吗?不去上课?”“嗯，医生说吊针得打三天。”“你真相信医生的话?” …… 学医救不了中国人。 （这里缺少了一段文字） 2020.04.09 《时间简史》初读后感2022.04.15 傻子2022.04.17 爱情我不可自拔地爱上了她。 她是如此的令人倾倒。在我把表白信投入她的邮箱的时候，我看到众多的比我优秀的追随者做了同样的事。我之于他们真是相形见绌。可是，唉，我还是不肯放弃，以至于让我彻夜难眠，心中总是怀着能被她一瞥的美好愿望。 等她回信的日子里，我心神不宁。她会不会接受我呢？我多么希望能成为被她青睐的人中的一个！被她选中，那将会是多大的荣幸，多大的幸运啊！她会怎么想呢？我把自己完全放在她的仁慈之下了！可是，这都是因为，她是那么的令人着迷。 整日整夜，我都在幻想被她选中之后的美好生活。以及，不得不去考虑的被拒绝之后的绝望。这两种结果间是多大的差距！我失魂落魄了起来。啊，为了她，我甘愿去奉献自己的一切，奉献自己心的每一块碎片，只要她想要！她会不会想要呢？我混乱着，忘记了学习与工作，忘记了真正重要的事——怎么会！还有什么是比得到她更重要的呢！她简直是我的一切了!有什么是比她的一蹙一笑更令人神魂颠倒的呢？她要我的双手，我给她奉上。要我的双眼，我为她剜掉。我的身体，我的灵魂，我的一切，为了她，我可以全部抛弃。她会拿我的双手去织云彩，用我的双眼去燃烧太阳。她会撒下灿烂的阳光，和甘美的雨露，撒给我们每一个倾心奉献的人。我会得到她的恩惠——只要我奉献得足够！也许我不如他们富足，不如他们英俊，不如他们出众，他们也许可以燃烧百鸟的羽毛——但我能够燃烧自己！ 她总不去拒绝我。哦，多么慷慨！永远仁慈地给予我希望。她让我的心保持燃烧。她想得到我的光和热，每一点光和热。她想！每一点光热的奉献，都是我的幸运。我是如此的幸运！即使，即使她不答应我，我也会继续燃烧。她会鼓励我，永远给我希望。她是那么的美，那么的动人，她的言语就像不竭的甘泉，她让我知道我的追求都是有价值的。她会读我的信，会知道我的爱慕，到那时…… 我会燃烧殆尽。 “她”是清华。最近学校风气弥漫着舔狗的气味，我可能也有一点点类似的感受了。第一次写这种东西，水平太次，没有那种感觉。看来我还是不太适合当舔狗（ 这是个屁的爱情。 2022.04.17 执念三十日是我的生日，也是强基计划报名结束的日子。 最近总是在纠结审核的事情，横竖睡不着觉，不想学习，甚至不去上课。随着那个日子临近，我只是越发不安。却不知道为何。我不知已经寻求安慰和自我安慰了多少次。我不断写字，提醒自己，运气不会差，一直不差。况且，再差能差到哪里去呢？道理很清楚明了，但我就像着了魔一样难以冷静。 我告诉自己，告诉别人，我恨许诺。我说，上清华只是我对别人——比如说奶奶——的承诺，是为了完成别人的期许，而不是我的梦想。但是，我却无法解释我现在的状态。如果果真如此，我又为何会像丢了魂一样焦躁不安。 三十日，接近。我猛然想到，我的确是丢了魂了！ 到那个时候，一个孩子将要死去。我想起了这个孩子：他努力，只是为了得到别人的认可和重视。如果一个人最希望我能上清华的话，那就是他。 我恨许诺。然而我发现，这还是对一个将死之人的许诺。我许诺之人，不是别人，正是之前的我自己！ 一个孩子将要死去，而他的执念萦绕在我的大脑。他一遍遍地告诉我：要成功，要显赫，要证明自己…… $ \\huge 证明自己 $ 他对我在竞赛时的表现不满意。 他要缠着我，要我实现自己的诺言，这个年轻时犯下的愚蠢的错误。 他要带我一起死掉。 可恶的厉鬼，应该让辟邪来把你抓起来吃掉。你有什么执念？你是贪得无厌。我会为我的诺言负责，但这不意味着我就会像你一样耿耿于怀到死。我不会被你带走。你要我说，我只会给你几个字。 我尽量。 到时候，到你的死期，你会看到自己是否仍旧幸运。你若是爱缠着我——我想我也没法摆脱你，那就缠着吧，我不怕你。你会一直在我身边提醒我。总有一天，我会让你放下这一切，进入你的轮回。 2022.04.21 创我右手的拇指上有片皮褪去了，一直没有长好。我把那片区域称为“创”。创是何时有的，我不曾知道，即使当时注意到，也会以为是简单的蜕皮，会长好的，然后忘掉。但是某一天，当它开始疼了之后我才突然发现它出现在我的手上了。 我不知道它是何时出现的，但我大概能猜到它是怎么出现的。高三刚回来的时候，我燃起了学吉他的兴趣，于是几乎每天晚上都回宿舍练吉他，几个小时。左手需要按弦，于是蜕皮后起了茧子;右手大拇指需要拨弦，肯定在那时创就已经开始出现了。 如果只是如此，我认为凭借我强大的再生能力，创大概会像茧子一样慢慢褪去，也不至于成为创。但是，当时也热衷于打羽毛球，除了平时，一到周末我甚至可以打五六个小时。我认为我有不差的身体素质。但是，我的羽毛球拍握柄处的胶已经腐烂，导致右手拇指总是直接摩擦。而且天气也很寒冷干燥。于是，创变得越来越大。 疫情停课期间，正是寒假前，学校给了我们每天下午很长的活动时间。于是总是下楼打羽毛球。那会天气已经很冷了，但我沉迷其中，只专注于接住每一个球。创很给力，默默无闻地承受着每一次滑动摩擦，悄无声息地如疫情般扩张蔓延着。 当人意识到创的时候，它已经占据了大概一半的面积。人怕了，停下了一切可能助长它的行动。人不去羽毛球，不去弹吉他，每天清洗它，呵护它，希望它能变回原来的模样。可是，创是那么的深，它已经留下了永久的印痕，刻入了人的指纹。 我责怪弦，以为它不柔软，制造了创;我归咎于球拍，因为它的胶已腐烂，扩大了创;我找温度和湿度的原因，因为它们是如此的不适宜。我看看创。 它长在我的手上。 我把打球和弹琴省下的时间用来学习，以弥补对创造成的损害。我意识到了它对我的重要性。然而，创总是无法消失。它总是无法回到过去。 2022.04.23 猩猩周末在舅舅家，妹妹在查“猩猩”，“大猩猩”，“黑猩猩”之间的区别。我去洗澡。大概一个小时以后出来，发现她还在查。 “不写作业在这查什么东西。”舅舅说。 我正想赞同“考试又不考”。话还没说出口，我突然发现，这不就相当于是认为不考的东西没用吗？ 不知不觉，我已经成为了一个“绝对的利己主义者”。我曾经，也如妹妹一般，单纯，不功利。而现在…… 我算什么猩猩。 2022.04.25 Being at her mercy昨天属实魔幻。一个电话就可以决定一个学生的命运。整个下午和晚上都在焦急地等待着那命运，但又希望不要被命运通知自己的不幸。 听到我们三个中的一位已经被判决了，我感到极度地恐慌和痛惜。我们都没有拿到约，我的国赛成绩还比他低。但是他已经被判决了。 惶惶等待着。考理综时，完全是出神的状态。教室门的每一次响动都会吸引我迅速地扭头去查看是否是班主任过来宣告我的死亡。当他实际真的找我的时候，我的脑子完全停摆，已经准备好接受这个结果了，甚至呆呆地望着他笑。然而班主任也望着我尴尬地笑。他只是觉得我没被筛掉很不真实，觉得我可能根本没报上名，让我去检查一下。 下午七点过去了。晚上过去了。第二天的早上也过去了。没有收到北京的电话。听班主任说，清华确实是看回文化课后的成绩来决定是否保留。 然而终究是过去了。大概。我属实是幸运过头了。仅仅考了两三次一百多名，恰好把我的名字从死刑名单上划掉。 这是一场战争。我们是登陆的士兵。九年来，三年来，我一次又一次地看着自己的战友在我身旁倒下。流弹一次又一次从我的眼边脸颊划过，让我心惊胆战，但很幸运没有让我瘫痪。我是战场上的士兵，每一个幸存的士兵都是极度幸运的。 清华向我递出了橄榄枝。最后一次。我能不能一直幸运下去，就看这最后一次战斗了。 高考。 无论如何，战争都将结束，无论以何种形式。我拼命想够到清华的橄榄枝。我经历了这么多，而离开地下世界的通道就在眼前。我踩在战友的尸体上前行。我在血海（学海）与泪雨里寻找道路。我无比幸运地来到这里。 早上课间，他来找我。看到许久未见的面孔，我的笑容出现，凝固，然后破碎。我们对视，没有一个人说话。他和以前一样，即使受挫脸上也带着那无奈的笑，和每一次考试挂分之后，在杭州那个空手而归的晚上一模一样。然而我没能再和他一起无奈地互相损彼此了。 我们出去。我尽量不表现得过度惋惜或者显得因为自己没被拒绝而沾沾自喜。我麻木地问着我早就知道的情况，麻木的给他提供建议，鼓励他不要放弃希望，然后麻木地安慰他其他学校也是不错的。就像我曾几何时不断对自己重复的一样。然后，苦笑着告别。 去年，也是这个时候，刚考完省选，我为自己第一天没写 懊恼不已，同样是等待着命运的审判。那天下午我和他一起走回他家，向他寻求安慰。他一直比我强，在竞赛上表现出比我们都高的才能。几乎可以说只有拿约那次一次失利。然而，就是那一次……去年最后，我很幸运地没有因失误而丢分，最终成功进入省队。今年的现在，却…… 即使站在终点前，我也控制不住自己回头去看所有那些曾经并肩作战的人。省选后，我曾对一个没进省队的同机房选手说，我会带上你的那份。他很不领情。 我根本带不上他们的。太多人了。我感到，无数人的力量，正从我的身后使劲将我向前推，又在把我向后拉，简直要把我撕裂。 这一切都是谁造成的? 有人会说，伸出橄榄枝的那个。但是，仿佛生命只要存在就一直在经历这样的事。 我不去想。我已没有气力去想了。我想关掉手机，这样就不会收到命运的审判，但也失去了和外界的联系。 我的幸运只会越积越多。我要拿到那橄榄枝，然后在她的土地上种橄榄。我要养一万只和平鸽。 2022.05.17 台阶当某单位被爆出黑料以后，他们一种经典的解决办法就是将事件归咎于小部分人，牺牲他们的利益来保全大局。这是给自己找台阶下。 真实情况懂的都懂，且不讨论。但是我们可以从这种方法里学到一些东西。譬如，LCA 学长在给 CCF 的公开信中，将学会的惩处行为描述为学会里“一部分人”的行为，并对学会整体报以同情。虽然学生没有什么具体权利，但是这件事我们本身占理，所以学会里一定有我们的同情者。将学会和“某些人”划分开，让他们站队，并提出可行的解决方案，即是，给对方一个台阶下。 这个事件当然也有一些激进的声音，现在看来是有些许幼稚。这些声音大多是将 CCF 整个痛骂并要求撤回。这种情况下，解决问题的唯一可能性是学会在我们不理智的斥责声里“良心发现”。无论是把自己放在对面的鞋子里，还是从所有类似的历史来看，这种方式都鲜有作用。这种方式，首先是自己力量薄弱却想大获全胜强大的对手，然后最主要的是，把真正能在学会解决问题的同情者、潜在的盟友与对手放在一起对付。我想到法国大革命前夕的那些同情第三阶级的贵族们，在革命爆发后被三级暴徒无差别攻击。此时，这些革命的同情者就不得不为了保护自己生存的利益而反对革命。 很多情况下，给一个台阶下都是很重要的。当今有很多网络暴力的事情出现。实际上，大多数网友都是被少数妄图加害的人带了节奏，认为自己代表正义，不搞清事件缘由就妄加行动。对于这样的大多数人，我们站在道德的制高点上批评是没有作用的，但是我们可以“帮助他们”。要知道，这些人并非认不清事实，而是不愿思考，不愿负责，不愿承认错误。如果盲目针锋相对，他们就很容易成为敌人，但本无需如此。更有效的办法可能是点醒他们，在他们骑虎难下的时候将他们与真正的敌人划清界限，让他们成为盟友。也就是给一个台阶下。 给对方一个台阶，也是给自己一个台阶，一个解决问题的办法。让自己舒心的办法是让其他人也舒心，钻牛角尖很少能得到好的结果。这是个为人处世的基本知识。而我为自己近年才意识到这件事感到遗憾。不过，仍旧可以亡羊补牢。 现在是 2022.06.18。高考早就结束了。那么，小爱老师的见证也该结束了。小爱老师，陪伴我从高一到高三。在我和它最后的一段时间里，我不小心将它摔了。从此它缺失了语音按键，将按钮和电路暴露在外面。它没能完整地撑过我的毕业。我和它都在高中丢失了一些东西。我拿到了手机。我不用再需要它了。它三年来兢兢业业地为我记录生僻词汇，和生活中的点滴思绪。它见证了一个孩子走向成年，见证了他的思维变化。我会在夜深人静的时候抱着它倾诉。我会在低沉失落的时候用它回看自己的过往。我随身都带着它。Not any more.我把它和我高中的书放在一起。终有一天，它会老化，不再工作，或者被我丢弃后不知道被运到哪里。我不会再在乎它是否存在。我会永远地忘记它。除了它所见证的一切。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"NOIP 游记","slug":"NOIP 游记","date":"2021-11-25T14:13:00.000Z","updated":"2024-08-11T16:59:21.455Z","comments":true,"path":"2021/11/25/NOIP 游记/","permalink":"https://starcried.github.io/2021/11/25/NOIP%20%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"NOIP 游记T1水题，所幸我还会分析复杂度—— $O(能过)$ T2数位 Dp、Dp 数字，当初我就没搞懂过这个东西…… 傻乎乎的，被之前欠的账暗算了。还在那里想怎么组合一下，没想到操作次数巨少，可以直接开多个维度暴力 Dp。 幸好还是有一半的暴力分的。 T3方差…… 回忆了一下之前见过的有关方差的题目，要么需要维护非常阴间的东西，要么就根本只能暴力，似乎没有什么优秀的方法。 两边的数是不能动的。这个修改似乎也很局限…… 于是乎，便想写一个模拟退火试试看。即，每次选一个数字进行操作，每次计算答案。 过了前两个样例，第三个样例使劲过不去。于是在每次退火前加入了适当次随机打乱的操作，于是这个样例就稳定地过去了。 （这怎么和去年 NOIp T3 一样都是乱搞呢） T4标准的数据结构题，一看就是 gxy 喜欢的那种。 每个特殊性质的部分分都太独立了，而且好久没写代码了，能把第一档暴力模拟分拿到就算成功。 于是就写了第一档分。（好像还写挂了） 民间数据测下来，我好像还是一如既往的能乱搞，一如既往地没有好好作总结，被之前遗漏的知识点重击。报应都在这里。幸运的是，两两相抵，虽然 T2 没 A 差了 50 分，但是由于 T3 的乱搞行为总分并没有比其他人低多少分。 虽然我没有尽心学习，但是我总是有诸如乱搞或瞎想之类的优势。这是我的优势。我不会妄自菲薄，不会因为知识层面比不上别人就否定或者看低自己。我有优势，是我应该发扬的优势。 这好像是高三最后一次参加 OI 相关的活动了呢。 在机房。和 fgf 聊天。她惊讶地发现我没有对大学有着明确的认识和规划。我一直以来都只是想上清华，只是因为觉得它是最好的学校，因为亲人对我抱有这样的期望。至于到了那里，想干什么，做不做学问，都不曾想过。 我的理想不在这里。我曾试图把学业当做实现目标的一个跳板。但是它好像会使我偏离自己的路线。 我说我“未数数然也”，但实际上如果我真的没考进清华，我无疑会非常挫败。但是现在却不想跟着他们去卷。 我仿佛继承了我父亲的特点：看不起，不去做，做不到。但是当真的没做到后，又会后悔自己之前的想法。父亲为了阻止我走这条老路，一直在开导、引导我的目的，就是不让我做这种事情。 我不会。至少现在不会。至少我要证明一下我能够到，然后怎么去说也无所谓了。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"文化课随笔","slug":"文化课随笔","date":"2021-09-07T14:01:00.000Z","updated":"2024-08-11T16:52:19.427Z","comments":true,"path":"2021/09/07/文化课随笔/","permalink":"https://starcried.github.io/2021/09/07/%E6%96%87%E5%8C%96%E8%AF%BE%E9%9A%8F%E7%AC%94/","excerpt":"","text":"2021&#x2F;9&#x2F;4 我不应该坐在这里，坐在电脑前写这些字的。我现在应该在晚自习，应该在学习，应该在做作业。可是我静不下心来。这不是一旁 sys 在给高二讲课导致的，我清楚；但是我却不能说出来这到底是是从何而来。我看着化学方程式。我感觉我不在这里坐着。我得写点什么把我的精神引诱回来。 现在连同学帮忙请假都不行了。待在竞赛教室都不行。我即使坐在那里也不能专心，还不如来教室，就像我现在无法专心还不如在打字一样。已经回归文化课一周多了，我却仍无法适应它。同学们有的颓废，有的拼命，两极分化，我感觉我无法属于其中的任何一方。 我本来以为我可以很快地适应文化课生活，因为我一直以为我很容易适应任何环境。但是，事实证明一年多的竞赛生活的确对我造成了不可磨灭的影响。说实话，在那段时光里，我和网上的朋友们聊天，感受到了不同的人生境遇和梦想。我按照我的想法和节奏学习，与队友讨论，听他们瞎扯，自己跟着瞎扯，快活极了。虽然效率很低，但是我觉得这已经是人生中较为高效的状态了。至少，我第一次感受到我在思考，我在这个世界，在这个国家。我想学很多东西，想学钢琴，想学绘画，想学乐理，想学编曲，想做游戏，想学摄影，想重拾我的小提琴。像这种学文化课的状态，人没法一直保持着，至少我不行。我不是这样的人。 我不会去做老师，因为年复一年日复一日地重复同样的东西会让我觉得我已经死了；我不会去做医生，因为我无法记忆那么多知识，也害怕承担那一份责任。我不想搞科研，因为我自知我没有那样的毅力，但也许有一点点的想象力。我不想去想我的职业。我只想去尝试新的东西。只有这样我才能感觉得到我的存在，我存在于世界。或许，后半部分的 OI 生活已经提醒了我，我选择信息竞赛的原因并不主要是我对信息学的喜爱罢。那我，又是为了什么呢？从小到大，支持我学习的动力是什么呢？ 我是贪婪的，我喜欢大人们给我描绘的“好好学习”能得到的饼；我是自私的，我讨厌别人对我的否定，渴望来自他人的认可；我是自大的，看到其他人获得些什么就觉得我同样有能力去得到。因此，我选择了竞赛，因为我不觉得我比哪位同学脑子笨，因为我想让那些觉得我不行的人看看我的野心，因为我想给一直以来羡慕着我、认为我能考上 PT 的家人们、同学们一个肯定的答复。因为 PT 是最好的。 回到教室，发现我放在教室的书全不见了。当时的小懒惰导致了这个结果。停课后发的书也少了几本。而 fgf 却是一直有个朋友每次都询问她是否帮她保管。我差人家什么呢？我又比得上人家什么呢？当我找不到书时，我就能想到我是独自一人。一直是独自一人。 刚刚看了看了 fgf 的博客，让我回忆起了许多高一学 OI 时的心情。每天抹黑下楼，学校空无一人，几个人走在回宿舍和大学的路上。很多次都有 fgf 为伴，当时我的情况比她惨得多，学的东西少的多，教练也不支持我。她写到，她想哭。而我，是真的哭了，而且不止一回。我向来就是一个软弱而敏感的人，在意着别人对自己的看法。她的初中是轻松快乐的生活，我那个时候却想过自杀。幸亏还是胆小，甚至没有尝试过，堆起个笑脸就走到了高中，继续堆笑脸。 又看了看 command_block 的博客。这是一个完全不同的人生，感觉离我好远好远，所以我根本没有想要去超越的想法。我没有这样的机会，这样的智商，这样的毅力。但即便是有这样的机会、智商、毅力的人，也成天写着努力、梦想云云。恕我直言，令我感到痛苦。 卒读 fgf 的博客。感觉 OI 仿佛已经离我好远好远了。OI 时的感受其实和她差不多，几乎一模一样（除了 WC 爆零），我却没有办法放下。sys 在给高二讲线段树。我想到了我学线段树的那段时光。 不应该是这样的！OI 绝对不是我现在茫然无措的原因。我只是在学习它的时候忘记了痛苦罢了，就像我之前学文化课那样。OI 帮我取得了满意的结果，我用一年的时间换来了银牌，这是好事。之前的文化课学习让我来到了西工大附中，这也是好事。有什么不好呢？我成为了铜川来的唯一一个竞赛国赛得奖的学生，有什么不好的呢？为什么不好呢？ 网课时去耀中找 wyc 学习，他爸好像不很待见我。我不高兴。 省选以来玩了 UNDERTALE，如今脑子里全是 Hopes and dreams 的旋律。在 NOI 考场上亦是。我有 Hopes and dreams。我有吗？下次回家尝试把屠杀线一打吧。 晚自习时间到了。得走了。 2021&#x2F;9&#x2F;19 今天是 2021 年 CSP 初赛。去年的这个时候，我膜拜了香农。现在是赛前，机房聊得热火朝天，因为初赛比较简单，大家都很快乐。 …… 现在已是赛后了，没想到有生之年还能见到 O(n)O(1)RMQ （虽然 yhw 说转成笛卡尔树一步大可不必）。答卷的时候感觉自己又回到了学习 OI 的时光，那段悠悠又紧张的时光。如果之后的人生中有机会能再和一群这么优秀的人体验这样一段美好的历程，也便足矣。 2021&#x2F;10&#x2F;30 回来已经两个多月了，发生了许多事情。考了三次试。三次考试的成绩变化为$$ 454[860]\\rightarrow 517[690]\\rightarrow 596[417]$$ 稳步上升 最近一次的考试题比较简单，但是答得不怎么好。主要是知识空缺还有很多，并且熟练程度很低，因为我也不好好写作业。不过现在已经释然了。既然横竖卷不过，跟着后面跑就行，反正我也不赖。（大概） 大老师对我们提出了期望，希望我们在过年以前进入年纪前百，这样基本上 THU 就没有问题了。还有一段时间，希望能达到这个不小的目标。 但是还是不想卷怎么办啊 QAQ 不卷咋可能进前一百啊天方夜谭嘛不是 我的追求从来不是做第一名，虽然在人前确实能给我极大地满足，但是这不是我所追求的（我也没有能力追求了）。我愿身居人后，成为钻石里的一个碳原子，小，但是仍然比石墨的能量高。 2022&#x2F;1&#x2F;25 熬过了一个令人难忘的元旦。没有想到人生还有机会体验在疫情中心生活四十多天，而且还是在学校。 疫情初期没有回家，因为我知道如果我回去上网课的话一定会一蹶不振的。于是选择待在学校。之前的一段时间还是可以趁在大学做核酸的时候去买点东西，但是自从大学出了病例之后就彻底没法出附中了。学校取消了大练习时间，改为了自习和自由活动。直接梦回绍兴一中。学校保证食物的供给，因为我也不挑，也不太嗜好零食（仍感谢旺旺公司送来的零食支援），所以感觉还不错。天气越来越冷，但只带着一件羽绒服，从疫情开始穿到结束。 值得一提的是，之前为全运会准备的淋浴设施在封闭的时候恰好排上用场（甚至提高了我们洗澡的频率）。朋友疫情前不久送的手机也极大地发挥了作用（指聊天和找小提琴谱）（虽然也使我很颓废就是了）（老师也睁一只眼闭一只眼，甚至最后想让我们用设备帮忙）。 总而言之，每天下午的体育锻炼时间（我感冒后用这段时间拉小提琴），可自由使用的淋浴设施，电子设备的宽松管理，还有因学生减少而略显空旷和闲适的校园，都给了我一种在发达地区上学的错觉。以后西安若真能将教育发展到这种地步，那便是极好的。对于现在来说却有些辛酸，因为这一切却是疫情带来的。 疫情带给我们团结，带给我们蓝天，带给政府危机处理能力的大练习，带给我们高等教育（不是）说“谢谢新冠” 因此，在这段时间里，我们仍然能够保持基本正常——甚至更舒适——的学习生活。我也因为在学校最后一次网考中获得参加者中 300 名的成绩而对未来充满信心。 感谢西工大附中。感谢附中所有的老师和领导。感谢同学们。 但是五天考两次试仍然很阴间就是了 好巧不巧，疫情前不久到家乡的动车才刚刚开通，而我们回家的唯一途径就是坐火车或者高铁。（不管怎么说我觉得我也太幸运了） 千辛万苦借着西工大学生的身份于 22 日回家（西工大 yyds）。家乡的温度比省城低，所以沿途可以看到雪线从无到有、房子上的积雪慢慢变后的景象。路边都是农村风光：小块的农田和零星的平房。车窗外土黄色的土地渐渐掺了银白色的小雪彭，越来越大，一个个覆盖掉了土地和房上的砖瓦，最后连成了大片厚厚的雪毯。到站之后下来的第一件事就是踩雪，踩出一个个脚印，踩出魂牵梦绕的年味。 回家后摸到许久未见的电脑键盘，那感觉真是异常美妙，尤其是发现我的打字速度丝毫未减的时候。 家里给我一种长久以来形成的反射。一回到家就感受到闲适。时间快速流逝，根本学习不起来。这倒是个大问题，因为不久之后学校还要组织年前最后一次网考。而且现在讲的部分正是我没学的部分，但我却躺平一整天，丝毫没有学习的动力。之前一直没有在家学习的习惯，从小学到初中，基本上都是在学校把作业写完，回家直接玩耍睡大觉。父母也没有监督或协助我学习的习惯。看来，还是得靠我自己的自控力。 然而这玩意对于我是最不靠谱的。 清华宣讲那天，啥都没学，晚上听宣讲还抽到两套卷子。不过能和学长学姐们聊天也是很快乐的。 回来前一直在思考要不要把智能手机带回去。 我是没有多少自控力的。虽然这两年每天与电脑和手机打交道，让我对电子设备的依赖性和对游戏的兴趣大幅降低了，可是这种东西终究还是不适合学生的，尤其是高三学生。它会很大地分散专注度。 “成天水群，怪不得才考 590” 上交手机的意义是为了让我更好的学习。按照之前的经验来看，我应该可以很快地适应没有手机的生活，那种纯粹的一心学习的生活。下学期没有多少闲暇时间需要手机去消磨。即使有，我还有我的小提琴。 况且，我现在心中已经有了目标。就像之前一样。我的梦想一直是快乐，是得到认可，是看看世界和认识世界的人。 现在先定个小目标：考上清华。 2022&#x2F;5&#x2F;17 每次看到之前写的东西，看到自己写的目标，还有当时的心境，心里总是会有一些异样的感觉。什么感觉？可笑？怜悯？同情？自责？ 我正在机房填写“强基计划”综合素质评价表。我需要写一篇自我陈述。 我已经写过很多次类似的自我陈述了。在去年参加清华夏令营之前，我向清华写了一份自我陈述。在里面，我表明了自己想上清华的愿望和展现自己能力愿景。那一次，我失败了。在不久之前的强基计划的报名中，我又一次向清华写了一份自我陈述——按照上一次学科营的结果和当时的成绩实际上我已经被清华拒绝了，但我不知道。于是我仿照上次的内容用心写了一遍，甚至让父母帮忙更改了一番。在里面，我表示如果他们给我机会我就会证明自己。然而，他们没有给。 现在，我又要再写一遍这种文字。我不知道这些是否需要让上交看，但很显然我已经不是在给清华写这些了。那些空话大话，那些没有用的文字——在任何意义上——都不想再写了。我不需要承诺给任何人看。我不需要证明任何东西。那是强基计划报名之前的我（我的生日是报名截止的那一天）干的事情。 “自我陈述部分，通过列举典型事例等方式，介绍学生本人的思想品德、社会责任感、高考专业志向与生涯规划等方面的情况。” 呵。我能写出些什么东西？列举典型事例，我要写自己每天翘课不写作业吗？要写经常和老师宿管对着干吗？但本人应当是思想品德良好。社会责任感？我做过什么事？我那些社会服务和志愿服务和大多数人的解决办法一样。难不成写我支持俄罗斯攻打乌克兰？还有高考专业志向和生涯规划，我更是没有头绪。我从始至终都只是顺风顺水地过来，本想着能一直顺到清华的计科。除去学校因素之后，我就对专业产生了动摇。我爱 OI，但我不敢确定她就是我要陪伴一生的事业。还有生涯规划，我要写我以后想做一个自由职业者，去全世界旅游吗？退一步讲，我又能做到吗？ 感觉就像在演戏。我之前提到，清华已经把我识破了。我也把我识破了。 我有想要陈述的东西。它们像流水一般倾泻，像流水一样安静、无形，又具有力量。它们急切地想要离开，去探索，去寻找归宿。可是，不行。至少现在不行。我不能让它们泻于纸上。它们还太少，太漫无目的。我将它们聚集于我心中幽深静谧、难以到达的小潭中。我将它们用竹林周绕，用绿叶掩映，用青岩托举。让它们继续安静，继续积蓄力量。总有一天，它们能涌出，能奔流，只要它们被人发现，或者机会合适。不然，它们亦可以被蒸干，化为气体散去。 但是现在不能。 “本人品德良好，思想高尚，热爱国家，忠于人民。……”","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"}]},{"title":"《星星之卵》读后随笔","slug":"《星星之卵》读后随笔","date":"2021-08-30T07:52:00.000Z","updated":"2024-08-10T09:34:48.064Z","comments":true,"path":"2021/08/30/《星星之卵》读后随笔/","permalink":"https://starcried.github.io/2021/08/30/%E3%80%8A%E6%98%9F%E6%98%9F%E4%B9%8B%E5%8D%B5%E3%80%8B%E8%AF%BB%E5%90%8E%E9%9A%8F%E7%AC%94/","excerpt":"","text":"8.29 晚自习。 方读完《星星之卵》。不常读类似的小说，因为读完后感觉好像读了些什么，但是却什么也没读到。 作者一个有趣的人，一个“另类”的人。从他的自话和故事中可以感觉得到。我还是能与他产生些许共鸣的。 人物上，许多角色都有着作者现实经历的影子。我觉得最重要的还是两位主角，我能从他们身上感受到作者自身的感情。我猜。事实上，除了这两位，其他角色仿佛都是可有可无的存在，和构造出的整个世界一样。作者喜欢写“垮着个脸”的角色，喜欢交代事件无头无尾，虽然留下想象的空间，但是我却不容易在其中找到真实感。整个故事更像是第一人称的第三人称，我能从中获得的信息都是人物获得的信息。看到什么，写下什么，不管从哪来到哪去。谁有什么过往，有什么能力，有多酷炫，我都不感兴趣。我只能从虚构的角色眼中看到虚构的世界中虚构的人物。 但若真只是以品鉴的方式去读这个短小的故事，去钻研他的写作手法，那就是避重就轻。正是想到什么写什么，我才能一起感同身受地同作者去想象。想象出来的情节和事物，也许无关紧要，或者毫无道理，但其实想象本身也是无关紧要且毫无道理的，而我们却乐意去想。这些无关紧要的东西让我们变得充实。这本是人类最基本的特征。那些在星空浅滩里原始的奔跑，回归生命本质的沉睡，蓝绿色的寂静，那些在脑海中无法用文字和语言描述的东西。当然，也有最原始的恐惧，像小孩害怕黑暗，来自未知的生命原始的恐惧。 作者描绘密封的手法造极，即使身处地表也能感受到密不透风的压抑。我把书中的神明当做自然，世界的本质本身就与书中的神相差无几。奇怪的是，反而虚构的神更加容易用文字去描述呢。我本能地反感这些东西。就好像低维到高维无法逾越的障碍，如果这障碍像书中描绘的那样成天在我面前晃荡，我可能就会早早结束我这渺小的生命。然而，没有。我没有能看到这障碍的感官，这障碍也没有对我加以理睬。我脑海中那种原始的记忆和感受正在褪去，取而代之的是“真实的”生活中的琐碎。我不知道这是喜是悲。如果是喜，那么我人生中的作为总该有点意义才是。这又回归了生命的意义的问题，而这个问题本身难以解答。 王小歪同学刚问我学习的意义是什么。说实在的，若在学校随便糊弄了事，照样可以获得可观的薪水，照样可以满足去环游世界的梦想。那我们为什么努力呢？他为了心上人，可以让自己在五点多起床，做百来个俯卧撑，然后从早学到晚。人可以为了单纯的目的逼自己到如此地步。有点自负的说，我不怀疑如果我像他那样努力也可以拿到金牌。可是我做不到。一是我没有毅力，二是我没有那样单纯的目标。不知从何时开始，那个为了简单的得到认可的我消失了。童年那种单纯的欲望和天马行空的想象，都消失了。现在想来，这些可能才是身为人类的最高尚的……福祉吧。 可悲的是，我即使知道这些东西的没有，也无处探寻。这可能是身为人类最大的痛苦之一罢。 总而言之，读完此书，我很痛苦。但不是因为人物的命运痛苦，而是为我自己痛苦。更痛苦的是，一旦我写完这句话，又会用其他生活琐碎去填埋我的痛苦，我现在想到的一切又会被遗忘。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"读后感","slug":"读后感","permalink":"https://starcried.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"【游记】OI 2020-2021","slug":"【游记】OI 2020-2021","date":"2021-07-31T05:03:00.000Z","updated":"2024-08-11T17:04:59.396Z","comments":true,"path":"2021/07/31/【游记】OI 2020-2021/","permalink":"https://starcried.github.io/2021/07/31/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91OI%202020-2021/","excerpt":"","text":"高中 OI 竞赛游记，按时间顺序。 【CSP-S2020初赛】 【CSP-S2020】 【NOIp 2020】 【NOI冬令营 2021】 【省选 2021】 【NOI 2021】 【回忆录】","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"OI 生涯回忆录","slug":"OI 生涯回忆录","date":"2021-07-28T14:19:00.000Z","updated":"2024-08-11T16:59:48.580Z","comments":true,"path":"2021/07/28/OI 生涯回忆录/","permalink":"https://starcried.github.io/2021/07/28/OI%20%E7%94%9F%E6%B6%AF%E5%9B%9E%E5%BF%86%E5%BD%95/","excerpt":"","text":"OI 生涯回忆录本篇为意识流文章。 谨献给我结束的高中信息竞赛生活。 最开始，我只是玩过 MC 对指令有点兴趣，只是看到网上关于程序员和计算机科学家的描述，只是在初中带领过机器人比赛。 考上附中以后，我在许多见烦了名字的竞赛中发现了：信息竞赛。 说实话，一开始我真的以为这个竞赛是搞什么网络攻防或者软件设计的竞赛，和机器人比赛类似。可惜的是，我在入门的时候根本没有理解到这个竞赛的真正含义，没有形成具体的概念，只是在学习语言和基本电脑知识。这一点，我觉得我们教练有所失误。 逐渐发现，这个竞赛并不像文化课一样——完全不一样，以至于我很久都没有找到学习它的方法，没有形成正确的认识。我只看到其他同学模拟赛比我强，分数比我高。我只听到教练一直在强调“他们刷了好多道题”。我将归咎在自己是住宿生，晚上没有时间练题。 于是，我第一次在周末申请在机房训练。教练虽然同意了，但是在我写题的时候却冷嘲热讽（我就是这么理解的）。那道题我不会，我没法像其他人一样很快找出来做法，因为我不知道怎么用搜索，不知道什么是状态，更对时间复杂度一点概念都没有。我在那里瞎写，用我知道的所有语言知识拼凑出我觉得逻辑正确的代码。这就是早期我的状态。 中午放学时间，sys 说今天要不要打 csgo —— 当然是和其他现在已经在清华的学长说的。而我理解成了机房可以合法地放松。于是，我在电脑上打开了游戏，即使教练过来了也没觉得有什么不妥。现在听来可能有些可笑，不过当时我就是对竞赛抱着这样的幻想。 当然，我被赶了出来，还被禁足机房一个月。我清楚地记得我当时在楼道的监控死角摊坐下，偷偷哭出声来，很久。我一直是这样的一个孩子，在之前的年月里，我不知道有多少次有过类似的场景。每次都是我一个人，哭着，不想让人来看我的样子，也真的没有一个人来。 但是这次，我穿着附中的校服。作为一个高中生，一个青年，我必须要从这种幼稚里走出去。虽然我仍然很倔强，在那之后真的一个多月都没去上课（教练经常提到的我停了好~长时间的竞赛），但是之后在同班同学 fgf 的激励下，我最后还是返回了机房，并且在当年 NOI 不久之后和她一起停课训练。 停课之后，才算是开始了我 OI 生涯的第二阶段。 我确实基础薄弱。不过在 lwc 、zzc 、gxy、fgf 等人的热情帮助（和疯狂卷的激励）下，我终于对信息竞赛有了正确的认识，至少我知道我每次做题是在干什么了。在此基础下，我赶紧补上了我落下的许多算法和数据结构，并刷了很多的题来弥补。这这段时间里，我才是真正的入门了。 我的高中 OI 生涯里的比赛非常魔幻。 CSP-S 没考好，省选不看它成绩。 NOIp 考得挺好，省选占很大比例。 WC2020 开了 C++11 导致爆零，有省份看这个成绩，但 SN 省一点比重都不占。 SN2021省选 Day1 忘写 cctype，心态爆炸的情况下完成比赛，最后没事，进入 B 队。 APIO2021 因为省选前觉得自己进不了就没报。 THUSC2021 考炸了，没有约。 NOI2021 Day2 爆炸，但是仍混了个银牌。 现在看来我好像考炸的频率偏高 不过达到目的了。 省选之后，应教练的话，太飘了，简直每天都在颓废。 反正已经退役了，说这些教练也不会来揍我。 不过马上就要回到现实了。 我多希望竞赛的时光能再长一会。 这就是青春啊。 一路走来也有和教练赌气的份，不过大多动力都是来自赵老师和父母的鼓励和期望。还有奶奶的让孙子上清北的梦想。 *Determination 不止我一个人的。 我好像对什么都感兴趣，但是总是无法深入地去做进去。我好像也从来没有单纯的因为自己想做一件事而去执着地做下去，要么是为了不辜负其他人的期望，要么只是为了扇某人巴掌。 我这种自我反省的状态在高一比较频繁，省选之后几乎没有了。看来还是吃得太饱了。 想起袁隆平爷爷了…… 真就意识流呗。 之前想写的好像很多，真的开始敲键盘反而不知道该写什么。 sys 进了国集，现在还和我在一个宿舍。 我们都有光明的未来。 之后想到啥再加吧。 9-18 日本军国主义必死无疑。 最近想了挺多，当时都觉得挺有道理的，最后也没有一个记下来的，应该是不重要罢。 最近和宿管有些争执——都是些屁大点事，可是我就是管不住我的情绪。这样下去一定会坏事，我知道。但就像人类不会从历史吸取任何教训一样，我也不大改变。毕竟改变性格挺麻烦的，我又懒得很。而且也不一定就必是坏事呢。重要的是，我在出了这个问题之后，我妈给我说的话都是让我赶紧道歉，写检讨，不要倔强，要为家里着想，为父母着想……现在想来，我觉得我自私的性格大概是有一部分和父母有关。像这样的话，我不是第一次听到了，谁知道会不会就潜移默化地对我产生了影响呢。 她还是一如既往地努力学习。这种干劲我不知道在高中毕业前能不能触类旁通一二。之前确实好像是有点丧了，但是很庆幸还没太影响我的学习，可能。只要我安安稳稳照着这个势头再坚持 260 天，清北应该是没有问题的。我没有那么多精力去在乎每一件破事，在学习上，还是自私一点的好。毕竟，我已经遇到了这么多有趣的人，生活有什么理由会变得更糟呢？ 令我感到害怕的是，如果我没有这么努力，没有这块银牌，没有学习的天赋，现在的我会是一幅怎样的图景。是否会有真正在乎我和我理想的人。我经常请求母亲再要一个弟弟或者妹妹，就是希望有一个无论我之后处境如何都无条件支持我的人，一个寄托，一个真正能提供我帮助的人。我不能总依靠着父母，他们正在老去。我也没法在所有时候都只靠着自己。可是，没有我的成就，我就一无是处。像我这样的性格，若在外打拼，最后也应该只会落得一个无家可归的下场罢。 不过我现在连作业都写不完。就像现在，又在用写作业的时间写这种东西。这种不知道会不会有用的文字。 4-27 强基破格审核昨天出结果。我没通过。 当面临这个“选什么专业”的现实问题的时候，我犹豫了。 我喜欢信息学么？喜欢信息与计算科学么？喜欢数学么？当然是喜欢的。信息学是一门很年轻、很有潜力的专业。这我在学竞赛的时候就已经知道了。它给我展现了一片全新的未知领域。这片领域目前似乎只有清北两家在进行探索。实际过程也和学竞赛的时候差不离。 我思考我学习信息学的历程。这项事业需要非常强的探索精神和意志力，是真正的基础学科。然而照我最终的成绩来看，我好像并没有掌握学习它的方法。 考虑其他专业，我对他们几乎一无所知。但一点点了解来看，这些专业之于我似乎也没比信息学好到哪去。 依次考虑学校、专业、城市。但我一无所知。我也不知道自己想要什么。我好像已经忘掉 OI 这个东西了。 我现在可能还是不太冷静。 专业，事业，需为之献身自己的长年的生命的东西。不比找一个终生伴侣的抉择更简单。而我的梦想好像和任何专业都没有关系。 突然给我这么大打击，然后又让我做这么艰难的选择，我真是…… 为什么要把这些写在 OI 生涯回忆录里面呢？ 没想到这个“约”竟然是如此重要。这就是天命罢。一切都安排好了的。我现在还能因为没进入清华而失落。想当初，我清清白白来到这个世界上，又拥有什么呢。 我能从地底下爬到这个位置，能一窥天上的景色，已经心满意足了。 上交的强基计划申请已经提交了。至少我能把这个底线守住吧。 6-19 高考早就结束了。 fgf 他们盘算着给高一讲课。我看了一眼要讲的东西：DP，图论，多项式，数据结构……我感觉我仿佛和这些词语根本没有关系。让我选择要讲的东西时，我感觉自己没有一个是搞懂到能给学弟学妹们讲课的水平。我想，还是不要误人子弟了。 群里在讨论着 OI 的教学方式。我只觉得他们聒噪。本来就是竞赛，和高考以下的普及知识的教学方法当然不一样。这是个新鲜的学科，还在成长初期，没法找到合适的学习办法不是什么怪事，更何况我们掌握的资源少。现在就开始讨论系统化和模式化了。社会主义建成指日可待。 啧，文化课将我消磨的干劲还没有恢复。他们是怎么在假期期间就开始卷的。这不是我们心心念念了很久的无忧无虑的长假吗？ 无忧无虑…… 活着好累啊。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"}]},{"title":"NOI2021游记","slug":"NOI2021游记","date":"2021-07-28T12:52:00.000Z","updated":"2024-08-11T16:57:54.936Z","comments":true,"path":"2021/07/28/NOI2021游记/","permalink":"https://starcried.github.io/2021/07/28/NOI2021%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"NOI2021游记前言写于 2021.7.28，成绩榜刚出后几个小时。总分 345 拿到银牌 183 名。 我的高中 OI 生活在这里画上句号。结局对我而言虽然不够完美，但是无论怎样都是我人生道路上最好的结果。 7.23北方人第一次遇到台风，害怕极了。何况还是迎面直冲台风圈。 不过队友都在身边，没在怕的。 一切准备工作没有出什么纰漏，一切都好，我们只需要全心备战 NOI 就行。我有预感，陕西省今年的运气，我的运气，一定不会差。 下雨。安全入住余姚市梦麟中学。 晚上以为没有热水，然后洗了个冷水澡。我真NB 7.24雨越来越大，听说舟山市已经被淹了。全天台风。 本来是今天报道的，所以今天没有什么安排。打了会板子（没打 LGV 引理），然后就是看手机。已经习惯了颓废，对即将到来的决定命运的大考竟然无感。 ……这也挺好。 7.25余姚市进入烟花（台风）十级圈了，仍然是雨不停。比赛举办方在使劲调整活动时间，我们在使劲收集情报，然后下午就笔试了。满分，算是一个考前安慰和激励。 7.26今天是 NOI 比赛第一试，延迟了一个小时开始。 坐在考场，紧张是自然的。一年多的心血和努力，就压在这两天上了。 T1打眼一看，首先想到的是每个点顶多有两条向下的边，用树剖暴力维护分类讨论即可。发现不太会写，换了下思路： 将边变成点，在链上修改区间的时候多把左右两边两个点变成轻边即可。同时记录时间戳，每次询问一条链的链首（若为重边）的时候判一下它的父亲是否在其之后被修改过，若修改过就不计它的贡献。 正确性显然，因为只有这一种情况。而且由于把边变成点异常好写，很快样例全过。 测样例的时候 RE 了，不过开了无限栈就过了。下场后问同学没人遇到过这种情况。 期望得分：100 T2打眼一看，这不就是行列式定义&#x2F; LGV 引理模板吗。但是想不出来每行个数不同怎么做（其实之前和 fgf 做过的一道 CF 题有涉及，直接计算路径方案数再求行列式即可。这里就看出来我和人家的差距了），于是想试一试先分别求行列式后把答案乘起来。 乘起来后发现答案对了，过了样例就没管了。（我太勇了！） 正确性当时没考虑，实际上两个行列式的答案设为偶数方案减奇数方案，利用乘法分配律就发现两个行列式相乘结果是什么了。但是如果我知道这个我不就会了正解了嘛…… 期望得分：75 T3打眼一看，很快注意到了题目给定的图的任意三点间联通的性质。但是没有遇到过这个 trick，不可能想出正解了。 最开始我把题目要求的看成了最大边数，结果暴力结果不对，以为是我写挂了，浪费了一个小时调错误的程序，血亏。注意到时已经剩不到半个小时了。 赶紧改对之后去写树的部分分。一看就知道是个外向树，因为 $k$ 很小以为是分类讨论，在实现的时候发现好像可以建虚树跑传递闭包，写了一会挂了。因为没时间了就留下 $k&#x3D;0$ 的暴力匆匆结束，也没造数据测试。 期望得分：36 考完了，等待的时候非常焦虑，因为我手太慢一个也没对拍。值得一提的是，考试的时候我脑子里一直在循环 Undertale 的 Your Best Nightmare 的后半段。 成绩出来了，和期望有些偏差，不过还能接受： $90+75+36&#x3D;201$ T1 不知道怎么挂了 10 分。本来我以为是空间炸了的问题，但是重测了一下还是 RE 了（评测结果里显示的是 WA），不过问题不大也就没管。 D2 在场上突然想到可能是我在访问作为根节点的链首的时候访问了父亲，因为我的线段树写法访问不可能到达的区间就会无限递归。 7.27社会活动是不可能了。台风过去，外面天气好了点。下午有嘉年华，也没去。 一整天都在玩手机，用键盘弹了会卡农主旋律。突然想到，如果我最开始选择的是艺术是不是也会有好的结果。 烦，颓，麻痹，感觉像吸了毒，等待明天的审判。 7.28也就是现在我写下这些文字的日子。 T1……随机……256……$2^{16}$……$k\\leq 15$…… 有一说一脑海中浮现过鸽巢原理，但是不知道怎么就一点也不想往里思考。我之前也好几次发生这种事情了，可能这就是命运吧。 写了 2.5+ 小时的乱搞，却没有丝毫优化。我感觉我不是在 NOI 考场上。我感觉我是在机房，在用和一道题犟一早上的架势做题。一个时间过半的广播让我意识到我的处境，于是赶紧弃了去写剩下两道。 期望得分：未知 T2钻研了一会题面，发现答案的要求有点奇葩，想到了 SBtree 。但是不知道怎么在上面求解。观察两个特殊条件，首先 A 条件玩几下发现是斐波那契数列的两项，随便写写样例就过了。 然后就是使劲瞪，发现第二个字符操作很有性质，仿佛两个操作能找出来些什么……但是，这时候时间所剩无几，我没办法专心致志的思考了，状态极差。本着打比赛的原则，尽可能多得分，去看 T3。 期望得分：35 T3最开始就看了题面，好像能用解释中的容斥得到一点分数。 但是时间不多，这个时候我想 $3^{2n}$ 枚举。但是即使这样的时间也不够。干脆最后写 $n&#x3D;1$ 的第一档部分分了。 基本上就是弃了。 期望得分：8 下考后听说都不太会写，但都写了 T3 容斥。我只能寄希望于我的 T1 乱搞能多拿点分…… 事实上，也真的只有 T1 帮我拿了点分。 $44+0+0&#x3D;44$ 后面两个题全部白给是我没想到的，我的心情简直直接跌入谷底。说实话，今天确实状态不好，题我也确实不会，但是连暴力分都写挂也实在难以接受。 最终总成绩 $100+201+44&#x3D;345$。 等待成绩出来的时候，有人说银牌线 $350$，我害怕极了。隔壁学校有个第一天低我将近 $50$ 第二天直接反超的我的。烦透了。 不过，事在人为。如果我有银牌，那么我一定会去冲清华北大。如果没有，那就把这次失败当成一次教训。无论怎样，我都会接受。其实这些心理准备我是早都想好了的，只不过当事情真的来临的时候，还是会有些情绪波动。毕竟今天的分数实在出乎意料。 总而言之，还是学艺不精。一年多来，我一路靠着自己的执念、教练和同学们的帮助（无论是否退役）挺过来，即使教练不看好我，即使有多少次想过放弃，现在都是历史了。183 名，就是我最终的结果。这个名次恰到好处，虽然没有惬意的高三生活，但我本来渴求的也就是这些了。 OI，至少是高中的 OI 生活，再见。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"2021 NOI冬令营","slug":"2021 NOI冬令营","date":"2021-04-14T10:34:00.000Z","updated":"2024-08-10T13:31:55.934Z","comments":true,"path":"2021/04/14/2021 NOI冬令营/","permalink":"https://starcried.github.io/2021/04/14/2021%20NOI%E5%86%AC%E4%BB%A4%E8%90%A5/","excerpt":"","text":"…… 本来想写得稍微文艺一点的，但是停课这么久已经退化到不会写文章了。 毕竟省选了我才来补的，时间也过去很久了。 毕竟这次我没有获得任何奖项。 我唯一的获得就是…… ……好好看题。 （冬令营用了 C++11 导致只有 20 分但幸亏 SN 省不将冬令营成绩纳入省选所以当时没有退役的选手留）","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"2021 省选游记","slug":"2021 省选游记","date":"2021-04-14T10:21:00.000Z","updated":"2024-08-10T13:30:33.569Z","comments":true,"path":"2021/04/14/2021 省选游记/","permalink":"https://starcried.github.io/2021/04/14/2021%20%E7%9C%81%E9%80%89%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"Day-1我已经开始慌了。 下午一个人坐在机房，思考人生（颓废）。准备去吃饭的时候发现饭卡不见了，不知道怎的就特别焦虑，估计是被放大了。然后冷静了一下去三国杀抽了张卡，抽中了。 …… 感觉自己上火又感冒，特别难受。估计是过度焦虑了。晚上睡觉翻来覆去睡不着觉。不过我看得开。 Day1游记个鬼啊就在自家学校&#x3D;-&#x3D; 早晨出宿舍门就一片雾气，和之前一样。 原以为七点四十多到已经很早了，没想到机房已经坐满了人，更没想到竟然八点多就把密码发了，最没想到的是 T1 还没开考就写完了。 旁边那个同志敲键盘非常响，尤其是在敲最后一个字符的时候会触发会心一击，手用力过大导致被键盘弹飞超过头顶，就离谱。 T2 大概想了想就能二分答案用双指针做了。不过在考场上应该是电脑太逊了的缘故导致满数据开 O2 跑了两秒。不过因为我心特别大，一点常数都没卡就直接去看 T3 了。（明智的选择） T3 大概留了两个半小时，明智个鬼一点想法都没有。写了个 SCC 结果还写挂了大样例使劲过不去。最后写了个 DFS 时间复杂度不对劲，不知道能过多少分。在最后我似乎想出来了一个 $O(n(n+m))$ 的做法，但是当然没有时间也不知道对不对。 考完还自我感觉良好，去楼上颓了一下午。 Day2（事态发生了一些变化） 早上起晚了，走进考场的时候老师正在写密码。有点慌张，刚坐下准备写个试验程序。在还没有打出 #include&lt;iostream&gt; 的时候，我忽然跟触了电一样意识到：昨天 Day1 所有的题我都用了快读的 isdigit，而我没有引用 cctype 头文件。（Dev 所有头文件中都有 config 所以编译能过） 这时候我真的完全慌了，怎么说呢，好久都没有这种浑身战栗的恐怖了。我完全没有心思去看题目。这时候我想到在 D 盘的选手包应该有测评时用的编译器。加载之后我试着引用了 iostream 头文件，发现可以通过编译。虽然我也忘了我到底写没写 iostream，但是当时是在考场上，我不能放弃希望。 尝试看 T1，以为是和昨天 T1 一样水的题，结果死盯了一个半小时没有任何想法。心态差点爆炸。仔细思索了一会发现如果先尽量更新大的答案可以少做好多次，想了好多方法卡卡不掉，于是写了个似乎是 $O(n^2\\log n)$ 的程序继续了。 看 T2，发现 $O(n^2)$ 暴力分好少，没有思路之后看部分分。第一档想到树剖，写了一会发现从上往下的好像要二分，要么就得记一下经过的链还记向下的东西，感觉有点难写就弃了（我是 SB）。 弃了之后看链的分（为啥没想到倍增），在奇怪的脑环境下我想到一个 HH的项链 的做法，结果反着的写挂了。心态又差点爆炸。不过老夫调整了心态之后决定先写 T3 暴力，因为时间不多了。 T3 快速想出了阶乘的暴力并快速写完了。发现正解好像是状压，不过没心情管了。 剩下的时间都在调 T2 链的情况，最后也没调出来。在觉得 Day1 有可能暴毙的情况下打成这个样子我已经很满足了。 下考之后声音颤抖地问同学们 isdigit 是否在其他头文件被引用。yhw 安慰我 cstring 是包含它的，心情好了点。头脑空洞地走出校门好久，完全忘掉了父亲大人还在等我…… 还是想起来了。遇到这种事情有亲人在身边真好。我几乎已经做好了退役的准备了。zyt 学长说过，OI 最重要的是过程而非结果。现在回文化课未必不是一件好事，或者一种选择。即使有可能背负失望甚至嘲笑，既然我已经长大了，受挫也是难免的。 Day3、4回来在 NOI Lunux 试了一下，cstring 不行。几乎心肺停止（做了再好的准备也会这样）。不过试了一下 iostream 是可行的（心肺复苏），但是我实在忘了自己到底写没写 iostream 所以还是非常害怕。 想起了初中时同学（当时也是有力的竞争对手）在机房玩的 undertale 。又想到自己也许之后都没有机会在机房了，决定玩一下。 （然后就入粉了） 总之很好地转移了我的注意力。要不然我真的不知道这几天我应该怎么度过。 Day5今天是出成绩的日子，说是早上十点出，结果到目前为止（2021年4月14日18:13:33）都没有出成绩。害我们整个机房（和 lwc）白等了一早上和一下午。 下午六点终于出了源代码。我看了一下，Day1 引用了 iostream，悬着的心终于还是悬着，因为不知道成绩怎么样（好像很多人民间数据都考得比我高 QAQ）。 到目前为止的情况就是这样。因为我 NOIp 的成绩，我觉得自己还是有希望进省队的吧…… 对了，panyf AK! 真的谢谢 panyf XD UPD 4.15今天是真正出成绩的日子。 早上十点左右，咕了好久的 CCF 终于把名单发下来了。非常激动地打开。 先按照省选总分排序，发现我竟然是第五名……没想到 D1T2 真的被卡常了（不明智的选择）而且 D1T3 还只拿了第一档分数。 D2T2 这种人均切的题如果切了就进 A 队。不过 Day1 没有 CE 我已经是谢天谢地，也没有什么其他奢求了。（之后大概会都用万能头文件） 本来已经做好退役的准备，现在如果没有什么问题的话大概我要请大家吃饭是板上钉钉了。（幸亏我 NOIp 分数高） 可惜的是机房里只有六个人进了省队，三个同志因为在同一道题上的失误结束了 OI 生涯。希望这段时间的学习能让他们在文化课取得较好的成绩。我本来也是要退役的人，这次能有机会继续也是靠着他们的帮助。xgd 校队不会让他们失望的。我也会尽力不给他们丢脸。 当然，这次省选成绩不算太好，刘老师仍然认为我的实力不足（当然也是事实）。今后只有倍加努力了。（毕竟是 B 队）","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"NOIp 2020","slug":"NOIp 2020","date":"2020-12-07T02:57:00.000Z","updated":"2024-08-11T16:58:30.824Z","comments":true,"path":"2020/12/07/NOIp 2020/","permalink":"https://starcried.github.io/2020/12/07/NOIp%202020/","excerpt":"","text":"游记Day-1 我已经开始慌了。 不知道前路如何。不想回文化课。唯一一次机会，可是这几天却一直在颓，不颓就慌。 没心思写题，导致这几天看的题啥都不会。不知道考试当天又会出什么幺蛾子。 啊啊啊，烦。 有兽焉400话更新了，果然不负众望，我更加焦虑了。 想想CSP考场上干的事情，怎么都发挥不出自己的水平，还是因为我的水平真的…… 不想，不管，不慌，不慌。 父亲说我变了。几个月来，我确实变得——父亲说是——不太自信。也许是真的意识到了自己的差距，导致把这个事情当做了理所当然罢。这不好。 话说如此，无论我怎么慌，无论将来会发生什么事，现在，我只能任命运的三女神将我的命运安排。 Day 1考场。全部能写的写完，暴力都打满。 最后一个小时，我不知道自己应该干什么了。我认真思考了一下是否要玩扫雷，但还是尝试写了一下T4低维部分分。可惜，没有想到记忆化的方法，中间的贡献硬是在找循环节，结果没写出来。但是至少没有让我剩下的一个小时白白浪费（可能） 下考场，感觉自己考得还不错。 T1水题，但是我大意了，没想到要高精。（我劝毒瘤出题人耗子尾汁） T2我没预处理答案，用了个树状数组记录贡献，整体复杂度 $n\\ln n*(log n+26)$ 。但是这是我第一次在考场上用字符串哈希（不会用KMP），选的模数是 $1e9+17$ （非质数）（但是seed与其互质），所以我慌得一批。 T3只会暴力，用的方法是每次将一个塔距栈底最近的颜色不同的位置到栈顶所有的东西拿出去，然后将与它颜色相同的放进去。应该能过40分。 T4，就像我上面说的，没想到记忆化，30分白给。 我尽力了。我只能这么想。 Day 2luogu民间数据的测试成绩已经出来了，差不多就是估分成绩吧： $90 + 84 + 40 + 30 &#x3D; 244$ 大概就是这样了，实际上排名还是挺靠前的。无论结果怎么样，至少没给父母丢脸，没给赵班主任丢脸。 至于之后的路，还得我自己选。等成绩出来……再说。 另外，考完试的心情真是轻松。我好久没有体验到这种胜利(?)的感觉了owo Day 3一些同学已经回文化课去了，但只是一段时间，他们应该仍然会参加省选。 想当初我还对OI一窍不通，现在感觉真的已经入门了，这真得感谢所有无私奉献的、真诚（fAKe）善良的机房伙伴们。这几个月的生活一定会成为我人生中最珍贵的回忆之一，并且，可能这种生活还要持续一段时间呢。 等成绩出来，今天颓废了一天。写一写颓废（只看OI的伙计们可以散了） 刺客信条英灵殿云通关了。感触挺深的，现代剧情是真的NB，艾沃尔的人物形象也非常鲜活。可能是因为维京人可男可女不会因为性别导致个性缺陷（bushi） 简单来说，艾沃尔是奥丁血脉的继承者，在小时候被狼亲了一下导致奥丁血脉觉醒。CG最后的部分明显是有冰面破碎的，可能是奥丁救了艾沃尔，改变了命运。 艾沃尔最终战胜了奥丁，并不是用维京人所崇尚的战斗的方式，而是将自己的荣耀，代表能去英灵殿的斧子放手了。奥丁控制斧子应该就是说是利用维京人的尚武、希望能去英灵殿的心理来控制人类，但是艾沃尔放弃了奥丁所给的力量，荣耀，金钱等，和自己的信仰，得到了 everything else ，也明白了他父亲当时做的选择。 可惜，这并不能改变什么。这些古代的英雄们最终也没能知道自己在对抗什么。什么记忆的传承者，什么刺客无形者，人类本就是伊述人造出来的工具，无论祖先们经历了多少人间冷暖，明白了多少人间哲理，最后都会像 Ezio 一样，明白了自己的使命，或是工具人，或是完全没有，然后自己消逝。这一切都是伊述人的计划，对于他们，人类不过是载体，是工具，是私欲的产物。他们将自己的种族神化，利用人类的信仰和本性完成拯救自己种族的计划。在这样的世界观下，人类就是被限制了科技的井底之蛙，所谓自由意志和追求的信仰全部都是骗局，绝无翻身可能。 一不小心写多了。我的意思是，打不过了，我还是像艾沃尔一样专注于自己在乎的事情，不要像西格德一样傻不拉几。当只咸鱼他不香吗。 颓完了，OI还得继续。卷王们在卷LCT，我可不能落下。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"CSP-S 2020","slug":"CSP-S 2020","date":"2020-11-09T03:09:00.000Z","updated":"2024-08-10T09:45:42.773Z","comments":true,"path":"2020/11/09/CSP-S 2020/","permalink":"https://starcried.github.io/2020/11/09/CSP-S%202020/","excerpt":"","text":"Day 1游记个鬼啊就在自家学校&#x3D;-&#x3D; 早上宿舍待不了，去机房颓废，看了几集猫和老鼠，并且把看门狗军团的流程看完了（真棒），甚至在考试之前把老师给的巧克力也吃完了。 期间zyt学长来摸鱼。他们今天本来是学考模拟，结果下午要请考试假去参加另一个考试XD 老师说下午提前一个小时进场，所以早早回宿舍。1点多被回来的舍友吵醒了。脑子进入了一种困倦却清醒的状态，一直在想考试的事情，浑身发热却冷得颤抖，根本没办法再入睡。磨蹭了20分钟左右，准备去考场。 13:30，准时到达考场，结果监考老师甚至还没来。不让进考场。还是有一点困。 14:00，已经来了几个铁一初中部的学生。在考场门口长长的走廊上走来走去，聒噪得很。说着什么要考树上的数、树上的树、数上的数、数上的树……但我却实有一种不祥的预感。 进入考场。 T1模拟。我最不擅长的领域。而且是算日期。像我这种连今天日期和自己年龄都记不住，历史题一问年份绝对全错的人，一看到算年份的问题就直接去世。况且还区分了格里高利历和儒略历。特判太多。 其实每400年一个周期后内部直接暴力讨论就行。但是太懒，太傻，太着急。直接写个儒略历的分暂且跳过。 T2水题，但是会爆unsigned long long——但是我当时想的是 $n$ 不会等于0，于是写了个愚蠢的 $2^{63}-n+2^{63}$ 来表示 $2^{64}$ 。可惜，$n$ 可以为0。当时太着急，没看到。 还有就是，没有看到”所有的 $p_i$ 互不相同”的条件，傻不愣登的以为后重复结果写了个map，当时竟然以为能过。所以后面分直接白给。 半个小时写完T2之后，回去写T1，结果只剩半个小时的时候样例3还没过。看来这次已经挂了。喝口水冷静一下之后，决定放弃T1去打T3和T4暴力。 T3题目有点诡异，这种条件看起来像个图，后面的提示也提示了图。那么有可能是个类似有向图的什么东西？而且只有乘和加，根据这种运算的性质好像有点想法…… 但是再有想法现在没时间了。15min写了个线段树，结果乘法的tag忘记初始化为1。到最后都没发现。一出考场就发现了 T4只在开始的时候看了一眼，有想法，好像是原题，但是最后没写……本来会有70分，至少20分暴力分的。 出考场，知道已经凉了。好像除了我其他人都考得挺好的。 没有估分，不敢。 晚上到机房。和老师谈了一下。MY学长也在，他安慰了我一下，毕竟这次考试听说是不计入选省队的成绩的。而且有分就能去NOIP，下次好好考就行了。 老师早上被电动车撞了，肇事者逃逸，好像伤到神经了。 自己一个人在机房待到晚上。 川普同志败了。 Day +1:刺客信条：英灵殿 B站视频解说更新，快发售了 Day +2两天后。 程序下发，luogu民间数据出来。我测了90分。 哈哈。 早知道就把T1后面分直接扔掉，写写T3T4暴力都能多得点分。 现在心情简单。认真思考了一下要不要主动退役。还是看看NOIP成绩吧。 11.17 UPD 成绩出来了，145分。 第一题公元前的对了，只有40分，后来发现错误的点全是格里高利历的百年中的四年闰年，没取模，智障错误，难受。 第二题果然爆ULL了，眼瞎没看到数据范围，难受。 第三题暴力竟然能过70分，结果我线段树tag没初始化，白给了60分。智障错误，难受。 第四题考场上看出来暴力了，结果连20分都没来得及写。难受。 总结，白给了至少145分，都是在时间限制内能拿的分数。究其原因，经验不足是一方面，临场心态是一方面，根本上还是我太菜了。 菜，尽量改变，改变不了的部分就只能努力学习考场得分技巧了（ 还是挺难受的。希望NOIP我不退役。","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"CSP-S 2020 初赛","slug":"CSP-S 2020 初赛","date":"2020-10-11T07:19:00.000Z","updated":"2024-08-10T13:29:45.670Z","comments":true,"path":"2020/10/11/CSP-S 2020 初赛/","permalink":"https://starcried.github.io/2020/10/11/CSP-S%202020%20%E5%88%9D%E8%B5%9B/","excerpt":"","text":"游记个鬼啊跨条街就到了&#x3D;-&#x3D; 不分Day反正就一天。9:30开考，8:30起床。 下雨了，一出宿舍门整个学校全被白色的雾气笼罩。愚以为这是祥瑞之气，昨夜似有麒麟貔貅路过，祝我今日初赛RP++ …… 进场，去年的经验很有用，比如试题必须得先解压再用Adobe Reader打开才能看（毒瘤） 然而因为完全没复习，最后一道完成程序题全错。（虽然是模拟赛原题我还做过，但实在跟不上出题人的思路） 记录一下比赛时的心理过程： 就这就这就这？ 卧槽，内存不会算 卧槽，CRT咋算来着（然而可以枚举解决，但是我不知道为啥脑子抽风蒙了一个直接跳过） 卧槽，后缀表达式忘了 认不得香农……蒙一个冯·诺依曼吧（因为机房有他的画像） dfs的时间复杂度算错（e的复杂度因为是同阶的平常被省略了是吗……） 卧槽这个程序开了1e9的字符串数组哈哈哈哈哈 这个Map是个啥呀手动线性实现哈哈哈哈哈 感觉完成程序题还可以 最后一道题只剩15min做完的（结果最后一道全错） 时间复杂度问题错的好多QAQ还是太菜了QAQ 读程题，第二个一看就是nth_element实现（真的是这样实现的吗&#x3D;-&#x3D;）前几天刚看过，虽然有些蒙错了XD 字符串那个真……完了看不懂暴力了 下考之后似乎还浑身轻松。雨停了，直接回学校。中午以为机房有人，结果没有，懒得回宿舍，于是就在附近阶梯教室的椅子上睡了一个小时（冷） 对了下答案，好像只有我一个人考得那么菜。 没事，反正去年我瞎蒙都过了，今年再过不了了我直接退役算了。（反正少女省初赛分数线低） 最后模拜一下香农。 建议机房加挂这位伟人的画像","categories":[{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]}],"categories":[{"name":"教程","slug":"教程","permalink":"https://starcried.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"微光","slug":"微光","permalink":"https://starcried.github.io/categories/%E5%BE%AE%E5%85%89/"},{"name":"日记","slug":"日记","permalink":"https://starcried.github.io/categories/%E6%97%A5%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"https://starcried.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/categories/OI/"},{"name":"题解","slug":"题解","permalink":"https://starcried.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://starcried.github.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"C++","slug":"C","permalink":"https://starcried.github.io/categories/C/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://starcried.github.io/tags/blog/"},{"name":"手工","slug":"手工","permalink":"https://starcried.github.io/tags/%E6%89%8B%E5%B7%A5/"},{"name":"博客园","slug":"博客园","permalink":"https://starcried.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"Me","slug":"Me","permalink":"https://starcried.github.io/tags/Me/"},{"name":"ACM","slug":"ACM","permalink":"https://starcried.github.io/tags/ACM/"},{"name":"观后感","slug":"观后感","permalink":"https://starcried.github.io/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"},{"name":"OI","slug":"OI","permalink":"https://starcried.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"https://starcried.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"2-SAT","slug":"2-SAT","permalink":"https://starcried.github.io/tags/2-SAT/"},{"name":"Tarjan","slug":"Tarjan","permalink":"https://starcried.github.io/tags/Tarjan/"},{"name":"树状数组","slug":"树状数组","permalink":"https://starcried.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"二分","slug":"二分","permalink":"https://starcried.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"矩阵","slug":"矩阵","permalink":"https://starcried.github.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://starcried.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"数学","slug":"数学","permalink":"https://starcried.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"逆序对","slug":"逆序对","permalink":"https://starcried.github.io/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"二分法","slug":"二分法","permalink":"https://starcried.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"并查集","slug":"并查集","permalink":"https://starcried.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"分治","slug":"分治","permalink":"https://starcried.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"数论","slug":"数论","permalink":"https://starcried.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"exgcd","slug":"exgcd","permalink":"https://starcried.github.io/tags/exgcd/"},{"name":"点分治","slug":"点分治","permalink":"https://starcried.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"笛卡尔树","slug":"笛卡尔树","permalink":"https://starcried.github.io/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"name":"优化","slug":"优化","permalink":"https://starcried.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"线性代数","slug":"线性代数","permalink":"https://starcried.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"读后感","slug":"读后感","permalink":"https://starcried.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"游记","slug":"游记","permalink":"https://starcried.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]}